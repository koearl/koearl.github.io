<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Effective Java(with Spring core) | Koearl 的笔记</title><meta name="description" content="电子原版目录以及概要 请购买实体书籍，支持作者、翻译以及出版社 Creating and Destroying Objects用静态工厂方法代替构造器123public static Boolean valueOf(boolean b)&amp;#123;  return b ? Boolean.TRUE : Boolean.FALSE;&amp;#125;  静态工厂方法与设计模式中的工厂方法模式不同。并不能直"><meta name="keywords" content="Effective Java"><meta name="author" content="Koearl"><meta name="copyright" content="Koearl"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon-mine.png"><link rel="canonical" href="https://young1lin.github.io/2020/06/18/Effective-Java-With-Spring/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Effective Java(with Spring core)"><meta property="og:url" content="https://young1lin.github.io/2020/06/18/Effective-Java-With-Spring/"><meta property="og:site_name" content="Koearl 的笔记"><meta property="og:description" content="电子原版目录以及概要 请购买实体书籍，支持作者、翻译以及出版社 Creating and Destroying Objects用静态工厂方法代替构造器123public static Boolean valueOf(boolean b)&amp;#123;  return b ? Boolean.TRUE : Boolean.FALSE;&amp;#125;  静态工厂方法与设计模式中的工厂方法模式不同。并不能直"><meta property="og:image" content="https://i.loli.net/2021/05/28/BTcFLGYdr7msKXk.jpg"><meta property="article:published_time" content="2020-06-17T16:00:00.000Z"><meta property="article:modified_time" content="2021-10-04T14:28:30.298Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="大数据简介" href="https://young1lin.github.io/2020/06/18/BigData/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2ecae16d802e26c514db9438e830a2cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Koearl 的笔记" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2021/05/17/TkBDeC6rG1URKAj.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 歌单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 全部能听音乐</span></a></li><li><a class="site-page" href="/music-1/"><i class="fa-fw fas fa-music"></i><span> Best EDM of 2010-2019(Decade Mix)</span></a></li><li><a class="site-page" href="/music-2/"><i class="fa-fw fas fa-music"></i><span> The Best Of EDM 2010 - 2020</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 电影</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2021/06/15/film-mooc/"><i class="fa-fw fas fa-video"></i><span> 电影概论-Mooc</span></a></li><li><a class="site-page" href="/film-criticism/"><i class="fa-fw fas fa-video"></i><span> 电影批评</span></a></li><li><a class="site-page" href="/film-criticism/"><i class="fa-fw fas fa-video"></i><span> 电影艺术形式与风格</span></a></li></ul></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Creating-and-Destroying-Objects"><span class="toc-number">1.</span> <span class="toc-text">Creating and Destroying Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用静态工厂方法代替构造器"><span class="toc-number">1.1.</span> <span class="toc-text">用静态工厂方法代替构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遇到多个构造器参数时要考虑使用构建器"><span class="toc-number">1.2.</span> <span class="toc-text">遇到多个构造器参数时要考虑使用构建器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用私有构造器或者枚举类型强化Singleton属性"><span class="toc-number">1.3.</span> <span class="toc-text">用私有构造器或者枚举类型强化Singleton属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过私有构造器强化不可实例化的能力"><span class="toc-number">1.4.</span> <span class="toc-text">通过私有构造器强化不可实例化的能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先考虑依赖注入来引用资源"><span class="toc-number">1.5.</span> <span class="toc-text">优先考虑依赖注入来引用资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免创建不必要的对象"><span class="toc-number">1.6.</span> <span class="toc-text">避免创建不必要的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免使用finalizer方法，和Java9的cleaner方法"><span class="toc-number">1.7.</span> <span class="toc-text">避免使用finalizer方法，和Java9的cleaner方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resources-优先于-try-finally"><span class="toc-number">1.8.</span> <span class="toc-text">try with resources 优先于 try finally</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Methods-Common-to-All-Objects"><span class="toc-number">2.</span> <span class="toc-text">Methods Common to All Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候应该覆盖equals方法？"><span class="toc-number">2.1.</span> <span class="toc-text">什么时候应该覆盖equals方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#覆盖-equals-时总要覆盖-hashCode"><span class="toc-number">2.2.</span> <span class="toc-text">覆盖 equals 时总要覆盖 hashCode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#始终要覆盖toString"><span class="toc-number">2.3.</span> <span class="toc-text">始终要覆盖toString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎地覆盖-clone"><span class="toc-number">2.4.</span> <span class="toc-text">谨慎地覆盖 clone</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑实现-Comparable-接口"><span class="toc-number">2.5.</span> <span class="toc-text">考虑实现 Comparable 接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Classes-and-Interfaces"><span class="toc-number">3.</span> <span class="toc-text">Classes and Interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使类和成员的可访问性最小化"><span class="toc-number">3.1.</span> <span class="toc-text">使类和成员的可访问性最小化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使可变性最小化"><span class="toc-number">3.2.</span> <span class="toc-text">使可变性最小化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复合优于继承"><span class="toc-number">3.3.</span> <span class="toc-text">复合优于继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#要么设计继承并提供文档说明，要么禁止继承"><span class="toc-number">3.4.</span> <span class="toc-text">要么设计继承并提供文档说明，要么禁止继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口优于抽象类"><span class="toc-number">3.5.</span> <span class="toc-text">接口优于抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为后代设计接口"><span class="toc-number">3.6.</span> <span class="toc-text">为后代设计接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口只用于定义类型"><span class="toc-number">3.7.</span> <span class="toc-text">接口只用于定义类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类层次优先于标签类"><span class="toc-number">3.8.</span> <span class="toc-text">类层次优先于标签类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员类优先于非静态成员类"><span class="toc-number">3.9.</span> <span class="toc-text">静态成员类优先于非静态成员类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#限制源文件为单个顶级类-public-修饰与文件名相同的类"><span class="toc-number">3.10.</span> <span class="toc-text">限制源文件为单个顶级类(public 修饰与文件名相同的类)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generics"><span class="toc-number">4.</span> <span class="toc-text">Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用原生态类型"><span class="toc-number">4.1.</span> <span class="toc-text">不要使用原生态类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消除非受检的警告"><span class="toc-number">4.2.</span> <span class="toc-text">消除非受检的警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表优先于数组"><span class="toc-number">4.3.</span> <span class="toc-text">列表优先于数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先考虑范型"><span class="toc-number">4.4.</span> <span class="toc-text">优先考虑范型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先考虑范型方法-⬆️"><span class="toc-number">4.5.</span> <span class="toc-text">优先考虑范型方法 ⬆️</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用有限制通配符来提升-API-的灵活性"><span class="toc-number">4.6.</span> <span class="toc-text">利用有限制通配符来提升 API 的灵活性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎使用并用范型和可变参数"><span class="toc-number">4.7.</span> <span class="toc-text">谨慎使用并用范型和可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先考虑类型安全的异构容器"><span class="toc-number">4.8.</span> <span class="toc-text">优先考虑类型安全的异构容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Enums-and-Annotations"><span class="toc-number">5.</span> <span class="toc-text">Enums and Annotations</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用-enum-代替-int-常量"><span class="toc-number">5.1.</span> <span class="toc-text">用 enum 代替 int 常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用实例域代替序数（表示次序的数目）"><span class="toc-number">5.2.</span> <span class="toc-text">用实例域代替序数（表示次序的数目）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用-EnumSet-代替位域"><span class="toc-number">5.3.</span> <span class="toc-text">用 EnumSet 代替位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用-EnumMap-代替序数索引"><span class="toc-number">5.4.</span> <span class="toc-text">用 EnumMap 代替序数索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用接口模拟可扩展的枚举"><span class="toc-number">5.5.</span> <span class="toc-text">用接口模拟可扩展的枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解优先于命名模式"><span class="toc-number">5.6.</span> <span class="toc-text">注解优先于命名模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#坚持使用-Override-注解"><span class="toc-number">5.7.</span> <span class="toc-text">坚持使用 @Override 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用标记接口定义类型"><span class="toc-number">5.8.</span> <span class="toc-text">用标记接口定义类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambdas-and-Streams"><span class="toc-number">6.</span> <span class="toc-text">Lambdas and Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-优先于匿名类"><span class="toc-number">6.1.</span> <span class="toc-text">Lambda 优先于匿名类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法引用优先于-Lambda"><span class="toc-number">6.2.</span> <span class="toc-text">方法引用优先于 Lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#坚持使用标准的函数接口"><span class="toc-number">6.3.</span> <span class="toc-text">坚持使用标准的函数接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎使用-Stream"><span class="toc-number">6.4.</span> <span class="toc-text">谨慎使用 Stream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Methods"><span class="toc-number">7.</span> <span class="toc-text">Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检查参数的有效性"><span class="toc-number">7.1.</span> <span class="toc-text">检查参数的有效性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#必要时进行保护性拷贝"><span class="toc-number">7.2.</span> <span class="toc-text">必要时进行保护性拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎设计方法签名"><span class="toc-number">7.3.</span> <span class="toc-text">谨慎设计方法签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#慎用重载"><span class="toc-number">7.4.</span> <span class="toc-text">慎用重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#慎用可变参数"><span class="toc-number">7.5.</span> <span class="toc-text">慎用可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回零长度的数组或者集合，而不是-null"><span class="toc-number">7.6.</span> <span class="toc-text">返回零长度的数组或者集合，而不是 null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎返回-optional"><span class="toc-number">7.7.</span> <span class="toc-text">谨慎返回 optional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为所有到处的-API-元素编写文档注释"><span class="toc-number">7.8.</span> <span class="toc-text">为所有到处的 API 元素编写文档注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#General-Programing"><span class="toc-number">8.</span> <span class="toc-text">General Programing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#将局部变量的作用域最小化"><span class="toc-number">8.1.</span> <span class="toc-text">将局部变量的作用域最小化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先使用-foreach-而不是-for"><span class="toc-number">8.2.</span> <span class="toc-text">优先使用 foreach 而不是 for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解和使用类库"><span class="toc-number">8.3.</span> <span class="toc-text">了解和使用类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果需要精确的答案，避免使用-float-和-double"><span class="toc-number">8.4.</span> <span class="toc-text">如果需要精确的答案，避免使用 float 和 double</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型优先于装箱基本类型"><span class="toc-number">8.5.</span> <span class="toc-text">基本类型优先于装箱基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果其他类型更合适，尽量避免使用字符串"><span class="toc-number">8.6.</span> <span class="toc-text">如果其他类型更合适，尽量避免使用字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解字符串连接的性能"><span class="toc-number">8.7.</span> <span class="toc-text">了解字符串连接的性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过接口引用对象"><span class="toc-number">8.8.</span> <span class="toc-text">通过接口引用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#样例"><span class="toc-number">8.8.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口优先于反射机制"><span class="toc-number">8.9.</span> <span class="toc-text">接口优先于反射机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎使用本地方法"><span class="toc-number">8.10.</span> <span class="toc-text">谨慎使用本地方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎地进行优化"><span class="toc-number">8.11.</span> <span class="toc-text">谨慎地进行优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遵守普遍接受的命名惯例"><span class="toc-number">8.12.</span> <span class="toc-text">遵守普遍接受的命名惯例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题外话"><span class="toc-number">8.12.1.</span> <span class="toc-text">题外话</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exception"><span class="toc-number">9.</span> <span class="toc-text">Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#只针对异常的情况才使用异常"><span class="toc-number">9.1.</span> <span class="toc-text">只针对异常的情况才使用异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常"><span class="toc-number">9.2.</span> <span class="toc-text">对可恢复的情况使用受检异常，对编程错误使用运行时异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免不必要地使用受检异常"><span class="toc-number">9.3.</span> <span class="toc-text">避免不必要地使用受检异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先使用标准的异常"><span class="toc-number">9.4.</span> <span class="toc-text">优先使用标准的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抛出与抽象对应的异常"><span class="toc-number">9.5.</span> <span class="toc-text">抛出与抽象对应的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#每个方法抛出的所有异常都要建立文档"><span class="toc-number">9.6.</span> <span class="toc-text">每个方法抛出的所有异常都要建立文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在细节消息中包含失败-捕获信息"><span class="toc-number">9.7.</span> <span class="toc-text">在细节消息中包含失败-捕获信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#努力使失败保持原子性"><span class="toc-number">9.8.</span> <span class="toc-text">努力使失败保持原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要忽略异常"><span class="toc-number">9.9.</span> <span class="toc-text">不要忽略异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Concurrency"><span class="toc-number">10.</span> <span class="toc-text">Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步访问共享的可变数据"><span class="toc-number">10.1.</span> <span class="toc-text">同步访问共享的可变数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#避免过度同步"><span class="toc-number">10.2.</span> <span class="toc-text">避免过度同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#executor、task、stream-优先于线程"><span class="toc-number">10.3.</span> <span class="toc-text">executor、task、stream 优先于线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饱和策略"><span class="toc-number">10.3.1.</span> <span class="toc-text">饱和策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发工具优先于-wait-和-notify"><span class="toc-number">10.4.</span> <span class="toc-text">并发工具优先于 wait 和 notify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全性的文档化"><span class="toc-number">10.5.</span> <span class="toc-text">线程安全性的文档化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#慎用延迟初始化"><span class="toc-number">10.6.</span> <span class="toc-text">慎用延迟初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要依赖于线程调度器"><span class="toc-number">10.7.</span> <span class="toc-text">不要依赖于线程调度器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Serialize"><span class="toc-number">11.</span> <span class="toc-text">Serialize</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#其他方法优先于-Java-序列化"><span class="toc-number">11.1.</span> <span class="toc-text">其他方法优先于 Java 序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谨慎地实现-Serializable-接口"><span class="toc-number">11.2.</span> <span class="toc-text">谨慎地实现 Serializable 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑使用自定义的序列化形式"><span class="toc-number">11.3.</span> <span class="toc-text">考虑使用自定义的序列化形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保护性地编写-readObject-方法"><span class="toc-number">11.4.</span> <span class="toc-text">保护性地编写 readObject 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于实例控制，枚举类型优先于-readObject"><span class="toc-number">11.5.</span> <span class="toc-text">对于实例控制，枚举类型优先于 readObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#考虑用序列化代理代替序列化实例"><span class="toc-number">11.6.</span> <span class="toc-text">考虑用序列化代理代替序列化实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">12.</span> <span class="toc-text">References</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2021/05/28/BTcFLGYdr7msKXk.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Koearl 的笔记</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 歌单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 全部能听音乐</span></a></li><li><a class="site-page" href="/music-1/"><i class="fa-fw fas fa-music"></i><span> Best EDM of 2010-2019(Decade Mix)</span></a></li><li><a class="site-page" href="/music-2/"><i class="fa-fw fas fa-music"></i><span> The Best Of EDM 2010 - 2020</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 电影</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2021/06/15/film-mooc/"><i class="fa-fw fas fa-video"></i><span> 电影概论-Mooc</span></a></li><li><a class="site-page" href="/film-criticism/"><i class="fa-fw fas fa-video"></i><span> 电影批评</span></a></li><li><a class="site-page" href="/film-criticism/"><i class="fa-fw fas fa-video"></i><span> 电影艺术形式与风格</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Effective Java(with Spring core)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-18 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-10-04 22:28:30"><i class="fas fa-history fa-fw"></i> 更新于 2021-10-04</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/notes/">notes</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">17.2k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 69 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2020/06/18/Effective-Java-With-Spring/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/18/Effective-Java-With-Spring/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><a href="https://www.oreilly.com/library/view/effective-java/9780134686097/" target="_blank" rel="noopener">电子原版目录以及概要</a></p>
<p>请购买实体书籍，支持作者、翻译以及出版社</p>
<h1 id="Creating-and-Destroying-Objects"><a href="#Creating-and-Destroying-Objects" class="headerlink" title="Creating and Destroying Objects"></a>Creating and Destroying Objects</h1><h2 id="用静态工厂方法代替构造器"><a href="#用静态工厂方法代替构造器" class="headerlink" title="用静态工厂方法代替构造器"></a>用静态工厂方法代替构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态工厂方法与设计模式中的工厂方法模式不同。并不能直接对应设计模式的工厂方法。</p>
<p><strong>优势</strong></p>
<ul>
<li>有名字（像这种<code>BigInteger.probablePrime(int bitLength,Random rnd)</code>）</li>
<li>不必每次调用他们的时候，都创建一个新对象。像<code>Integer.MAX_VALUE = 0x7fffffff</code>（享元<code>Flyweight</code>模式）真正的享元模式如下，<code>Integer</code>中有个私有静态类，叫<code>IntergeCache</code></li>
<li>可以返回原返回类型的任何子类型的对象。<code>Java8</code>允许接口中含有静态方法，<code>Java9</code>允许接口中有私有的静态方法，但是静态域和静态成员变量仍然需要是公有的。</li>
<li>所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。</li>
<li>方法返回的对象所属的类，在便携包含该静态工厂方法的类时可以不存在。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 这里定义了最大值，也就是说这个可以配置</span></span><br><span class="line"><span class="comment">         * -XX:AutoBoxCacheMax=NNN，这里的 NNN 表示最大值是多少，只能改最大值，不能改最小值。</span></span><br><span class="line"><span class="comment">         * 在设置了-XX:+AggressiveOpts启动参数后，AutoBoxCacheMax的默认值会被修改为20000并且生效。</span></span><br><span class="line"><span class="comment">         * 这里的 -XX:+AggressiveOpts 是表示加快编译</span></span><br><span class="line"><span class="comment">         * aggressive adj.好争斗的, 挑衅的, 侵略性的</span></span><br><span class="line"><span class="comment">         * export JAVA_OPTS="-Xms2048m -Xmx2048m"。</span></span><br><span class="line"><span class="comment">         * 合起来翻译 积极的选择</span></span><br><span class="line"><span class="comment">         * - Tired compilers (hoping that it will make it into JDK7)</span></span><br><span class="line"><span class="comment">         * - Scalar replacement (and I am still hoping that this will remove some of the memory throughput preassure 64-bit brought)</span></span><br><span class="line"><span class="comment">         * EA and stack allocation</span></span><br><span class="line"><span class="comment">         * Code cache</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>缺点</p>
<ul>
<li>类如果不含公有或者受保护的构造器，就不能被子类化</li>
<li>难发现它们</li>
</ul>
<p><code>BeanDefinitionBuiler</code> 就是将<code>静态工厂方法</code> 和 <code>构建器</code> 模式结合的案例。</p>
<h2 id="遇到多个构造器参数时要考虑使用构建器"><a href="#遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="遇到多个构造器参数时要考虑使用构建器"></a>遇到多个构造器参数时要考虑使用构建器</h2><ul>
<li><p><code>JavaBean</code>模式（不推荐，当然我觉得不包括 <code>POJO</code> 类）</p>
</li>
<li><p><code>Builder</code>模式（<code>lombok</code>提供了<code>@Builder</code>注解，可以偷懒，但是就不要注解了，可以在顶部菜单栏<code>Refactor</code>使用 <code>delomok</code>生成相应代码）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样例</span></span><br><span class="line"><span class="comment">// spring-beans 下。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> AbstractBeanDefinition beanDefinition;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">int</span> constructorArgIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一般 BeanDefinitionBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinitionBuilder <span class="title">genericBeanDefinition</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = <span class="keyword">new</span> BeanDefinitionBuilder(<span class="keyword">new</span> GenericBeanDefinition());</span><br><span class="line">        builder.beanDefinition.setBeanClassName(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他相同类型方法.....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init-method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(@Nullable String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detroy-method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setDestroyMethodName</span><span class="params">(@Nullable String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setDestroyMethodName(methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scope  defualt singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setScope</span><span class="params">(@Nullable String scope)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setScope(scope);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他类型方法....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.validate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionAPI</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericBeanDefinition <span class="title">getGeneriBeanDefinition</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (GenericBeanDefinition)BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(<span class="string">"org.springframework.web.client.RestTemplate"</span>)</span><br><span class="line">            .setScope(<span class="string">"singleton"</span>)</span><br><span class="line">            .getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em style = "color:blue">如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是一种不错的选择</em></p>
<h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化<code>Singleton</code>属性</h2><p><em style="color:blue">如果要阻止反射实例化单例类，可以在被要求创建第二个实例的时候，抛出异常。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。</span></span><br><span class="line"><span class="comment">* 双检锁/双重校验锁（DCL，即 double-checked locking）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里检查是不是初始化过了</span></span><br><span class="line">        <span class="keyword">if</span>(singleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单元素的枚举类型经常成为实现<code>Singleton</code>的最佳方法。当然如果<code>Singleton</code>必须扩展一个超类，而不是扩展<code>Enum</code>的时候，则不宜使用这个方法。</p>
<p>下面是 Spring Boot 2.0 引入的单例类。具体执行顺序如下 </p>
<p><code>SpringApplication#run --&gt; SpringApplication#prepareEnvironment --&gt; SpringApplication#configureEnvironment --&gt; ApplicationConversionService#getSharedInstance</code><br>也是使用 DCL 思想（我觉得应该从 Stackoverflow 上面复制的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConversionService</span> <span class="keyword">extends</span> <span class="title">FormattingConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ApplicationConversionService sharedInstance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ApplicationConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ApplicationConversionService</span><span class="params">(StringValueResolver embeddedValueResolver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">         setEmbeddedValueResolver(embeddedValueResolver);</span><br><span class="line">      &#125;</span><br><span class="line">      configure(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a shared default application &#123;<span class="doctag">@code</span> ConversionService&#125; instance, lazily</span></span><br><span class="line"><span class="comment">    * building it once needed.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Note: This method actually returns an &#123;<span class="doctag">@link</span> ApplicationConversionService&#125;</span></span><br><span class="line"><span class="comment">    * instance. However, the &#123;<span class="doctag">@code</span> ConversionService&#125; signature has been preserved for</span></span><br><span class="line"><span class="comment">    * binary compatibility.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the shared &#123;<span class="doctag">@code</span> ApplicationConversionService&#125; instance (never</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConversionService <span class="title">getSharedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">      <span class="keyword">if</span> (sharedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (ApplicationConversionService<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">            <span class="keyword">if</span> (sharedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               sharedInstance = <span class="keyword">new</span> ApplicationConversionService();</span><br><span class="line">               ApplicationConversionService.sharedInstance = sharedInstance;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sharedInstance;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 省略一大段代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><p>像这种工具类就私有构造器。使用 final 防止继承，使用私有构造器防止实例化（开安全后防止反射实例化）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DateUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如 spring.core 中的 String 工具类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WINDOWS_FOLDER_SEPARATOR = <span class="string">"\\"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOP_PATH = <span class="string">".."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CURRENT_PATH = <span class="string">"."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> EXTENSION_SEPARATOR = <span class="string">'.'</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先考虑依赖注入来引用资源"><a href="#优先考虑依赖注入来引用资源" class="headerlink" title="优先考虑依赖注入来引用资源"></a>优先考虑依赖注入来引用资源</h2><p><em>通过依赖注入而非手动 new 对象，降低类于类之间的耦合度。而且应该尽量是基于接口而非实现来注入，这样更适合*</em>经常变更的类*<em>，或者模块</em>。当然，不是 Service 都需要写接口，除非你真的很需要，例如 SOA 程序、微服务程序，需要提供给外部 SDK。像 Spring Cloud 所有模块，以及 Spring 所定义的所有抽象一样，定义了统一的接口，引用的都是接口，而非实现类，Spring 统一的 Caching 等接口也是如此。</p>
<p>静态工具类和<code>Singleton</code>类不适合于需要引用底层资源的类。</p>
<p>关于解耦，右侧有更多解释。<a href="https://www.infoq.cn/article/8hlh2qEWP1Y00qumdMQj" target="_blank" rel="noopener">细数软件架构中的解耦</a></p>
<p>集中化配置，根据服务动态解析 IP 也算是解耦的方式。</p>
<p><em style='color:blue'>当创建一个新的实例时，就将该资源传到构造器中</em></p>
<p>依赖注入（<code>Dependency Injection</code>）</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/11/uEgJFLlyzrk951m.png" alt="Spring IoC"></p>
<p>类似的内容，在进程间的 Broker 消息模式也有体现。</p>
<p>关于构造器注入好，还是 <code>Setter</code> 注入好，个人认为是前者好。<code>Spring</code>作者也推荐前者，因为这样能判断你是不是传了非空、非法的参数。</p>
<p>如果想更深入了解如何实现循环依赖，在构造器注入如何实现，可以看看 ObjectProvider，以及 Spring Boot MyBatis 的内容，那个比较简单。</p>
<p><code>Spring</code> 中单例的对象，并不一定是全局唯一的，它是 每个<code>ClassLoader</code> 中唯一的，<code>static</code> 对象也是。所以插件 Spring Dev Tool 让项目重启，只需要新的 ClassLoader 加载这些内容。这里有个小知识点，就是分级处理。和 JVM 的分代处理其实是差不多的，就是将部分不变的类用固定的 ClassLoader 加载，项目中可变的类用新的 ClassLoader 加载，这样就实现每次代码变更，不用全部重新加载的功能了。当然，这里是简化了实现细节，内部实现没有这么简单。</p>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><ol>
<li>字符串循环累加</li>
<li>包装类型循环累加</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DON'T DO THIS面试经常问到这个，傻瓜才会这么写</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"bikini"</span>);</span><br><span class="line"><span class="comment">//正确的写法</span></span><br><span class="line">String s = <span class="string">"bikini"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于是否是罗马数字的正则校验   这样做不合理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matche(<span class="string">"^(?=.)M&#123;1,3&#125;?(CM|C?D|D?C&#123;1,3&#125;)?(XC|XL|L|L?X&#123;1,3&#125;)?(IX|I?V|V?I&#123;1,3&#125;)?$"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然String.matches方法最易于查看一个字符串是否与正则表达式相匹配，但并不适合在注重性能的情形中重复使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(<span class="string">"^(?=.)M&#123;1,3&#125;?(CM|C?D|D?C&#123;1,3&#125;)?(XC|XL|L|L?X&#123;1,3&#125;)?(IX|I?V|V?I&#123;1,3&#125;)?$"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器是指这样一个对象：它把功能委托给一个后备的对象（<code>backing object</code>），从而为后备对象提供一个可以代替的接口。</p>
<p><code>WebMvcConfigurerAdapter</code>这是个适配器，一般用于配置<code>web</code>的一些配置，如拦截器<code>Interceptor</code>，<code>JSONformatter</code>等，不过在<code>Java8</code>出来接口中声明 <code>default</code> 方法后，这个类就被声明 <code>@Deprecated</code>。</p>
<p><strong>优先使用基础类型而不是装箱基本类型，要当心无意识的自动装箱</strong>。(当然，实际生产中，除非你用于科学计算，一般都用包装类，例如 long 和 Long，小写的 l 容易看成大写 i 避免歧义)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐下面的写法，会让系统无意义得创建很多Long类型对象。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>;i &lt;= Integer.MAX_VALUE; i++)&#123;</span><br><span class="line">        <span class="comment">//就算是一行代码，我也推荐加上大括号，语义清晰</span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        <span class="comment">// 把数组中对象置空，防止内存泄漏</span></span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存泄漏的另一个常见来源是缓存。用<code>WeakHashMap</code>代表缓存。只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，<code>WeakHashMap</code>才有用处。</p>
<p>第三个常见来源是监听器和其他回调。可以借助 <code>Heap</code> 剖析工具（<code>Heap Profiler</code>）发现内存泄漏问题。</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/56214714" target="_blank" rel="noopener">ThreadLocal 是否存在内存泄漏问题，为什么？</a></p>
</li>
<li><p><a href="https://www.zhihu.com/org/a-li-yun-yun-qi-she-qu-48" target="_blank" rel="noopener">阿里云云栖号</a></p>
</li>
</ol>
<h2 id="避免使用finalizer方法，和Java9的cleaner方法"><a href="#避免使用finalizer方法，和Java9的cleaner方法" class="headerlink" title="避免使用finalizer方法，和Java9的cleaner方法"></a>避免使用<code>finalizer</code>方法，和<code>Java9</code>的<code>cleaner</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Clearner cleaner = Cleaner.create();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numJunkPiles;</span><br><span class="line">        State(<span class="keyword">int</span> numJunkPiles)&#123;</span><br><span class="line">            <span class="keyword">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Cleaning room"</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">int</span> numJunkPiles)</span></span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> State(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="keyword">this</span>,state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources-优先于-try-finally"><a href="#try-with-resources-优先于-try-finally" class="headerlink" title="try with resources 优先于 try finally"></a>try with resources 优先于 try finally</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path,String defualtVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path)))&#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// dual 表只在 Mysql 是默认有的，Oracle 查不到的</span></span><br><span class="line">        pst = conn.prepareStatement(<span class="string">"SELECT 1 FROM dual"</span>);</span><br><span class="line">        pst.execute();</span><br><span class="line">        rs = pst.getResultSet();</span><br><span class="line">        rs.getInt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 老程序猿是这样教的，当然实际生产中不要这么写，尽量细化异常，让不同异常，做不同的事</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pst != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pst.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 这里的 logger 是 Slf4j 获取的 Logger</span></span><br><span class="line">            logger.error(getStackTraceAsString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getStackTraceAsString</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">    e.printStackTrace(<span class="keyword">new</span> PrintWriter(stringWriter));</span><br><span class="line">    <span class="keyword">return</span> stringWriter.toString()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.7引入的语法糖，让代码更简洁</span></span><br><span class="line"><span class="comment">// try with resource 相当于默认加了finally块，并且默认添加 finally 块，其中调用实现了 AutoCloseable 接口的 close 方法</span></span><br><span class="line"><span class="comment">// AtuoCloseable 接口自 1.7 引入，让 Closeable 继承，而 Closeable @since 1.5</span></span><br><span class="line"><span class="comment">// InputStream &amp; OutputStream 都实现了 Closeable接口</span></span><br></pre></td></tr></table></figure>

<h1 id="Methods-Common-to-All-Objects"><a href="#Methods-Common-to-All-Objects" class="headerlink" title="Methods Common to All Objects"></a>Methods Common to All Objects</h1><h2 id="什么时候应该覆盖equals方法？"><a href="#什么时候应该覆盖equals方法？" class="headerlink" title="什么时候应该覆盖equals方法？"></a>什么时候应该覆盖<code>equals</code>方法？</h2><p>如果类具有自己特有的“逻辑相等”（<code>logical equality</code>）概念，而且超类还没有<code>equals</code>。这通常属于”值类“（<code>Value class</code>），值类仅仅是表示一个表示值的类，例如<code>Integer</code>或<code>String</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String foo = <span class="keyword">new</span> String(<span class="string">"str"</span>);</span><br><span class="line">String bar = <span class="keyword">new</span> String(<span class="string">"str"</span>);</span><br><span class="line">foo.equals(bar);<span class="comment">// true 比较的是对象内容，String重写了Object的equals方法</span></span><br><span class="line">foo == bar ;<span class="comment">// false 比较内存地址，只要内存地址为true，就一定是一样的对象</span></span><br><span class="line"><span class="comment">// 还有ons-client（RocketMQ的Java client） Subscription 订阅类，覆盖了equals方法，比较的是topic，只要topic相等，这个类就相等(dump)，但是他要根据不同 tag 获取不同消息内容，比如删除 人员信息的tag和新增人员信息的 tag 不一样。搞得我以不同 tag 为基础设置类，配置半天找不到问题。</span></span><br></pre></td></tr></table></figure>

<p><em style='color:blue'>equals方法实现了等价关系（<code>equivalence relation</code>）</em></p>
<p>放心，在《算法》Java 版本的这本书上也有介绍，这只是个基本的概念而已。</p>
<p>– 所有前提是 对于任何非<code>null</code>的引用值<code>x</code></p>
<ul>
<li>自反性（<code>reflexive</code>）：<code>x.equals(x)</code>必须为<code>true</code></li>
<li>对称性（<code>symmetric</code>）：如果x.equals(y)==true，必定y.equals(x);前提是两个非null</li>
<li>传递性（<code>transitive</code>）：<code>x.equals(y)==true</code>,<code>y.equals(z)==true</code>,<code>z.equals(x)==true</code>;</li>
<li>一致性（<code>consistent</code>）：当<code>x.equals(y)==true</code>时，只要在比较操作在对象中所用的信息没有被修改，多次调用，都是<code>true</code>。</li>
<li>任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(null)==true;</code></li>
</ul>
<p>里氏替换原则（<code>Liskov substitution principle</code>）认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoValueMoney</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getCurrency</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getAmount</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutoValueMoney <span class="title">create</span><span class="params">(String currency, <span class="keyword">long</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_AutoValueMoney(currency, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoValue_AutoValueMoney</span> <span class="keyword">extends</span> <span class="title">AutoValueMoney</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String currency;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> amount;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    AutoValue_AutoValueMoney(String currency, <span class="keyword">long</span> amount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currency == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(currency);</span><br><span class="line">        <span class="keyword">this</span>.currency = currency;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        h *= <span class="number">1000003</span>;</span><br><span class="line">        h ^= currency.hashCode();</span><br><span class="line">        h *= <span class="number">1000003</span>;</span><br><span class="line">        h ^= amount;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> AutoValueMoney) &#123;</span><br><span class="line">            AutoValueMoney that = (AutoValueMoney) o;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.currency.equals(that.getCurrency()))</span><br><span class="line">              &amp;&amp; (<span class="keyword">this</span>.amount == that.getAmount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenValueTypeWithAutoValue_whenFieldsCorrectlySet_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoValueMoney m = AutoValueMoney.create(<span class="string">"USD"</span>, <span class="number">10000</span>);</span><br><span class="line">    assertEquals(m.getAmount(), <span class="number">10000</span>);</span><br><span class="line">    assertEquals(m.getCurrency(), <span class="string">"USD"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="覆盖-equals-时总要覆盖-hashCode"><a href="#覆盖-equals-时总要覆盖-hashCode" class="headerlink" title="覆盖 equals 时总要覆盖 hashCode"></a>覆盖 equals 时总要覆盖 hashCode</h2><ul>
<li>在应用程序的执行期间，只要对象的<code>equals</code>方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，<code>hashCode</code>方法必须始终放回同一个值。在一个应用程序与另一个程序的执行过程中，执行hashCode方法所返回的值可以不一致。</li>
<li>两个对象<code>equals</code>调用相等，<code>hashCode</code>一定相等</li>
<li>两个对象<code>equals</code>调用不相等，<code>hashCode</code>可以一样。例如<code>String</code>的<code>hashCode</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;			</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选31*每个h值+每个char的值</span></span><br></pre></td></tr></table></figure>

<p>这是 <code>HashMap</code> 的实际的<code>put</code> 方法，里面通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果你是 new HashMap()创建的对象，默认这里的 resize() 大小是 16，DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 //aka 16 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      	<span class="comment">// 第一次创建 HashMap，如果没有特殊处理，这里的 table 为 null</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          	<span class="comment">//	也就是这里的 n = 16</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">      		<span class="comment">// 与 &amp; 操作两个操作数中位都为1，结果才为1，否则结果为0</span></span><br><span class="line">        	<span class="comment">// 这里是判断 tab[i] 数组上有没有对象，没有直接存，跳过下面 else 复杂的步骤</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">          	<span class="comment">// 这里就用到 equals 来判断了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h2><p>下面是<code>Spring</code>中的抽象<code>Bean</code>定义类重写的<code>hashCode()</code>和<code>toString()</code>方法，重写<code>toString()</code>让我们能更好的<code>debug</code>以及了解这个类属性。<code>String</code>的<code>hashCode</code>是以31为优选乘子，选择相邻的质数也是<code>ok</code>的，但是<code>31 = (2&lt;&lt;5) -1</code> ,可以被<code>JVM</code>优化。</p>
<div class="note danger">
            <p>不建议用 <code>Lombok</code>以及<code>AutoValue</code> 。代码是简洁了，维护起来很麻烦。</p>
          </div>

<ul>
<li>你使用了这些插件，你的组员也要用，如果你在内网开发，其他人没有这个插件，完全是个灾难。</li>
<li>代码是整洁了，但是维护起来很麻烦，不要图一时之快。</li>
</ul>
<p>当然你要用，要注意用<code>@Slf4j</code>，而不是<code>@Log4j</code>，<code>SpringBoot</code>默认使用<code>Logback</code>，你指定了<code>Log4j</code>，就会有冲突，你换成其他日志输出框架，那就有问题。<code>Slf4j</code>有桥接包，屏蔽了这些内容，让你可以<code>LoggerFactory.getLogger(xxx.class)</code>，而不用明确指定是哪个日志输出框架。</p>
<p>那<code>Spring</code> 和其他框架是怎么输出日志的呢，就是用 <code>apache.logging</code>包下的<code>protected final org.apache.commons.logging.Log logger = org.apache.commons.logging.LogFactory.LogFactory.getLog(this.getClass());</code>里面的<code>getLog</code>方法，再来了<code>LogAdpter.createLog()</code>这个 <code>LogAdpter</code>里面就是去找<code>slf4j</code>或者<code>log4j</code>内容，当然你用<code>Spring Boot</code>默认的 <code>logback</code>就用<code>Slf4j</code>再来个桥接包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_SPI = <span class="string">"org.apache.logging.log4j.spi.ExtendedLogger"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_SLF4J_PROVIDER = <span class="string">"org.apache.logging.slf4j.SLF4JProvider"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SLF4J_SPI = <span class="string">"org.slf4j.spi.LocationAwareLogger"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SLF4J_API = <span class="string">"org.slf4j.Logger"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LogAdapter.LogApi logApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LogAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是解析 <code>Spring</code> 中<code>AbstractBeanDefinition</code> 的 <code>toString()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.getBeanClassName());</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.scope);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.constructorArgumentValues);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.propertyValues);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.factoryBeanName);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.factoryMethodName);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + <span class="keyword">super</span>.hashCode();</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"class ["</span>);</span><br><span class="line">        sb.append(<span class="keyword">this</span>.getBeanClassName()).append(<span class="string">"]"</span>);</span><br><span class="line">        sb.append(<span class="string">"; scope="</span>).append(<span class="keyword">this</span>.scope);</span><br><span class="line">        sb.append(<span class="string">"; abstract="</span>).append(<span class="keyword">this</span>.abstractFlag);</span><br><span class="line">        sb.append(<span class="string">"; lazyInit="</span>).append(<span class="keyword">this</span>.lazyInit);</span><br><span class="line">        sb.append(<span class="string">"; autowireMode="</span>).append(<span class="keyword">this</span>.autowireMode);</span><br><span class="line">        sb.append(<span class="string">"; dependencyCheck="</span>).append(<span class="keyword">this</span>.dependencyCheck);</span><br><span class="line">        sb.append(<span class="string">"; autowireCandidate="</span>).append(<span class="keyword">this</span>.autowireCandidate);</span><br><span class="line">        sb.append(<span class="string">"; primary="</span>).append(<span class="keyword">this</span>.primary);</span><br><span class="line">        sb.append(<span class="string">"; factoryBeanName="</span>).append(<span class="keyword">this</span>.factoryBeanName);</span><br><span class="line">        sb.append(<span class="string">"; factoryMethodName="</span>).append(<span class="keyword">this</span>.factoryMethodName);</span><br><span class="line">        sb.append(<span class="string">"; initMethodName="</span>).append(<span class="keyword">this</span>.initMethodName);</span><br><span class="line">        sb.append(<span class="string">"; destroyMethodName="</span>).append(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"; defined in "</span>).append(<span class="keyword">this</span>.resource.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="谨慎地覆盖-clone"><a href="#谨慎地覆盖-clone" class="headerlink" title="谨慎地覆盖 clone"></a>谨慎地覆盖 clone</h2><p><strong>不可变的类永远都不应该提供<code>clone</code>方法</strong></p>
<p>实际上<code>clone</code>方法就是另一个构造器，必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件（<code>invariant</code>）。</p>
<p><code>Cloneable</code>架构与引用可变对象的final域的正常用法是不相兼容的。</p>
<p><code>HashMap.Entry</code>被加强了，它支持一个“深拷贝”<code>deepCopy()</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s/K0_FBX6pRJ-seUGKVqrY-w" target="_blank" rel="noopener">什么是深拷贝，什么是浅拷贝</a></p>
<p><code>Java Shallow clone</code></p>
<p><strong>Shallow clone</strong> is  default implementation  in Java. In overridden <code>clone</code> method, if you are not cloning all the object types (not primitives（原生类型）, then you are making a shallow copy.</p>
<p><code>Java Deep Copy</code></p>
<p>In the deep copy, we create a clone which is independent of original object and making changes in the cloned object should not affect original object.</p>
<h2 id="考虑实现-Comparable-接口"><a href="#考虑实现-Comparable-接口" class="headerlink" title="考虑实现 Comparable 接口"></a>考虑实现 Comparable 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this &lt; t &#x3D;&gt; -1，</span><br><span class="line"></span><br><span class="line">this &#x3D;&#x3D; t &#x3D;&gt; 0;</span><br><span class="line"></span><br><span class="line">this &gt; t &#x3D;&gt; 1;</span><br></pre></td></tr></table></figure>

<p>遵循下面几个规范</p>
<ul>
<li>sgn(x.compareTo(y)) == -sgn(y.compareTo(x));  类似1 == -(-1)</li>
<li>传递性，a&gt;b,b&gt;c     =&gt;   a&gt;c</li>
<li>如果x.compareTo(y) ==0，sgn(x.compareTo(z)) == sgn(y.compareTo(z))。a==b,a.f(c) == b.f(c)</li>
</ul>
<p>强烈建议<code>x 比 y == 0</code>，<code>x.equals(y) =&gt; true</code>,若违反了这个条件，都应该明确说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal foo = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal bar = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line">foo.equals(bar);<span class="comment">//false</span></span><br><span class="line">foo.compareTo(bar);<span class="comment">// 0	值相等</span></span><br></pre></td></tr></table></figure>

<p><em style="color:blue">在ocmpareTo方法中使用关系操作符 &lt; 和 &gt; 是非常繁琐的，而且容易出错，因此不建议使用</em></p>
<p>HashSet 会两个都存，TreeSet 只会存一个，因为利用了compareTo() 方法。<br>实现 Comparable 接口，有助于在有序集合中更好的排序。</p>
<h1 id="Classes-and-Interfaces"><a href="#Classes-and-Interfaces" class="headerlink" title="Classes and Interfaces"></a>Classes and Interfaces</h1><h2 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h2><p>区分一个组件设计得好不好，唯一重要的因素在于，它对外部的其他组件而言，是否隐藏了其内部数据和其他实现细节。设计良好的组件会隐藏所有的实现细节，把<code>API</code>与实现清晰地隔离开来。然后组件之间通过<code>API</code>通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏（<code>information hiding</code>）/封装（<code>encapsulation</code>），是软件设计的基本原则之一。</p>
<p>例如<code>Spring Boot 2.0</code>后的版本的<code>Spring Boot</code>，直接在<code>https://start.spring.io</code>直接生成就完事了，不像以前写一个<code>Web</code>应用先要<code>Servlet</code> 容器（<code>Tomcat/Jetty/Weblogic</code>等），再实现<code>javax.servlet.http.HttpServlet</code>重写它的<code>doGet/doPost</code>方法，甚至是<code>service</code>方法（不建议这么做，有关内容自己谷歌 <code>Http Code 304</code>），然后在 <code>web.xml</code>文件中添加这么一坨东西。</p>
<div class="tabs" id="content-1"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-1-1">Java代码部分</button></li><li class="tab"><button data-href="#content-1-2">web.xml部分</button></li><li class="tab"><button data-href="#content-1-3">有关 304 在HttpServlet及Servlet容器的实现</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import required java libraries</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend HttpServlet class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String message = <span class="string">"Hello World"</span>;</span><br><span class="line">        <span class="comment">// Set response content type</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        <span class="comment">// Actual logic goes here.</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>me.young1lin.HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloWorld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-3"><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/09/1cwSl6KMXNrVtY7.png" alt="Http Code 304.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p><a href="https://www.tutorialspoint.com/servlets/servlets-first-example.htm" target="_blank" rel="noopener">引用</a></p>
<p>当然这些东西不算完，还要放进<code>Servlet</code>容器中启动，最终返回信息。</p>
<p>而<code>Spring Boot</code>只需要简单几行代码的配置，就能启动一个<code>web</code>应用。</p>
<p>信息隐藏之所以重要，是因为</p>
<ol>
<li>有效地解除组成系统的各组件之间的耦合关系，即解耦（<code>decouple</code>），使得这些组件可以独立地开发、测试、优化、使用、理解和修改。</li>
<li>同时减轻了维护的负担。</li>
<li>隐藏实现，就可以使代码组件化，如果因为哪个组件性能差，就可以单独对这个组件进行优化。</li>
</ol>
<div class="note info">
            <p>尽可能地使每个类或者成员不被外界访问</p>
          </div>

<p>并且一个包级私有的顶层类（或者接口）只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个累的私有嵌套类（内部类）。像下面这样</p>
<div class="tabs" id="content-2"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-2-1">HashMap Node部分</button></li><li class="tab"><button data-href="#content-2-2">ArrayList 迭代器部分</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....省略一大段代码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;    </span><br><span class="line">          <span class="comment">// ......省略一大段代码</span></span><br><span class="line">      <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>公有类的实例域决不能是公有的，包含公有可变域的类通常并不是线程安全的。</p>
<p>虽然 ClassPathXmlApplicationContext 封装做的很好，但是学习起来比较费劲。</p>
<h2 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h2><p>善用<code>final</code>、加上<code>final</code>的静态工厂，享元模式。<code>BigDecimal.ZERO</code>，<code>Integer</code>的自动拆装箱里面的<code>CacheInteger</code>类。</p>
<h2 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h2><p>我觉得更优的翻译应该叫组合优于继承。当然，不是所有情况下都要用组合。《UNIX 编程艺术》中也提到，善用组合。</p>
<p>下面是 <code>Spring</code> 基石 <code>GenericApplicationContext</code> 中的源码，其中 <code>DefaultListableBeanFactory</code> 才是真正的容器。这个叫组合模式，两者都实现了同一个接口（<code>BeanFactory</code>），这里的 <code>DefaultListableBeanFactory</code> 可以是一个至多个，然后依次调用，直到返回结果为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略一大段代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .....省略一段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用内含的方式实现，例如<code>JFinal</code>中的<code>Record</code>对象，内含了一个<code>HashMap</code>对象，来实现一些操作。万物(单条数据)皆为<code>Record</code>。</p>
<p>Spring 中 ApplicationContext 类型的对象就是内涵了个 BeanFactory，其实就是 DefaultListableBeanFactory，也就是所谓的 IoC （Inversion of Control）容器。</p>
<h2 id="要么设计继承并提供文档说明，要么禁止继承"><a href="#要么设计继承并提供文档说明，要么禁止继承" class="headerlink" title="要么设计继承并提供文档说明，要么禁止继承"></a>要么设计继承并提供文档说明，要么禁止继承</h2><p>类必须精心挑选的受保护的（<code>protected</code>）方法，提供适当的钩子（<code>hook</code>），一边进入其内部工作中。</p>
<p>因为要符合里氏替换原则，之后开发的人，并不清楚你现在的类是什么意思。</p>
<h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><p>类是单继承，接口可以多实现，多接口可以实现不同业务需求，由于<code>1.8</code>后可以用<code>default</code>修饰接口方法，实现和抽象类一样的效果，又可以有实体方法，又有待子类实现的抽象方法。</p>
<p>Netty 中的 ChannelInboundHandler 就是个很好的例子。</p>
<p>多个接口方法同名，实现类报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">// 这样会报错，不知道你到底要返回什么类型，但是把B的void改成int，就不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是高度抽象的结果，而抽象类</p>
<h2 id="为后代设计接口"><a href="#为后代设计接口" class="headerlink" title="为后代设计接口"></a>为后代设计接口</h2><p>慎用 default 去修饰接口方法</p>
<p>BeanFactory 接口定义了最基本的容器功能。</p>
<h2 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h2><p>常量接口模式是对接口的不良使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XXXConstants</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MY_CONSTANTS = <span class="string">"my constants    "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.io.ObjectStreamConstants</code> 是个反例</p>
<p>如果要去定义常量</p>
<ol>
<li><p>要么在类内部定义，想 <code>Integer.MAX_VALUE</code>，<code>BigDecimal.ZERO</code>等等</p>
</li>
<li><p>要么用枚举实现，像我自定义的状态信息</p>
</li>
</ol>
<p>接口应该用来定义类型。</p>
<h2 id="类层次优先于标签类"><a href="#类层次优先于标签类" class="headerlink" title="类层次优先于标签类"></a>类层次优先于标签类</h2><p>字面意思。</p>
<p>像这种 <code>AbstractApplicationContext</code> 继承自 <code>DefaultResourceLoader</code>，拥有了资源加载的能力，像 EventObject 这种就是标记类，你可以加上，也可以不加，但是这是约定俗称的事件对象的类。</p>
<p>著名的标签接口（tagging interface）<code>java.util.EventListener</code>、<code>java.lang.Serializable</code>。注意这里是接口，平常项目开发也是会自己定义标记接口的，里面没有任何方法（行为），仅起到标记作用。这个是约定俗称的内容，你不遵守，等待的就是报错（例如 Java 序列化没有实现 Serializable 接口，就会报错）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A tagging interface that all event listener interfaces must extend.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员类优先于非静态成员类"><a href="#静态成员类优先于非静态成员类" class="headerlink" title="静态成员类优先于非静态成员类"></a>静态成员类优先于非静态成员类</h2><p><code>Builder</code></p>
<p><code>Map.Entry</code></p>
<h2 id="限制源文件为单个顶级类-public-修饰与文件名相同的类"><a href="#限制源文件为单个顶级类-public-修饰与文件名相同的类" class="headerlink" title="限制源文件为单个顶级类(public 修饰与文件名相同的类)"></a>限制源文件为单个顶级类(<code>public</code> 修饰与文件名相同的类)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pan"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"cake"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个不同文件，public 修饰的 class 为该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"bar"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(A.NAME+B.NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样有歧义，编译不给过，分开存。如果一定要放一起，就放在顶级类内部做静态成员类。</p>
<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p>翻译版本有误，<code>SINCE Java 5, generics have been a part of the language</code>. 翻译版本少了个 s 变成了 generic。因为 Think in Java 英文版中， generics 才是代表泛型。</p>
<h2 id="不要使用原生态类型"><a href="#不要使用原生态类型" class="headerlink" title="不要使用原生态类型"></a>不要使用原生态类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 别这样使用，报黄线是结果，原因是没有确定类型，那么就是任何类型都可以存入，如果存错了东西，取出来强制转换的时候，会报错。编译时给不了提示。</span></span><br><span class="line">List apples = <span class="keyword">new</span> ArrayList(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该这样用，编译器就会告诉你哪里出问题</span></span><br><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">apples.add(<span class="keyword">new</span> Banana());</span><br><span class="line"><span class="comment">//如果 Banana不是继承 Apple，就会报错</span></span><br></pre></td></tr></table></figure>

<p><code>List</code> 和 <code>List&lt;Object&gt;</code> 是有区别的，后者明确告诉该容器接受所有任意类型对象。</p>
<p>必须在类文字（<code>class literal</code>）中使用原生态类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="消除非受检的警告"><a href="#消除非受检的警告" class="headerlink" title="消除非受检的警告"></a>消除非受检的警告</h2><p><code>/uncheck/</code></p>
<p>⬆️尽量不要编译后出现这个（其实就是<code>@SuppreWarnings(&quot;unchecked&quot;)</code>），除非可以证明引起警告的代码是类型安全的，用 /uncheck/ 或者 <code>@SuppreWarnings(&quot;unchecked&quot;)</code>来禁止警告。尽可能在小的范围使用这个注解，像 <code>synchronized</code> 以及<code>catch Exception</code> 一样，尽可能精准，细粒度去做。这样好调试啊。</p>
<p>书上讲的 <code>ArrayList.toArray(T[] a)</code>方法，在 <code>JDK1.8</code> 中，源码是把去警告的注解放在方法上的，和他推荐的不一样。当然还是按照作者推荐的，这样让后人更容易懂你写的代码，尽量别写出祖传代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h2><p>除非写游戏类的，用二维数组表示坐标什么的，科学计算用基础类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译不报错，运行报错</span></span><br><span class="line">Object[] o = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"str"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">List&lt;Object&gt; o2 = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">ol.add(<span class="string">"str"</span>);</span><br></pre></td></tr></table></figure>

<p>范型数组不存在，编译不通过。</p>
<p>列表帮你做好了动态扩容，类型转换等操作。</p>
<h2 id="优先考虑范型"><a href="#优先考虑范型" class="headerlink" title="优先考虑范型"></a>优先考虑范型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前写 BaseDao 这种类时写的反射方法，也是 ORM 框架中会用到的方法。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="优先考虑范型方法-⬆️"><a href="#优先考虑范型方法-⬆️" class="headerlink" title="优先考虑范型方法 ⬆️"></a>优先考虑范型方法 ⬆️</h2><p>像上面这种</p>
<p>善用通配符，<code>E Element</code>，<code>T type</code>表示具体的类型，<code>K V key Value</code>，？ 不确定什么类型</p>
<p><code>JDK1.7</code>引入<code>@SafeVarargs</code> 放在方法上，消除使用范型方法警告</p>
<h2 id="利用有限制通配符来提升-API-的灵活性"><a href="#利用有限制通配符来提升-API-的灵活性" class="headerlink" title="利用有限制通配符来提升 API 的灵活性"></a>利用有限制通配符来提升 <code>API</code> 的灵活性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T extends Record&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContainAnnotation</span><span class="params">(Object target,Class&lt;? extends Annotation&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == target.getClass().getAnnotation(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="谨慎使用并用范型和可变参数"><a href="#谨慎使用并用范型和可变参数" class="headerlink" title="谨慎使用并用范型和可变参数"></a>谨慎使用并用范型和可变参数</h2><p>《阿里巴巴 Java 开发规范》中也明确指出了，少用甚至不用可变参数，这是个语法糖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;String&gt;...  stringLists)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">// 这样一起用，就要谨慎了。不安全，当遇到不同类型转换时，编译器不能把你的错误给指出来。</span></span></span><br></pre></td></tr></table></figure>

<p>如果真的方法是安全的，对于每一个带有范型可变参数或者参数化类型的方法，都要用<code>@SafeVarargs</code>进行注解.</p>
<h2 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h2><p>以前写的手动分页的类。,<code>List&lt;E&gt; Set&lt;E&gt; Map&lt;K,V&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size；</span><br><span class="line">  <span class="keyword">private</span> E[] list;</span><br><span class="line"> 	<span class="comment">//.... getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Enums-and-Annotations"><a href="#Enums-and-Annotations" class="headerlink" title="Enums and Annotations"></a>Enums and Annotations</h1><h2 id="用-enum-代替-int-常量"><a href="#用-enum-代替-int-常量" class="headerlink" title="用 enum 代替 int 常量"></a>用 enum 代替 int 常量</h2><p> <code>Java</code> 的枚举本质上是<code>int</code> 值。<code>《深入理解 Java 虚拟机》</code>介绍了枚举类其实是隐式继承了 <code>java.lang.Enum</code>这个类，所以枚举不能继承其他类，只能实现接口。</p>
<p>Java enums can extend <strong>java.lang.Enum</strong> class <strong>implicitly</strong>（隐含的）, so enum types cannot extend another class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeThingStatus</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用枚举替代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Status&#123;</span><br><span class="line">    Y,N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>根据枚举所作用的范围，尽可能贴合实际使用范围来定义枚举类该在类私有/包级私有/顶层类（<code>top-level class</code>）/顶层类的成员类。</p>
<p>策略模式枚举</p>
<p><code>trategy enum</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PayrollDay&#123;</span><br><span class="line">    MONDAY,TUESEDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY(PayType.WEEKEND),SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType paytype)&#123;<span class="keyword">this</span>.payType = payType;&#125;</span><br><span class="line"></span><br><span class="line">    PayrollDay()&#123;<span class="keyword">return</span> <span class="keyword">this</span>(PayType.WEEKDAY);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span> <span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> PayType&#123;</span><br><span class="line">        WEEKDAY&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minisWorked &lt;= MINIS_PER_SHIT ? <span class="number">0</span> : (minsWorked - NINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minsWorked * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> mins,<span class="keyword">int</span> payRate)</span></span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> basePay = minsWorked * payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当需要一组固定的常量，并且在编译时就知道其成员的时候，就应该使用枚举。如菜单的选项、操作代码以及命令行标记等。</p>
<p>策略模式 如 <code>org.springframework.core.io.Resource</code></p>
<ul>
<li><strong>UrlResource：</strong>访问网络资源的实现类。</li>
<li><strong>ClassPathResource：</strong>访问类加载路径里资源的实现类。</li>
<li><strong>FileSystemResource：</strong>访问文件系统里资源的实现类。</li>
<li><strong>ServletContextResource：</strong>访问相对于 ServletContext 路径里的资源的实现类.</li>
<li><strong>InputStreamResource：</strong>访问输入流资源的实现类。</li>
<li><strong>ByteArrayResource：</strong>访问字节数组资源的实现类。</li>
</ul>
<p>责任链模式，例如 Handler Interceptor，Filter 。如下所示：</p>
<p>DispatcherServlet 中的 service 方法，经过一些校验和一些参数设置，最终会调用这个方法，如果你懂了这个方法，Spring MVC 一般的情况都能 Hold 住了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">            Object dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = processedRequest != request;</span><br><span class="line">                <span class="comment">// HandlerMapping 会在系统启动的时候，把所有的 RequestMapping 相关的方法封装成 MethodHadler，注入进来</span></span><br><span class="line">                <span class="comment">// 先从 HandlerMapping 中获取对应的 Handler</span></span><br><span class="line">                mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                String method = request.getMethod();</span><br><span class="line">                <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">                <span class="comment">// 做一些优化，304 方面的。看文件没有没改动过，没有就直接返回请求。</span></span><br><span class="line">                <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// mapperHandler，执行 preHandle 方法。对应 Interceptor preHandle 的方法</span></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                <span class="comment">// 对应 Intercaptor 的 postHandler 方法。</span></span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                dispatchException = var20;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, var21);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, var23));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用实例域代替序数（表示次序的数目）"><a href="#用实例域代替序数（表示次序的数目）" class="headerlink" title="用实例域代替序数（表示次序的数目）"></a>用实例域代替序数（表示次序的数目）</h2><p>实例域 <code>ONE(1),TWO(2)</code></p>
<h2 id="用-EnumSet-代替位域"><a href="#用-EnumSet-代替位域" class="headerlink" title="用 EnumSet 代替位域"></a>用 EnumSet 代替位域</h2><p>让你用 <code>OR</code> 位运算将几个常量合并到一个集合中，称作位域（<code>bit field</code>）</p>
<p><code>Set set = EnumSet.of(ONE,TWO);</code></p>
<h2 id="用-EnumMap-代替序数索引"><a href="#用-EnumMap-代替序数索引" class="headerlink" title="用 EnumMap 代替序数索引"></a>用 EnumMap 代替序数索引</h2><p>麻烦，平时用不到</p>
<h2 id="用接口模拟可扩展的枚举"><a href="#用接口模拟可扩展的枚举" class="headerlink" title="用接口模拟可扩展的枚举"></a>用接口模拟可扩展的枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(String operation)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SubFoo implements Foo&#123;</span><br><span class="line">    A(<span class="string">"a"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String operation)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"a"</span>+operation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    B(<span class="string">"b"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String operation)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"b"</span>+operation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    SubFoo(String s)&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">boolean</span> <span class="title">updateUser</span>(<span class="title">User</span> <span class="title">user</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.updateUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ApiReturnObject</span> <span class="title">defaultExceptionHandler</span>(<span class="title">BindException</span> <span class="title">bindException</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理返回的错误信息</span></span><br><span class="line">    List&lt;ObjectError&gt; errors = bindException.getBindingResult().getAllErrors();</span><br><span class="line">    <span class="keyword">if</span>(errors.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ObjectError objectError = errors.get(<span class="number">0</span>);</span><br><span class="line">        ResultCode resultCode = ResultCode.FAILURE.setMessage(objectError.getDefaultMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiReturnUtil.failure(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ApiReturnUtil.failure(ResultCode.SYSTEM_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="坚持使用-Override-注解"><a href="#坚持使用-Override-注解" class="headerlink" title="坚持使用 @Override 注解"></a>坚持使用 @Override 注解</h2><p>保证写的代码，在编译时能检查得出来到底有没有重写 父类/接口 的方法。</p>
<h2 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h2><p>Spring 中的所有事件，默认继承 EventObject 这个也算是“接口”，一个不成文的规定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在使用 ObjectOutputstream 时，如果没有实现 Serializable 接口会报错，仅仅是个标记接口</span></span><br><span class="line"><span class="comment">* 在 writeObject0(Object obj, boolean unshared)中，显示的标注了，非 instance of Serializable 实现，将会抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="comment">// 防止被序列化，当然实现了某个接口，还是设置一下，还是会被序列化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> BigDecimal salary;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记注解</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Compment</span></span><br></pre></td></tr></table></figure>

<h1 id="Lambdas-and-Streams"><a href="#Lambdas-and-Streams" class="headerlink" title="Lambdas and Streams"></a>Lambdas and Streams</h1><h2 id="Lambda-优先于匿名类"><a href="#Lambda-优先于匿名类" class="headerlink" title="Lambda 优先于匿名类"></a>Lambda 优先于匿名类</h2><p>接口只有一个待实现方法时，可以转换成<code>Lambda</code> 写法。如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SayHelloInterface</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span></span>&#123;</span><br><span class="line">    SayHelloInterface hello = () -&gt; <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 <code>Comparable&lt;T&gt;</code>就是很好用 Lambda 写法的例子，而不是用匿名类去写。</p>
<p>如果 Lambda 没有名称和文档，并且有很多行，那就不要用。</p>
<h2 id="方法引用优先于-Lambda"><a href="#方法引用优先于-Lambda" class="headerlink" title="方法引用优先于 Lambda"></a>方法引用优先于 Lambda</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out::println</span><br><span class="line">Integer::parseInt</span><br></pre></td></tr></table></figure>

<p>方法引用详情见 《Java 8 实战》</p>
<h2 id="坚持使用标准的函数接口"><a href="#坚持使用标准的函数接口" class="headerlink" title="坚持使用标准的函数接口"></a>坚持使用标准的函数接口</h2><table>
<thead>
<tr>
<th align="center">接口</th>
<th align="center">函数签名</th>
<th align="center">范例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UnaryOperator<T></td>
<td align="center">T apply(T t)</td>
<td align="center">String::toLowerCase</td>
</tr>
<tr>
<td align="center">BinaryOperator<T></td>
<td align="center">T apply(T t1,T t2)</td>
<td align="center">BigInteger::add</td>
</tr>
<tr>
<td align="center">Predicate<T></td>
<td align="center">boolean test(T t)</td>
<td align="center">Collection::isEmpty</td>
</tr>
<tr>
<td align="center">Function&lt;T,R&gt;</td>
<td align="center">R apply(T t)</td>
<td align="center">Arrays::asList</td>
</tr>
<tr>
<td align="center">Supplier<T></td>
<td align="center">T get()</td>
<td align="center">Instant::now</td>
</tr>
<tr>
<td align="center">Consumer<T></td>
<td align="center">void accept(T t)</td>
<td align="center">System.out::println,Iterable<T>::forEach</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 Supplier 其实是下面的更简化版。</span></span><br><span class="line">Supplier&lt;Instant&gt; supplier = () -&gt; (Instant.now());</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code></p>
<p>这个注解有三个目的，</p>
<ol>
<li>告诉这个类及其文档的读者，这个接口是针对 Lambda 设计的。</li>
<li>这个接口不会进行编译，除非它只有一个抽象方法</li>
<li>避免后续维护人员不小心给该接口添加抽象方法</li>
</ol>
<p>必须使用这个注解对自己编写的函数接口进行标注。</p>
<h2 id="谨慎使用-Stream"><a href="#谨慎使用-Stream" class="headerlink" title="谨慎使用 Stream"></a>谨慎使用 Stream</h2><p>不建议使用 Stream 来进行 SQL 查询之类的操作。</p>
<p>过度地使用函数式编程，会导致代码可读性变差，强调不要滥用</p>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><h2 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法尽量是个动词，方法是行为/动作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(String str,Collection collection,Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(str))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是 apache common 包下的工具类，hutool 也有类似的类</span></span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(collection))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    Objects.requireNonNull(obj,<span class="string">"obj is null"</span>);</span><br><span class="line">    <span class="comment">// 其他操作....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在违背导出的方法，使用断言，确保什么时候能够调用这个方法</span></span><br><span class="line">    <span class="keyword">assert</span> str.length = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><p>对于参数类型可以被不可信任方子类化的参数，请不要使用 clone 方法进行保护性拷贝。</p>
<h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><p>代码整洁之道</p>
<p>对于参数类型，优先使用接口而不是具体实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Modify the application context's internal bean definition registry after its</span></span><br><span class="line"><span class="comment">    * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">    * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">    * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">		<span class="comment">//BeanDefinitionRegistry 常用实现为 DefaultListableBeanFactory，也有其他 ApplicationContext 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boolean 参数，优先使用两个元素的枚举类型。</p>
<h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><p>不要在重载方法中使用范型，或者继承关系类型。如 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAll(List&lt;?&gt; list);</span><br><span class="line"></span><br><span class="line">getAll(Collection&lt;?&gt; collection);</span><br></pre></td></tr></table></figure>

<p>需要调用哪个重载方法是在编译时作出决定的。</p>
<p>对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。</p>
<h2 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h2><p>可变参数其实是个语法糖</p>
<p>每次调用可变参数方法都会导致一次数组分配和初始化。有性能问题。可以适当的利用重载方法，替代可变参数方法。当然方法参数超过3个，就一起用可变参数，具体方法参数内容可以参考《代码整洁之道》。</p>
<p>最理想的参数数量是零，其次是一，再次是二，尽量避免三。有足够特殊的理由才能用三个以上参数（阿里巴巴Java开发手册：相同参数类型，相同业务含义，才可以使用 Java 的可变参数，可变参数放在最后，尽量不用可变参数，避免使用 Object）。</p>
<p><a href="https://yq.aliyun.com/articles/684075?spm=a2c4e.11155435.0.0.1e463312jtOsPe" target="_blank" rel="noopener">很久以前记的《代码整洁之道》的笔记</a></p>
<h2 id="返回零长度的数组或者集合，而不是-null"><a href="#返回零长度的数组或者集合，而不是-null" class="headerlink" title="返回零长度的数组或者集合，而不是 null"></a>返回零长度的数组或者集合，而不是 null</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getDigestKeyGen(String content)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">        bytes = xxxx;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="谨慎返回-optional"><a href="#谨慎返回-optional" class="headerlink" title="谨慎返回 optional"></a>谨慎返回 optional</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an &#123;<span class="doctag">@link</span> Optional&#125; wrapper for the specified dependency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;?&gt; createOptionalDependency(</span><br><span class="line">    DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="keyword">final</span> Object... args) &#123;</span><br><span class="line"></span><br><span class="line">    DependencyDescriptor descriptorToUse = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :</span><br><span class="line">                    <span class="keyword">super</span>.resolveCandidate(beanName, requiredType, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Object result = doResolveDependency(descriptorToUse, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Optional ? (Optional&lt;?&gt;) result : Optional.ofNullable(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line"><span class="comment">// 这个 value 就是该对象的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"><span class="comment">// 这里是空的兜底的策略时，返回的 Optional null 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>常用的方法 <code>Optional.ofNullable(result)</code>，返回一个<code>Optional(null)</code>或者 <code>Optional</code> 的包装对象的。</p>
<p><strong>Optional&lt;T&gt; 类代表的是一个不可变的容器，它可以存放单个非 null 的 T 引用，或者什么内容都没有</strong>。</p>
<ol>
<li><p>永远不要通过返回 Optional 的方法返回 null，因为它彻底违背了 optional（可选的） 的本意。</p>
</li>
<li><p>容器类型含<code>集合</code>、<code>映射</code>、<code>Stream</code>、<code>数组</code>和<code>optional</code>，都不应该被包装在 optional 中。</p>
</li>
<li><p>永远不要返回基本包装类型的 optional 。已经提供了 <code>OptionalInt</code>，<code>OptionalDouble</code>，<code>OptionalLong</code>等。</p>
</li>
<li><p>永远都不适合用 optional 作为键、值，或者集合或做数组中的元素。</p>
</li>
<li><p>尽量不要将 Optional 用作返回值以外的任何其他用途。</p>
</li>
</ol>
<p>用了 Optional，你就必须在调用方，做相应的判断，因为如果使用 <code>Optional.ofNullable(obj)</code>它有最差返回 <code>private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</code></p>
<h2 id="为所有到处的-API-元素编写文档注释"><a href="#为所有到处的-API-元素编写文档注释" class="headerlink" title="为所有到处的 API 元素编写文档注释"></a>为所有到处的 API 元素编写文档注释</h2><p>《代码整洁之道》—— 最好的注释是方法本身（见名知意、简短 <code>不超过 50 行</code>、方法参数最好不要超过 3 个、少用可变参数）。</p>
<p>当然这是一种比较极端的说法，好的 API 应该至少写出 what why how，这个方法是什么，为什么这么实现，以及如何使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface BeanFactory	</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment"> * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment"> * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment"> * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment"> * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>
<p>使用<code>{@literal}</code>忽略尖括号等需要转义的内容。如 <code>{@literal r &lt; 1}</code></p>
<h1 id="General-Programing"><a href="#General-Programing" class="headerlink" title="General Programing"></a>General Programing</h1><h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p><strong>只在需要用到变量的前一步，去声明变量。</strong></p>
<p>下面是<code>AutowiredAnnotationBeanPostProcessor</code>覆盖<code>SmartInstantiationAwareBeanPostProcessor</code>的方法。</p>
<p>具体执行步骤 <code>AbstractAutowireCapaleBeanFactory#doCreateBean</code> -&gt; <code>AbstractAutowireCapaleBeanFactory#createBeanInstance</code> -&gt; <code>AbstractAutowireCapaleBeanFactory#determineConstructorsFromBeanPostProcessors</code> -&gt; <code>SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors</code>  -&gt;<code>AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors</code></p>
<p>在属性填充之前，创建 beanWrapper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName)</span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let's check for lookup methods here..</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.doWithMethods(beanClass, method -&gt; &#123;</span><br><span class="line">                Lookup lookup = method.getAnnotation(Lookup<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">"No BeanFactory available"</span>);</span><br><span class="line">                    <span class="comment">// 检查 Lookup 方法，去覆盖原来的方法</span></span><br><span class="line">                    LookupOverride override = <span class="keyword">new</span> LookupOverride(method, lookup.value());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        RootBeanDefinition mbd = (RootBeanDefinition) <span class="keyword">this</span>.beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">                        mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                        <span class="string">"Cannot apply @Lookup to beans without corresponding bean definition"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Lookup method resolution failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lookupMethodsChecked.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略后面代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>for</code> 循环优先于 <code>while</code> 循环</p>
<h2 id="优先使用-foreach-而不是-for"><a href="#优先使用-foreach-而不是-for" class="headerlink" title="优先使用 foreach 而不是 for"></a>优先使用 foreach 而不是 for</h2><p>简洁、灵活、预防出错（当然在里面删除元素又进行遍历，是不行的）</p>
<p>不要在 foreach（增强 for 循环） 里面进行删除集合内部元素的操作。如果必要，请使用迭代器。</p>
<p><strong>什么时候不该用 foreach</strong></p>
<ol>
<li><p>解构过滤：就是上面的情况，使用 Collection#removeIf。</p>
</li>
<li><p>转换：就是要明确知道要替换的元素在哪几位的时候，予以替换的时候。</p>
</li>
<li><p>平行迭代：多层迭代，例如排序算法</p>
</li>
</ol>
<p><strong>正确的在遍历时删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">    Iterator&lt;User&gt; it = users.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        User user = it.next();</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span> &amp;&amp; <span class="string">"zhangSan"</span>.equals(user.name))&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="了解和使用类库"><a href="#了解和使用类库" class="headerlink" title="了解和使用类库"></a>了解和使用类库</h2><p>从 Java7 开始该使用 ThreadLocalRandom 而不是 Random</p>
<p>熟悉 java.lang、java.util、java.io及其子包中的内容。子包包括但不限于 java.util.concurrent，java.util.regex。</p>
<h2 id="如果需要精确的答案，避免使用-float-和-double"><a href="#如果需要精确的答案，避免使用-float-和-double" class="headerlink" title="如果需要精确的答案，避免使用 float 和 double"></a>如果需要精确的答案，避免使用 float 和 double</h2><p>float、double 适合科学计算。</p>
<p>使用 BigDecimal、Joda Money 进行金额计算。</p>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> != <span class="number">0.3</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">//0.1 +0.2===0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">0.3</span>;</span><br><span class="line">System.out.println(b-a == <span class="number">0.2</span>);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">double</span> d = b-a;</span><br><span class="line">System.out.println(d);<span class="comment">// 0.19999999999999998</span></span><br></pre></td></tr></table></figure>



<h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>基本类型比包装类型更省内存，性能更高。当然，业务对性能要求不是非常高的，可以用装箱的类型。</p>
<p>自动拆装箱会带来一些隐藏的问题，在《阿里巴巴 Java 开发手册》中介绍，统一使用装箱类型。</p>
<p>如果基本类型和装箱基本类型混合使用，装箱基本类型则会自动拆箱。</p>
<p>自动拆装箱本质上是为了简化开发，添加此类语法糖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时优化，自动装箱</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 实际上是 list.add(Integer.valueOf(1));</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 编译时优化，自动拆箱</span></span><br><span class="line">Integer a = <span class="number">129</span>;</span><br><span class="line">a = <span class="number">1</span> * a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动装箱时，会在 IntegerCache 中查找是否有缓存中的元素，有即返回，这个最大值可以设置，最小值为 -128，low=-128，</span></span><br><span class="line"><span class="comment">//  String integerCacheHighPropValue =</span></span><br><span class="line"><span class="comment">//                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如果其他类型更合适，尽量避免使用字符串"><a href="#如果其他类型更合适，尽量避免使用字符串" class="headerlink" title="如果其他类型更合适，尽量避免使用字符串"></a>如果其他类型更合适，尽量避免使用字符串</h2><p>不适合代替枚举类型的值、聚合类型、能力表（capabilities）。</p>
<p>ThreadLocal 如果用 String 作为 Key，那将是全局共享的，不妥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚合类型</span></span><br><span class="line">String compoundKey = className + <span class="string">"#"</span> + i.next();</span><br><span class="line"><span class="comment">// Spring 中也是这么做的。 </span></span><br><span class="line">String methodName = className + <span class="string">"#"</span>+ methodName;</span><br></pre></td></tr></table></figure>
<p><code>1kb = 1024 byte = 1024 * 8 bit</code></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>名称</td>
<td>长度</td>
<td>备注</td>
</tr>
<tr>
<td>byte</td>
<td>字节型</td>
<td>8bit</td>
<td>表示数据范围：-128~127</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>16bit</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td>16bit</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>32bit</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>8 byte</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型</td>
<td>4 byte</td>
<td>精度：7-8位</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8 byte</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>布尔型</td>
<td>true/false</td>
<td>实际用 byte 存储，0 为 false，1 为 true</td>
</tr>
</tbody></table>
<p>选择合适的类型，能使得占用内存更小。</p>
<p>当然，为防止伪共享，提高 CPU 执行效率，如果使用 volatile 关键字禁止 CPU 缓存，如果需要提升代码性能，需要额外填充其他对象。</p>
<p>如果一个对象包含线程局部变量且尺寸小于 64byte，就有可能发生伪共享。在Java7之前，一般通过对象填充的方式来避免伪共享问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java7 以前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedVolatileLong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java 8 加上注解，加上启动参数，自动填充。</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要给JVM加上启动项参数：</p>
<p><strong>-XX:-RestrictContended</strong></p>
<p>Hotspot虚拟机文档 “oops/oop.hp”有对Markword字段的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">64 bits:</span><br><span class="line">--------</span><br><span class="line">unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">Fruit fruit = <span class="keyword">new</span> Fruit();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Object 对象，Markword  8 个字节，kclass 4 个字节， 加起来 12 个字节，加上 4 个字节的对齐填充，占用的空间是 16 个字节。</p>
</li>
<li><p>Fruit 对象， Markword 8 个字节，kclass 4 个字节，还有个 size 成员变量，int类型占 4 个字节，加起来是 16 个字节，不需要对齐填充</p>
<p>缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。</p>
<p>共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>
</li>
</ul>
<h2 id="了解字符串连接的性能"><a href="#了解字符串连接的性能" class="headerlink" title="了解字符串连接的性能"></a>了解字符串连接的性能</h2><p>避免在循环使用 <code>+</code> 拼接字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">    String str = <span class="string">"1"</span> + strs[i];</span><br><span class="line">    <span class="comment">// 实际代码为</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">  *	sb.append(str);</span></span><br><span class="line"><span class="comment">  * sb.append(strs[i]);</span></span><br><span class="line"><span class="comment">  * sb.toString();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>更加灵活。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>实际碰到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = aService.getList();</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我需要按照构造器传入的 size 来截取 List，因为我客户端需要根据 pageSize 来获取指定 size 或小于该大小的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = aService.getList();</span><br><span class="line">    SubList subList = list.subList(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">   	<span class="keyword">return</span> <span class="keyword">new</span> ArrayList(subList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我只是需要个 JSON 数组，我并不需要 ArrayList 的特殊的方法，这样就是<strong>严重耦合</strong>的代码。</p>
<p>这个改成下面的，是不是更好点？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; list = aService.getList();</span><br><span class="line">    <span class="keyword">return</span> list.subList(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 中大量使用接口来引用，而非具体实现类。代码尽量使用依赖注入接口类型，实现实际类与调用类解耦。</p>
<p>如果没有合适的接口，就用<strong>类层次结构中提供了必要功能的最小的具体类</strong>来引用对象。</p>
<p>即如果要使用<code>ArrayList.trimToSize()</code>就声明为 <code>ArrayList</code> 引用，这是一种编程习惯，只用你用到的，只提供你想给外部调用的，不是全部，是部分（部分可以是全部）。</p>
<p>Spring 中是采用的流水线的思维方式，将各个阶段，抽象了出来，每个阶段都有其对应的接口抽象。</p>
<p>每个阶段的抽象。</p>
<ol>
<li>BeanFactory</li>
<li>Resource</li>
<li>BeanDefinition</li>
<li>BeanWrapper</li>
</ol>
<p>每个阶段中的前置后置处理抽象</p>
<ol>
<li>BeanFactoryPostProcessor（BeanFactory 启动的时候，可以在 <code>AbstractApplicationContext#invokeBeanFactoryPostProcessors</code> 中找到答案，打断点，自己慢慢看，就知道 @Component 是在这里的哪一步解析的了，启动一个随便什么的 Spring Boot 项目，即可查看具体内容）</li>
<li>BeanDefinitionRegistryPostProcessor（BeanDefnition 注册的时候）</li>
<li>MergedBeanDefinitionPostProcessor（GenericBeanDefinition 和其他 BeanDefinition 有个合并的过程，合并成 RooBeanDefinition，如果你看过小马哥的讲解的，这个其实是 XML 配置里面会出现的情况，一个 &lt;bean/&gt; 就是一个 RootBeanDefinition，当然，它会先包装成 GenericBeanDefinition 再进行合并）</li>
<li>SmartInstantiationAwareBeanPostProcessor（一般带 Smart 的，都要先一步执行，例如 SmartInitializingSingleton，会在单例对象<strong>预实例化</strong>阶执行，SmartInstantiationAwareBeanPostProcessor 的实现的抽象类 <code>AbstractAdvisorAutoProxyCreator</code> 和 AOP 相关，就在这一步，对要拦截的 Bean 进行拦截，然后代理，这里会有 Pattern 正则来匹配的过程，@Transaction 也是在这一步做的）</li>
<li>InstantiationAwareBeanPostProcessor</li>
<li>DestructionAwareBeanPostProcessor</li>
<li>BeanPostProcessor（上面所有 BeanPostProcessor 的父类，就是最卑微的，最后执行）</li>
</ol>
<h2 id="接口优先于反射机制"><a href="#接口优先于反射机制" class="headerlink" title="接口优先于反射机制"></a>接口优先于反射机制</h2><p><strong>详情见</strong></p>
<p>Spring <code>BeanProcessor</code></p>
<p>InitializingBean 和 DisposableBean，它们也可以用 @PostConstruct 和 @PreDestroy 代替，当然，两者一起也是可以的，具体执行顺序。</p>
<ul>
<li><p>@PostConstruct</p>
</li>
<li><p>InitializingBean</p>
</li>
<li><p>自定义初始化方法 </p>
</li>
<li><p>@PreDestroy 标注方法</p>
</li>
<li><p>实现 DisposableBean 接口的 destroy() 方法</p>
</li>
<li><p>自定义销毁方法 (destroy-mehod)</p>
</li>
</ul>
<p>Spring MVC <code>Interceptor</code></p>
<p>给定了模版类，调用模版类的模版方法。</p>
<p>如果使用反射机制</p>
<ul>
<li>损失了编译时类型检查的优势</li>
<li>执行反射访问所需要的代码非常笨拙和冗长</li>
<li>性能损失</li>
</ul>
<h2 id="谨慎使用本地方法"><a href="#谨慎使用本地方法" class="headerlink" title="谨慎使用本地方法"></a>谨慎使用本地方法</h2><p>native method 是与平台相关的，破坏了 Java 的移植性，如非必须情况，要避免使用本地方法。</p>
<p>可能的必要情况</p>
<ul>
<li>需要调用 dll 文件</li>
<li>需要真正高性能的高精度算术运算。</li>
</ul>
<h2 id="谨慎地进行优化"><a href="#谨慎地进行优化" class="headerlink" title="谨慎地进行优化"></a>谨慎地进行优化</h2><p>不等同于不要持续重构代码</p>
<h2 id="遵守普遍接受的命名惯例"><a href="#遵守普遍接受的命名惯例" class="headerlink" title="遵守普遍接受的命名惯例"></a>遵守普遍接受的命名惯例</h2><ol>
<li>包名com.xxxx，域名反写</li>
<li>类名 抽象类，BaseXXXXX，AbstractXXXXXX</li>
<li>变量名 局部变量名，String xxxStr，</li>
<li>方法名 方法名应该是个动词，如 createBean，getBean，表示的是类的行为。</li>
<li>get 是获取单个对象，list 是获取多个对象。</li>
</ol>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p><strong>怪罪于</strong> StringBuilder sb = new StringBuilder(100); 命名为 sb 的人，是真的 SB。本来就是局部变量用于拼接字符串的，没有很大的实际意义。</p>
<p>有些现代工具（MyBatis）依赖 Beans 命名惯例，setter getter，从数据库中取出值后，赋值需要调用 setter 类型方法。</p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h2><p>不要将异常作为普通的控制流。</p>
<h2 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可恢复情况</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.xxx.Driver"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编程错误使用 RuntimeException</span></span><br><span class="line"><span class="keyword">int</span> foo = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error 最好由 JVM 抛出，不适合自定义 Error</span></span><br></pre></td></tr></table></figure>

<h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>可以适当将 try catch 块重构为 if else 块。</p>
<h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p>类越精简，加载类的速度越快，优先使用专家级的定义的异常。加粗表示更为高频使用的，如</p>
<ul>
<li><p>IndexOfBoundsException</p>
</li>
<li><p>NullPointException</p>
</li>
<li><p><strong>IllegalArgumentException</strong></p>
</li>
<li><p><em>IllegalStateException*</em></p>
</li>
<li><p>IllegalAccessException</p>
</li>
<li><p>ConcurrentModificationException</p>
</li>
<li><p>UnsupportedOperationException</p>
</li>
</ul>
<h2 id="抛出与抽象对应的异常"><a href="#抛出与抽象对应的异常" class="headerlink" title="抛出与抽象对应的异常"></a>抛出与抽象对应的异常</h2><p>更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。</p>
<p>如果在 MyBatis 中，写 resultType 写成不存在的类，会先抛出 ClassNotFoundException，然后层层抛出，到 Spring 创建 Bean 的步骤中。最终由 Servlet 容器捕获，然后停止启动项目。<strong>可以自己手动试试</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Constructor&lt;?&gt;[] ctors, @Nullable Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>)).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.ConstructorResolver</span></span><br><span class="line"><span class="comment">// ConstructorResolver.ArgumentsHolder createArgumentArray 方法里面</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object autowiredArgument = resolveAutowiredArgument(</span><br><span class="line">        methodParam, beanName, autowiredBeanNames, converter, fallback);</span><br><span class="line">    args.rawArguments[paramIndex] = autowiredArgument;</span><br><span class="line">    args.arguments[paramIndex] = autowiredArgument;</span><br><span class="line">    args.preparedArguments[paramIndex] = <span class="keyword">new</span> AutowiredArgumentMarker();</span><br><span class="line">    args.resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="keyword">new</span> InjectionPoint(methodParam), ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常链（exception chaining），如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。Spring 就是这样。</p>
<p>实际 WEB 开发也是不要将异常捕获，尽量将异常向上抛出，最终由 <strong>容器/框架 *<em>进行 *</em>捕获/抛出</strong>。编写自定义含 @ExceptionHandler的类，进行捕获异常。</p>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 表单验证时异常返回信息</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bindException 绑定异常</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 带异常的 ResponseEntiy</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> 杨逸林</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2019-07-29 22:27</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">ResponseEntity</span>&lt;?&gt; <span class="title">defaultExceptionHandler</span>(<span class="title">BindException</span> <span class="title">bindException</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//处理返回的错误信息</span></span><br><span class="line">		List&lt;ObjectError&gt; errors = bindException.getBindingResult().getAllErrors();</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(errors)) &#123;</span><br><span class="line">			ObjectError objectError = errors.get(<span class="number">0</span>);</span><br><span class="line">			ResultCode resultCode = ResultCode.FAILURE.setMessage(objectError.getDefaultMessage());</span><br><span class="line">			<span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(resultCode);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意⚠️</p>
<p>这里必须使用 ResponseEntity，不要自定义的什么乱七八糟的返回，没有必要再套一层，HTTP 早就想到了，<strong>不要</strong>像下面这样返回！！多此一举，如果这么做，多半不了解 HTTP 的一些细节内容，前人早就帮你想好了。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span> : <span class="string">"404"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"can't find any matches response"</span>,</span><br><span class="line">    <span class="attr">"data"</span> : <span class="string">"404"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做，只会徒增前端的负担。</p>
<h2 id="每个方法抛出的所有异常都要建立文档"><a href="#每个方法抛出的所有异常都要建立文档" class="headerlink" title="每个方法抛出的所有异常都要建立文档"></a>每个方法抛出的所有异常都要建立文档</h2><p>永远不要声明一个公有方法直接 “throws Exception”。无法让调用者判断该如何解决并捕获该异常。</p>
<p>有个例外，就是 main 方法，它可以被安全地声明抛出 Exception，因为它只通过虚拟机调用。</p>
<p>还有就是 Spring Boot 的 CommandRunner，ApplicationRunner 以及 Spring 的 InitializingBean。注意这里的 @throws 需要你写清楚，像下面那样。如何写，在我的另一个我在公司分享的【代码规范】文章里面有讲解、翻译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Invoked by the containing &#123;<span class="doctag">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class="line"><span class="comment">    * and satisfied &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, &#123;<span class="doctag">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class="line"><span class="comment">    * configuration and final initialization when all bean properties have been set.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class="line"><span class="comment">    * essential property) or if initialization fails for any other reason</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在细节消息中包含失败-捕获信息"><a href="#在细节消息中包含失败-捕获信息" class="headerlink" title="在细节消息中包含失败-捕获信息"></a>在细节消息中包含失败-捕获信息</h2><p>为了捕获失败，异常的细节信息应该包含“对该异常由贡献”的所有参数和域的值。</p>
<p>以下是 Spring 启动创建 Bean 时失败，抛出异常的堆栈异常信息。PS：就是上面说的 MyBatis 改了 resultType 的异常。<strong>这里就是按层级抛出异常的案例</strong>。注意：Spring 是以流水线（Pipeline）的形式来处理的 Bean，看过卓别林的《摩登时代》里面就有他在拧螺丝，是流水线上的一环，也是一个阶段的处理者。流水线是福特提出的，并且作用于福特汽车的生产，极大得提高了生产力。在软件行业同样适用，如果你懂了 Spring 是流水线的处理思想（没什么书上提到流水线和 Spring 的关系），你就懂了大半的 Spring，其他的注解解析，派生等等内容都不难。思想很重要，每个人都需要拥有多个学科的知识，例如达芬奇是<strong>画家</strong>、科学家、发明家。这个观念在查理·芒格的《穷查理宝典》中反复被提及，值得一看的书籍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'callEvaluationController' defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/api/CallEvaluationController.class]: Unsatisfied dependency expressed through constructor parameter 0;</span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'userServiceImpl'</span>: Unsatisfied dependency expressed through method <span class="string">'setUserMapper'</span> parameter <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userMapper' defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/dao/main/UserMapper.class]: Cannot resolve reference to bean 'mainSqlSessionTemplate' while setting bean property 'sqlSessionTemplate'; </span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'mainSqlSessionTemplate' defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Unsatisfied dependency expressed through method 'sqlSessionTemplate' parameter 0;</span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mainSqlSessionFactory' defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Bean instantiation via factory method failed; </span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method <span class="string">'sqlSessionFactory'</span> threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: <span class="string">'file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]'</span>;</span><br><span class="line"></span><br><span class="line">nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is 'file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]'. Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Cause: org.apache.ibatis.type.TypeException: Could not resolve type alias 'java1.lang.Integer'.  Cause: java.lang.ClassNotFoundException: Cannot find class: java1.lang.Integer</span><br><span class="line"> <span class="comment">// 这其实是一行异常信息，我用换行分离出来 </span></span><br><span class="line"><span class="comment">// 层层嵌套，将必要的信息给暴露出来。</span></span><br></pre></td></tr></table></figure>

<p>不要在细节消息中包含密码、密钥以及类似的信息。输出异常消息日志时，或者正常日志时，一定要对敏感信息（用户名密码，用户名等等信息）进行脱敏操作。</p>
<h2 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h2><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p>
<p>使用 JDBC 操作数据库进行增/删/改时，出现失败的情况，应该进行事务回滚。</p>
<p>分布式系统中的 GET 操作即使失败，也要保持幂等性。</p>
<p>// TODO Spring Cloud 的中就是这么 GET 默认为幂等的，会一直调用，直到你没出错为止。这个就需要提到 HATEOS 以及 RESTful 的一些约定的一些内容。</p>
<h2 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h2><p>空的 catch 块会使异常达不到应有的目的。</p>
<p>如果选择忽略异常，catch 块中应该包含一条注释，说明情况，并将异常变量命名成 ignored</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(TimeoutException | ExecutionException ignored)&#123;</span><br><span class="line">    <span class="comment">// 这是一条注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>不要使用 Thread#stop 方法。</p>
<p>除非读和写操作都被同步，否则无法保证同步能起作用。</p>
<p>避免线程不安全的条件，可以有，避免共享，没有共享就没有伤害，使用 Synchronized/volatile/Atomic 类保证线程安全。</p>
<h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><p>使用 JUC 容器，如CopyOnWriteArrayList。</p>
<p>// TODO 死锁代码</p>
<h2 id="executor、task、stream-优先于线程"><a href="#executor、task、stream-优先于线程" class="headerlink" title="executor、task、stream 优先于线程"></a>executor、task、stream 优先于线程</h2><p>不要用 Executors 创建线程池，里面具体实现有无界队列，Integer.MAX_VALUE 等坑人的定义。无界队列会一直堆积请求，直到OOM，应该使用 ArrayBlockingQueue 这种有界队列。使用 Guava 中 ThreadFactoryBuilder 创建 ThreadFactory，而不是继承原生的（不仅麻烦，而且很多东西其实是重复的，就是为了给线程加个名字和其他一些自定义的内容），也可以用 Spring 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"><span class="comment">// 核心线程数，最大线程数，等待时间，时间单位，线程队列（应该用有界队列 ArrayBlockingQueue），线程工厂（继承 ThreadFactory），系统自带的拒绝策略 4 种 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>

<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ol>
<li>AbortPolicy：中止策略是默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException 调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</li>
<li>DiscardPolicy：当新提交的任务无法保存到队列中等待执行时，抛弃策略会悄悄抛弃该任务。</li>
<li>CallerRunsPolicy：调用者运行（Caller-Runs）策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛弃异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行该任务。</li>
<li>DiscardOldestPolicy：抛弃最旧的（Discard-Oldest）策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，那么”抛弃最旧的“策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。</li>
</ol>
<p>ForkJoinTask。// TODO 《Java 并发编程的艺术》解释，以及代码。Redis 子线程 Fork 父线程，进行集群同步。</p>
<p>并发的 Stream 是在 Fork Join 池上编写的。</p>
<h2 id="并发工具优先于-wait-和-notify"><a href="#并发工具优先于-wait-和-notify" class="headerlink" title="并发工具优先于 wait 和 notify"></a>并发工具优先于 wait 和 notify</h2><ul>
<li>Executor FrameWork </li>
<li>JUC 容器 ConcurrentHashMap（而不是 Collections.synchronizedMap/HashTable）</li>
<li>同步器 CountDownLatch，Semaphore,CyclicBarrier 和 Exchanger 等</li>
</ul>
<p>对于间歇式的定时，始终应该优先使用 System.nanoTime 而不是 System.currentTimeMillis</p>
<p>// TODO Spring 同步机制代码补充</p>
<p>始终应该使用 wait 循环模式来调用 wait 方法，永远不要在循环之外调用 wait 方法。</p>
<p>一般情况下，优先使用 notifyAll 方法。// 极客时间《并发编程》代码补充</p>
<h2 id="线程安全性的文档化"><a href="#线程安全性的文档化" class="headerlink" title="线程安全性的文档化"></a>线程安全性的文档化</h2><p>一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。</p>
<ul>
<li>不可变的（immutable）—— String、Long、BigInteger</li>
<li>无条件的线程安全（unconditionally  thread-safe）—— 这个类的实例是可变的，但是这个类有着足够的内部同步。AtomicInteger、ConcurrentHashMap</li>
<li>有条件的线程安全（conditionally thread-safe）—— 除了有些方法为进行安全的并发使用而需要外部同步之外，和无条件的线程安全相同。Collections.synchronized 包装返回的集合。</li>
<li>非线程安全（not thread-safe）—— 类实例是可变的。ArrayList、HashMap</li>
<li>线程对立的（thread-hostile）—— 类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。// TODO ThreadLocal？</li>
</ul>
<p>使用类内部私有锁对象。lock 域应该始终声明为 final。// TODO Spring 中也是这么做的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><p>Lazy Initialization 是指延迟到需要域的值时才将它初始化的行为。Spring Boot 中有 @Lazy 标注是否延迟初始化，如果标记了，则将会该 Bean 进行延迟初始化，只有在其他类真正使用时，进行初始化。</p>
<p><strong>大多数情况下，非延迟初始化优先于延迟初始化。</strong></p>
<p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）</p>
<p>除非绝对必要，否则就不要这么做。</p>
<p><strong>如果处于性能的考虑而需要对静态域使用延迟初始化，就使用 Lazy Initiazlization Holder Class 模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式（Double-Check Idiom）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 构造器检查，防止反射多次创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(instance != <span class="keyword">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 中使用单例注册表（Bean 容器）控制 Bean 的单例。</p>
<p><strong>有时可能需要延迟初始化一个可以接受重复初始化的实例域。可以使用单重检查模式（Single-Check Idiom）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FieldType result = filed;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">        field = result = computeFieldValue()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><p><strong>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的</strong></p>
<p>如果一个程序不能工作，是因为某些线程无法像其他线程那样获得足够的 CPU 时间片，那么，不要企图调用 Thread.yield 来 “修正” 该程序。</p>
<p>线程优先级时 Java 平台上最不可移植的特征了。设置了优先级，不代表一定会按优先级执行，而是“看情况”。</p>
<h1 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize"></a>Serialize</h1><h2 id="其他方法优先于-Java-序列化"><a href="#其他方法优先于-Java-序列化" class="headerlink" title="其他方法优先于 Java 序列化"></a>其他方法优先于 Java 序列化</h2><p>如果使用 Java 自带的反序列化，以下层次非常高的结构，会导致系统反序列化时占用大量资源。使用 JSON 代替 Java 中的序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] bomb()&#123;</span><br><span class="line">	Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; s1 = root;</span><br><span class="line">    Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(ini i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123; </span><br><span class="line">        Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        t1.add(<span class="string">"foo"</span>);</span><br><span class="line">        s1.add(t1);</span><br><span class="line">        s1.add(t2);</span><br><span class="line">        s2.add(t1);</span><br><span class="line">        s2.add(t2);</span><br><span class="line">        s1 = t1;</span><br><span class="line">        s2 = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialize(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="谨慎地实现-Serializable-接口"><a href="#谨慎地实现-Serializable-接口" class="headerlink" title="谨慎地实现 Serializable 接口"></a>谨慎地实现 Serializable 接口</h2><p>BigInteger、Instant 等值类应该实现 Serializable 接口，大多数的集合类也应该如此。代表活动实体的类，如线程池，一般不应该实现 Seriallizable 接口。</p>
<p>内部类不该实现 Serializable。</p>
<h2 id="考虑使用自定义的序列化形式"><a href="#考虑使用自定义的序列化形式" class="headerlink" title="考虑使用自定义的序列化形式"></a>考虑使用自定义的序列化形式</h2><p>跨语言的 Socket 通信，是自己实现序列化机制，包括 Redis，是以纯文本格式，换行的方式分隔操作符。</p>
<p>transient 表示该字段不能被序列化，当然实现了 // TODO 实现某个接口后，在方法中写明了字段，也是可以序列化的。</p>
<h2 id="保护性地编写-readObject-方法"><a href="#保护性地编写-readObject-方法" class="headerlink" title="保护性地编写 readObject 方法"></a>保护性地编写 readObject 方法</h2><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，必须做保护性拷贝。</p>
<h2 id="对于实例控制，枚举类型优先于-readObject"><a href="#对于实例控制，枚举类型优先于-readObject" class="headerlink" title="对于实例控制，枚举类型优先于 readObject"></a>对于实例控制，枚举类型优先于 readObject</h2><p>// TODO 不太理解</p>
<h2 id="考虑用序列化代理代替序列化实例"><a href="#考虑用序列化代理代替序列化实例" class="headerlink" title="考虑用序列化代理代替序列化实例"></a>考虑用序列化代理代替序列化实例</h2><p>使用静态内部类，代理外部类序列化内容，以及反序列化。</p>
<p>// TODO 代码</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><blockquote>
<p><a href="https://juejin.im/post/5c6698b6f265da2da23d17a8" target="_blank" rel="noopener">关于Integer面试的一个问题</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">VM系列三:JVM参数设置、分析</a></p>
</blockquote>
<blockquote>
<p><a href="http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2008-April/000110.html" target="_blank" rel="noopener">What does AggressiveOpts do with my timings?</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">科普：为什么 String hashCode 方法选择数字31作为乘子</a></p>
</blockquote>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1593982" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1593982</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/xx326664162/article/details/51743969" target="_blank" rel="noopener">https://blog.csdn.net/xx326664162/article/details/51743969</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43161690" target="_blank" rel="noopener">无声的性能杀手-伪共享(FalseSharing)</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/6844903873346453518" target="_blank" rel="noopener">重学Java-一个Java对象到底占多少内存</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Koearl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://young1lin.github.io/2020/06/18/Effective-Java-With-Spring/">https://young1lin.github.io/2020/06/18/Effective-Java-With-Spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://young1lin.github.io" target="_blank">Koearl 的笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Effective-Java/">Effective Java</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5efdebeafffaba83" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2020/06/18/BigData/"><img class="prev-cover" data-src="https://i.loli.net/2021/05/17/PB83r5w9ZEla7Tn.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大数据简介</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'm0gBGr4FkIgDqftQbXOmxAKE-gzGzoHsz',
  appKey: 'BNWTP7OOIGVhyWpa4I4mSw01',
  placeholder: '欢迎留言指正错误',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Koearl</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">善待家人 & 朋友 & 自己</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>
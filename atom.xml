<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yasir Lin 的笔记</title>
  <icon>https://young1lin.github.io/img/favicon-mine.png</icon>
  
  <link href="https://young1lin.github.io/atom.xml" rel="self"/>
  
  <link href="https://young1lin.github.io/"/>
  <updated>2023-11-23T16:20:46.282Z</updated>
  <id>https://young1lin.github.io/</id>
  
  <author>
    <name>Yasir Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>找一份工作</title>
    <link href="https://young1lin.github.io/2023/07/06/get-a-job/"/>
    <id>https://young1lin.github.io/2023/07/06/get-a-job/</id>
    <published>2023-07-05T16:00:00.000Z</published>
    <updated>2023-11-23T16:20:46.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="找一份合适的工作需要做什么"><a href="#找一份合适的工作需要做什么" class="headerlink" title="找一份合适的工作需要做什么"></a>找一份合适的工作需要做什么</h1><p>根据时间排序，分为面试前、面试时、面试后。</p><p>面试前</p><ol><li><p>找到你去的公司（明确你的目标）</p></li><li><p>准备简历</p><ol><li><p>书写简历</p><ol><li>格式</li></ol></li><li><p>投递简历方式</p><ol><li><p>内推</p><ol><li>V2ex 这类社群</li></ol></li><li><p>Boss 直聘</p></li><li><p>公司招聘官网</p></li></ol></li></ol></li><li><p>准备自我介绍（背熟，根据工作时间渐进式介绍你自己，一定要时刻保持自信的口吻讲述）</p></li><li><p>复习将要面试的点</p><ol><li>笔试</li><li>八股文</li><li>HR 提问</li></ol></li><li><p>了解公司背景业务</p><ol><li>找到它的官网</li><li><a href="https://zj.gsxt.gov.cn/index.html" target="_blank" rel="noopener">国家企业信用信息公示系统</a></li><li>钉钉里面的 钉钉企典</li><li>Google</li><li>知乎（看看就行）</li></ol></li><li><p>了解该岗位（后面面试时会问，需要你反问面试官）</p><ol><li>看工作职位描述</li><li>面试前直接问 HR</li><li>网上搜索</li></ol></li></ol><p>面试时</p><ol><li>笔记<ol><li>算法题<ol><li>需要你时刻与你的面试官进行交流，你的困惑的点，你将要以什么方法去解决。千万不要笔试的时候一言不发，写代码。面试官会认为你这个人不会与他人交流沟通，定点上报的你工作内容，与上级保持良好的沟通也是你工作中重要的。你做了很牛逼的事情，比如优化了个接口，TPS 翻倍，平均响应延迟减半，要写出来，要和你上级及时的沟通。千万千万不要闷头干事，很蠢的。</li></ol></li><li>非算法题</li></ol></li><li>面试</li></ol><h1 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h1><h2 id="找到你想要去的公司"><a href="#找到你想要去的公司" class="headerlink" title="找到你想要去的公司"></a>找到你想要去的公司</h2><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="面试前问题准备"><a href="#面试前问题准备" class="headerlink" title="面试前问题准备"></a>面试前问题准备</h2><p>按重要程度，出现频率排序。</p><ol><li>准备好你的自我介绍可能招来的问题。</li><li>你的职业规划是什么？</li><li>为什么考虑我们公司？</li><li>有什么要问我的问题吗？</li><li>你认为自己取得的最大成绩是什么？是哪些因素造就了你取得这样的成绩？</li><li>你觉得你工作/学习这些年，带给你最大的变化是什么？</li><li>你觉得你是个什么样的人（如何简短几句评价你自己）？</li></ol><p>推荐这个<a href="https://www.youtube.com/channel/UCIIZW9HopU9GrQMfM_YpY2g" target="_blank" rel="noopener">频道</a>，看他最受欢迎几个面试的视频。</p><h3 id="知己解彼"><a href="#知己解彼" class="headerlink" title="知己解彼"></a>知己解彼</h3><h3 id="专注一段时间，做好一件事"><a href="#专注一段时间，做好一件事" class="headerlink" title="专注一段时间，做好一件事"></a>专注一段时间，做好一件事</h3><h2 id="面试中需要注意的事项"><a href="#面试中需要注意的事项" class="headerlink" title="面试中需要注意的事项"></a>面试中需要注意的事项</h2><p>Boss 面需要引导他谈论的内容，以及你表述内容的主题应该必须包括四大块内容。</p><ol><li>对公司的了解，对工作岗位的内容的了解，并且展现出对公司的极大兴趣。</li><li>保持积极的心态应答相应问题。</li><li>准备好常见的问题回答</li><li>准备好有水准的反问问题。</li></ol><p>还有一个简历的问题，关于书写简历，可以参考[这个](<a href="https://github.com/young1lin/notes/blob/master/Prepare" target="_blank" rel="noopener">https://github.com/young1lin/notes/blob/master/Prepare</a> for Interview/Java_工程师_张三_zh.md)。</p><h1 id="了解公司"><a href="#了解公司" class="headerlink" title="了解公司"></a>了解公司</h1><p>可以去以下途径了解公司，了解方向，包括公司主营业务、你要做的业务的方向内容、公司信用信息。</p><ol><li>公司官网</li><li>钉钉企典（去钉钉里面搜）</li><li>企查查、天眼查</li><li><a href="https://zj.gsxt.gov.cn/index.html" target="_blank" rel="noopener">国家企业信用信息公示系统</a></li><li>看准网、职友集</li></ol><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ol><li>引导面试官，往你熟悉的领域，或者已经准备好比较完美的答案的问题上。</li><li>如果面试官提出一个比较模糊的问题，你可以通过询问等方式，丰富明确问题。</li></ol><h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><ol><li>对公司了解，并且展现出对公司的兴趣。</li><li>了解该岗位实际的工作内容，有意展现出你能胜任这方面的工作。</li><li>一定要是积极的心态，讲述他人或者一些事情的时候，千万千万不要展现出一点点消极的心态（但凡有一点，别人是能感受出来的）</li><li>准备好反问的问题</li></ol><h1 id="可参考的节目"><a href="#可参考的节目" class="headerlink" title="可参考的节目"></a>可参考的节目</h1><p>令人心动的 Offer</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://www.bilibili.com/video/BV1GS4y1d734/" target="_blank" rel="noopener">三种方法教你查询企业信息</a></li><li></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="Interview" scheme="https://young1lin.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>原则</title>
    <link href="https://young1lin.github.io/2022/03/03/principles/"/>
    <id>https://young1lin.github.io/2022/03/03/principles/</id>
    <published>2022-03-02T16:00:00.000Z</published>
    <updated>2022-09-05T14:35:44.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><p>对我而言，有意义的工作是指一项我能全身心投入的使命；有意义的人际关系是指我既深深地关心对方，对方也深深地关心我。</p></li><li><p>我发现，我能够成功的唯一途径将是：</p><p>1．找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。</p><p>2．知道自己在什么时候不能有明确的意见，不急于下结论。</p><p>3．逐步归纳永恒和普适的原则，对其进行测试，将其系统化。</p><p>4．通过平衡风险来保持较大的回报，并降低下行波动。</p></li><li><p>我逐渐认识到，股价反映了人们的预期，所以当实际结果比预期好时，股价上涨；当实际结果比预期差时，股价下跌。而大多数人会因为近期的经验而产生偏见。</p></li><li><p>通过市场交易赚钱是很困难的。对此，才华横溢的交易者和投资家伯纳德·巴鲁克形象地说道：“如果你已经做好准备放弃一切其他东西，像医科学生研究解剖一样仔细地研究市场的整个历史和背景，并研究所有主要上市公司——如果你能做到上述的一切，同时你还拥有赌博者的镇定、洞察者的第六感和狮子的勇气，你才有可能抓住一丝机会。”</p></li><li><p>我了解到，如果你以勤奋和有创造性的方式工作，你几乎可以得到你想要的任何东西，但你不可能同时得到所有东西。成熟意味着你可以放弃一些好的选择，从而追求更好的选择。</p></li><li><p>就我们一致同意的相处规范而言，最重要的一条是，我们需要做三件事：</p><p>1．把我们的真实想法摆在桌面上；</p><p>2．存在经过深思熟虑的分歧，但人们愿意在相互了解的过程中更改观点；</p><p>3．如果分歧依然存在，拥有一种大家一致同意的决策方式（如投票或者拥有清晰的权威），以便我们能够不带怨气地把分歧留在身后。</p></li><li><p>管理的资金太多有可能损害业绩，原因是太大的规模会影响市场走向，导致建仓和平仓的成本很高。在2010年实现超过40%的收益率后，我们不得不考虑向客户退回很多资金，尽管他们其实希望将更多的钱交由我们管理。我们一直谨慎地让自己不要变得过大，以免竭泽而渔。</p></li><li><p>在我看来，人生由三个阶段组成：在第一个阶段，我们依赖其他人，我们学习；在第二个阶段，其他人依赖我们，我们工作；在第三个阶段，当其他人不再依赖我们、我们也不必再工作时，我们就可以自由地体验生活了。</p></li><li><p>王岐山：有能力的人居安思危。安然无忧的是愚人。假如冲突能在变得尖锐之前被解决的话，世界上就不会有英雄了。</p></li><li><p>做到头脑极度开放、极度透明</p><ul><li><strong>对于快速学习和有效改变而言，头脑极度开放、极度透明是价值无限的</strong>。学习过程是一连串的实时反馈循环：我们做决定，看到结果，然后根据结果改进对现实的理解。做到头脑极度开放能够增强这些反馈循环的效率，因为这能让你和其他人无比清晰地看到你在做什么、为什么这么做，而不会产生误解。你的头脑越开放，你就越不会自欺，其他人也就越会给你诚实的反馈。如果他们是“可信”的人（知道什么样的人是“可信”[插图]的也很重要），你就会从他们那里受益良多。</li><li><strong>不要担心其他人的看法，使之成为你的障碍</strong>。</li><li><strong>拥抱极度求真和极度透明将带来更有意义的工作和更有意义的人际关系</strong>。</li></ul></li><li><p>人在尝试理解任何东西（经济、市场、天气等）时，都可以从两种视角出发：</p><p>1．自上而下：努力找到这些东西背后的唯一驱动法则或规律。例如，在理解市场时，人可以研究影响所有经济和市场的普适法则，如供求关系；在理解物种时，人可以集中了解基因密码是如何对所有物种发生作用的。金字塔原理，结构化思维。</p><p>2．自下而上：研究每种具体情况及其背后的法则或规律，例如，小麦市场独特的法则或规律，或者使鸭子区别于其他物种的基因序列。</p></li><li><p>痛苦+反思=进步</p><p>如果你能养成一种习惯，面对精神痛苦时能够自动地反思痛苦而不是躲避痛苦，你将能够快速地学习和进化</p></li><li><p>生活中的大多数东西都不过是“同类情况的重演”。</p></li><li><p>但大多数人缺乏勇气克服自身弱点，也缺乏勇气做出这一改变所要求的不容易做出的抉择。归根到底，这可以总结为以下5项抉择：1．不要混淆你的愿望和事实。</p><p>2．不要为自身形象担心，只需关心能不能实现你的目标。</p><p>3．不要过于重视直接结果而忽视后续、再后续的结果。</p><p>4．不要让痛苦妨碍进步。</p><p>5．不要把不好的结果归咎于任何人，从自己身上找原因。</p></li><li><p>在我看来，个人进化过程（即我在上一条描述的循环）通过5个不同的步骤发生。如果你能把那5件事都做好，你几乎肯定可以成功。这五步大概是：</p><p>1．有明确的目标。</p><p>2．找到阻碍你实现这些目标的问题，并且不容忍问题。</p><p>3．准确诊断问题，找到问题的根源。</p><p>4．规划可以解决问题的方案。</p><p>5．做一切必要的事来践行这些方案，实现成果。</p></li></ul><ul><li>有明确的目标<ul><li><strong>排列优先顺序：尽管你几乎可以得到你想要的任何东西，但你不可能得到你想要的所有东西</strong>。我的事情只有两类，重要的和紧急的，紧急的事情永远都是不重要的，重要的事情永远都是不紧急的。——《架构整洁之道》</li><li><strong>不要混淆目标和欲望</strong>。合理的目标是你真正需要实现的东西，欲望则是你想要但会阻止你实现目标的东西。欲望通常是直接结果。</li><li><strong>调和你的目标和欲望，以明确你在生活中真正想要的东西</strong>。</li><li><strong>不要把成功的装饰误认为成功本身</strong>。</li><li><strong>永远不要因为你觉得某个目标无法实现就否决它</strong>。</li><li><strong>谨记伟大的期望创造伟大的能力</strong>。</li><li><strong>如果你拥有灵活性并自我归责，那么几乎没有什么能阻止你成功</strong>。</li><li><strong>知道如何对待挫折和知道如何前进一样重要</strong>。</li></ul></li><li>找出问题，并且不容忍问题<ul><li><strong>把令人痛苦的问题视为考验你的潜在进步机会</strong>。</li><li>不要逃避问题，因为问题根植于看起来并不美好的残酷现实。</li><li>要精准地找到问题所在。</li><li>不要把问题的某个原因误认为问题本身。</li><li>区分大问题和小问题。我只做重要的事情。</li><li>找出一个问题之后，不要容忍问题。</li></ul></li><li>诊断问题，找到问题的根源<ul><li>先把问题是什么弄明白，再决定怎么做。</li><li><strong>区分直接原因和根本原因</strong>。在《肥胖代码》里面，你变胖的直接原因是你吃了很多东西，根本原因是胰岛素产生过多且持久。压力大会生成皮质醇，进而产生很多胰岛素。吃精致碳水会比同等卡路里的油脂更容易发胖，因为前者产生更多的胰岛素。一个人酗酒的直接原因是喝了太多酒，根本原因可能是遗传，也有可能是小时候的环境影响。</li><li>认识到了解人（包括你自己）的特性，有助于对其形成合理预期。</li></ul></li><li>规划方案<ul><li>前进之前先回顾。</li><li><strong>把你的问题看作一部机器产生的一系列结果</strong>。通过俯视你的机器并思考如何改变这部机器以创造更好的结果来从事更高层次的思考。你要站在更高的维度思考问题。</li><li>谨记实现你的目标通常有很多途径。</li><li>把你的方案设想为一个电影剧本，然后循序渐进地思考由谁来做什么事。</li><li>把你的方案写下来，让所有人都能看到，并对照方案执行。</li><li>要明白，规划一个好方案不一定需要很多时间。</li></ul></li><li>坚定地从头至尾执行方案<ul><li>规划做得再好，不执行也无济于事。</li><li>良好工作习惯的重要性常被大大低估。</li><li>建立清晰的衡量标准来确保你在严格执行方案。</li></ul></li><li>谨记：如果你找到了解决方案，弱点是不重要的。<ul><li>考察你犯错误的类型，并识别你通常在五步流程中的哪一步上做得不好。</li><li>每个人都至少有一个最大的弱点阻碍其成功，找到你的这个弱点并处理它。</li></ul></li></ul><ul><li><p>影响合理决策的两个最大的障碍是你的自我意识和思维盲点。</p></li><li><p>如果你对自己掌握的知识和擅长的事情过于自豪，你学到的东西就会变少，决策质量就会变低，也将难以充分发挥自己的潜力。</p></li><li><p>习惯本质上是惯性，一种继续把你一直做的事情做下去（或者继续不做你一直不做的事情）的强烈倾向。研究显示，如果你能坚持某种行为约18个月，你就会形成一种几乎要永远做下去的强烈倾向。</p></li><li><p>在桥水，我们讨论过设计好的量化指标需要4个步骤：</p><p>（1）了解公司的目标是什么；</p><p>（2）了解达成目标的程序（你的机器，包括人和设计）;</p><p>（3）找到程序中最适合量化的关键部分，以便了解机器如何运作以达成目标；</p><p>（4）研究如何在关键指标上发挥杠杆效用，以便调整程序、改变结果。在这方面，我们鼓励员工在使用流程图、程序手册的同时，开发适用于我们自己的指标。</p></li><li><p>常言道：“对于无法计量的事物，你肯定也管不好。</p></li><li><p>温斯顿·丘吉尔所说：“给公众以虚假的期望，而期望又很快破灭，这是最糟糕的领导方式。</p></li><li><p>坚持对话的逻辑性。</p></li><li><p>要记住，情绪化容易阻碍人们正确地看待现实。</p></li><li><p>如果有人问你一个问题，你要首先想想你自己是否合适回答这个问题。如果你觉得自己回答的可信度不强，就不应该对此发表意见，更不要与人分享你的观点。</p></li><li><p>区别于苍白的抱怨和有助于改进工作的诉求。</p><ul><li>区别心态开放和心态封闭的人。</li><li>远离心态封闭的人。</li><li>提防那些羞于承认自己并无所不知的人。</li><li>确保工作负责人以开放的心态对待问题和他人的意见。</li><li>认识到求取共识是双向的责任。</li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="other" scheme="https://young1lin.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>电影概论-Mooc</title>
    <link href="https://young1lin.github.io/2021/06/15/film-mooc/"/>
    <id>https://young1lin.github.io/2021/06/15/film-mooc/</id>
    <published>2021-06-14T16:00:00.000Z</published>
    <updated>2021-07-11T16:25:44.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>源自于<a href="https://www.icourse163.org/learn/HENU-1003369001?tid=1461424469#/learn/content?type=detail&id=1237803381&sm=1" target="_blank" rel="noopener">电影概论</a></p><h1 id="一、电影总览"><a href="#一、电影总览" class="headerlink" title="一、电影总览"></a>一、电影总览</h1><h2 id="八大艺术"><a href="#八大艺术" class="headerlink" title="八大艺术"></a>八大艺术</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E5%85%AB%E5%A4%A7%E8%97%9D%E8%A1%93" target="_blank" rel="noopener">来源于 Wikipedia</a></p><h3 id="八大艺术来源"><a href="#八大艺术来源" class="headerlink" title="八大艺术来源"></a>八大艺术来源</h3><p><strong>八大艺术</strong>的分类来源已不可考，但有两个明显的现象是：</p><ul><li>人们提到八大艺术时，往往目的放在想要引介不在此艺术之中之物，例如新兴的<a href="https://zh.wikipedia.org/wiki/電子遊戲" target="_blank" rel="noopener">游戏</a>设计，有人指为第九艺术。</li><li>会提到八大艺术的理论，是因为摄影的发明对以后的各项科学、艺术、媒体及商业行为有巨大的贡献，也改变了人类以往的视觉经验，并进而衍生电影的发明，故变成第八艺术。</li></ul><h3 id="八大艺术列表"><a href="#八大艺术列表" class="headerlink" title="八大艺术列表"></a>八大艺术列表</h3><p>八大艺术包含：</p><ul><li><a href="https://zh.wikipedia.org/wiki/繪畫" target="_blank" rel="noopener">绘画</a></li><li><a href="https://zh.wikipedia.org/wiki/雕塑" target="_blank" rel="noopener">雕塑</a></li><li><a href="https://zh.wikipedia.org/wiki/建築" target="_blank" rel="noopener">建筑</a></li><li><a href="https://zh.wikipedia.org/wiki/音樂" target="_blank" rel="noopener">音乐</a></li><li><a href="https://zh.wikipedia.org/wiki/文學" target="_blank" rel="noopener">文学</a></li><li><a href="https://zh.wikipedia.org/wiki/舞蹈" target="_blank" rel="noopener">舞蹈</a></li><li><a href="https://zh.wikipedia.org/wiki/戲劇" target="_blank" rel="noopener">戏剧</a></li><li><a href="https://zh.wikipedia.org/wiki/電影" target="_blank" rel="noopener">电影</a></li></ul><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h3 id="电影经历过程"><a href="#电影经历过程" class="headerlink" title="电影经历过程"></a>电影经历过程</h3><p>基本上，一部电影会经历三个阶段：制作(production)、发行(distribution)及放映(exhibition)。后面的数字化的售卖，是比较靠后的了，比如 DVD 版，放到各大视频平台售卖之类的。</p><h2 id="电影元素"><a href="#电影元素" class="headerlink" title="电影元素"></a>电影元素</h2><ul><li>光</li><li>色彩</li><li>声音</li><li>画面构图</li><li>镜头构图</li></ul><h2 id="电影创作过程"><a href="#电影创作过程" class="headerlink" title="电影创作过程"></a>电影创作过程</h2><ul><li>剧作</li><li>导演</li><li>表演</li><li>拍摄</li><li>剪辑</li></ul><p>大部分的电影生产过程会经过四个主要的阶段，和上面的 MOOC 的对应了起来。</p><ol><li>编剧与集资（scriptwriting and founding）：电影观念开发完成，完成剧本。电影工作者也需要为拍片计划获得财务援助。</li><li>拍片准备（preparation for filming）：一旦脚本大致完成，且至少有了某些资金，电影工作就可以开始计划实体的生产过程。</li><li>拍摄（shooting）：电影工作者创造出电影的影像和声音。</li><li>组合（assmebly）：这些影像与声音组合成最终的形态，其中牵涉到剪辑图片与声音、执行特效、加入音乐或额外对白，以及加上标题名称。</li></ol><p>这些阶段可能会相互重叠。后面会介绍，好莱坞的 “制片人中心制” 来详细介绍制片人这一角色，这里只是做个大概的介绍。总的来说，这四个阶段会产生几十种专业的分工。</p><h3 id="编剧与集资阶段-（The-Scripting-and-Funding-Phase）"><a href="#编剧与集资阶段-（The-Scripting-and-Funding-Phase）" class="headerlink" title="编剧与集资阶段 （The Scripting and Funding Phase）"></a>编剧与集资阶段 （The Scripting and Funding Phase）</h3><p>核心人物</p><ol><li>制片（producer）<ol><li>执行制片（executive producer）：通常负责安排财务与洽谈版权。</li><li>在线制片（line producer）：监管导演、演员与剧组的日常工作。由助理制片所指派。</li><li>助理制片（associate producer）：负责协调冲印厂或技术人员。</li></ol></li><li>编剧（screenwriter）</li></ol><p>制片主要负责财务及组织上的工作。如果是独立制片，则要去发掘拍片计划，并说服制片公司或赞助者出资，也可能雇佣制片人去整合项目计划。在编剧的过程中，制片还要照顾整个拍片计划、筹募资金、安排人事等。在拍摄及剪辑期间，制片往往是编导和出资者之间的桥梁。在电影完成后，制片通常还要安排发行、宣传、营销、以及监督成本的回收。单一制片<strong>或许可以</strong>接管所有这些工作，但一般不会这么做。</p><p>剧本的完成会经历几个阶段。</p><ol><li>大致交代主要情节（action）的大纲（treatment）</li><li>一份货多份完整脚本</li><li>最后的拍摄脚本（shooting script）</li></ol><p>有的电影，可能会有好几个编剧一起编写，或者制片直接换编剧写剧本，例如《异形：普罗米修斯》，其实换了好几个编剧。如果直拍呢货导演不满意某一个作者的剧本，可以雇其他做和加以修改。</p><h3 id="准备阶段（The-Preparation-Phase）"><a href="#准备阶段（The-Preparation-Phase）" class="headerlink" title="准备阶段（The Preparation Phase）"></a>准备阶段（The Preparation Phase）</h3><p>核心人物</p><ol><li>导演（director）</li><li>制片（producer）</li><li>选角总监（casting supervisor）</li><li>场景组（set unit）/ 制作设计组（production design unit）：场景的建筑与色调，绘制草图并进行规划。<ol><li><strong>设计总监</strong>（production designer）：以他为首，负责电影场景的视觉设计。</li><li>美术指导（art director）：负责监督场景的建造与与油漆。</li><li>陈设指导（set decorator）：通常具有室内设计的专长，负责根据特定拍摄需要而调整陈设，并监督找寻道具的人员。</li><li>布景人员（set dresser）：在拍摄时摆设道具。</li><li>服装设计（costume designer）：负责电影中所有戏服的设计与制作。</li><li>绘图师（graphic artist）：画<strong>分镜表</strong>（storyboard）类似于漫画，将每场戏的镜头绘制成草图，并就服装、灯光、摄影机运动做出提示。大部分导演并不要求所有场景都有分镜表，但是，关于需要特效或有复杂摄影机运动的情节段落与镜头，则需要有详细的分镜表。有了分镜表，摄影组和特效组便能初步了解完成后的镜头会是什么样子。分镜影像以拍摄剪辑的方式制作，并且配上音效协助场景的影像化，这就是一种动态脚本（animatics）。《曼达洛人》每一集后面都会有每个场景的绘图，很精致的草图，就是分镜表。</li><li>预视化团队（previsualization team）</li></ol></li></ol><p>这个阶段，导演其实是核心人物，当然制片也很重要。</p><h3 id="拍摄阶段（The-Shooting-Phase）"><a href="#拍摄阶段（The-Shooting-Phase）" class="headerlink" title="拍摄阶段（The Shooting Phase）"></a>拍摄阶段（The Shooting Phase）</h3><p>核心人物</p><ol><li>导演组（directors’s crew）<ol><li>导演：知道演员表演，多数的导演会话许多时间讲解如何念台词或做动作，提醒演员这一场戏在全片当中的地位，并协助演员保持前后一致的表演。</li><li>演员（cast）<ol><li>主要角色（primary actor ）</li><li>配角（supporting players）</li><li>路人、群众或临时演员（extras）</li><li>特技演员（stunt artist）：由特技教练（stunt coordinator）指导</li></ol></li><li>场记（script supervisor）：负责每一镜头的连续性细节，还必须检查演员的外表，以及道具、灯光、动作、摄影机位置，与每一个镜头的时间。</li><li>第一助导（first assistant director，AD）：通常要负责与临时演员沟通，并调度群众场景。是万事通类型的人，与导演计划每日拍摄进度。根据导演指示，为每个镜头做拍摄前准备，并掌控演员、监督安全设施，以及维持拍片的士气。</li><li>第二助导（second assistant director）：担任第一助导与摄影组、电工组之间的协调工作。</li><li>第三助导（third assistant director）：担任导演与行政人员之间的传达工作。</li><li>对白员（dialogue coach）：为演员提词，或扮演不在镜头内的角色与镜头内演员对话。</li><li>第二组导演（second unit director）：在主要拍摄点的远距离外，负责拍摄特技动作、外景镜头与打斗动作等。</li></ol></li><li>摄影组（photography unit）<ol><li>摄影师（cinematographer）/摄影指导（director of photography，DP）：摄影师必须是摄影、灯光及掌镜专家。摄影师与导演会沟通每一场戏的灯光及拍法，以及负责监督以下人员。</li><li>摄影机操作员（camera operator）：负责开机、换片、对焦及跟焦、推轨等等。</li><li>场务领班（key grip）：领导场务助理（grips）搬运及放置设备、道具等场景及灯光器材。</li><li>灯光师（gaffer）：监督灯光位置与架设。</li><li>麦克风操作员（boom operator）：负责操控吊杆式麦克风（boom microphones），以及把无线麦克风藏在演员身上。</li><li>声效控制员（third man）：负责安置其他的麦克风，铺设音效电缆、控制环境音。</li><li>音效设计师（sound designer）：在前期制作便开始参与，为全片设计适当的声音风格。</li></ol></li><li>视觉特效组（visual-effects unit）<ol><li>视觉特效总监（visual-effects supervisor）：指挥视觉特效组，负责准备及执行枪击、模型、画面合成、计算机合成影像与其他技术镜头。在规划阶段，导演与制作设计总监会决定需要哪些特殊效果，而视觉特效总监则要随时与导演及摄影师沟通。</li><li>Model maker</li><li>Matte artist</li></ol></li><li>总务组（miscellaneous unit）<ol><li>化妆师（makeup staff）</li><li>服装师（costume staff）</li><li>发型师（hairdresser）</li><li>在线制片（line producer）：负责管理日常性组织事务，如安排食宿等。</li><li>制片会计（production accountant; production auditor）：监督开销</li><li>制片秘书（production secretary）：协调单位与制片间的电话联系</li><li>制片助理（prduction assistants，PAs）：负责跑腿。一般而言，电影产业的新进人员通常由制片助理做起。</li><li>司机</li></ol></li></ol><h3 id="组合阶段（The-Assembly-Phase）"><a href="#组合阶段（The-Assembly-Phase）" class="headerlink" title="组合阶段（The Assembly Phase）"></a>组合阶段（The Assembly Phase）</h3><p>后期制作（postproduction）</p><ol><li>剪辑师（editor）/剪辑指导（supervising editor）<ol><li>声音剪辑师</li><li>作曲</li><li>导演</li><li>电影作曲者</li></ol></li></ol><h2 id="电影类型"><a href="#电影类型" class="headerlink" title="电影类型"></a>电影类型</h2><ul><li>音乐歌舞片</li><li>喜剧片</li><li>西部片</li><li>武侠片</li></ul><h2 id="电影批评"><a href="#电影批评" class="headerlink" title="电影批评"></a>电影批评</h2><p>将理论批评与创作批评结合，文本批评与审美批评结合，从叙事学、作者等层面较为全面的讲授电影理论的相关内容。</p><h2 id="电影流派"><a href="#电影流派" class="headerlink" title="电影流派"></a>电影流派</h2><ul><li>欧洲先锋派电影</li><li>苏联蒙太奇学派</li><li>意大利新现实主义电影</li><li>法国新浪潮电影</li><li>日本东方美学电影</li><li>香港新浪潮电影</li><li>台湾新电影</li></ul><h2 id="电影工业与电影产业"><a href="#电影工业与电影产业" class="headerlink" title="电影工业与电影产业"></a>电影工业与电影产业</h2><p>分别以好莱坞电影工业和中国电影产业为核心，介绍电影 “制作” “发行” “放映” 等环节在工业、产业体系中的发展与特点。</p><h1 id="光"><a href="#光" class="headerlink" title="光"></a>光</h1><p>通常称电影的拍摄为摄影（photography），电视的拍摄为摄像。</p><p><strong>摄影即用光来描绘和表现。</strong></p><p><strong>魔术时刻</strong></p><p>是指日落前后约半小时左右，此时天空变成深蓝色或者红色（蓝移和红移），但是仍然可以清楚地照映出大地上景物的轮廓，此时所能够形成的电影画面效果，就仿佛是从天空架设了灯光照射到地面上。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="外部引导功能"><a href="#外部引导功能" class="headerlink" title="外部引导功能"></a>外部引导功能</h3><ul><li><strong>空间引导功能</strong></li></ul><p>空间光线的明暗变化，来进行叙事空间的转换</p><ul><li><strong>时间引导功能</strong></li></ul><p>电影常常使用不同的时间光的变化，表示时间的流逝，从而形成光的时间引导功能。</p><h3 id="内部引导功能"><a href="#内部引导功能" class="headerlink" title="内部引导功能"></a>内部引导功能</h3><ul><li><strong>光对电影情绪和氛围的影响</strong></li></ul><p>电影中的 “光” 可以分为 “高调光” 和 “低调光”。</p><p>以 “<strong>高调光</strong>” 为主进行拍摄的影片中，往往场景的亮度充足，光影反差较小。因而多用于喜剧片、音乐歌舞片等情绪比较积极的电影类型中。</p><p>例如大话西游，光线充足，人和物体都基本没有光影反差。</p><p>以 “<strong>低调光</strong>” 为主拍摄的电影中，往往场景的亮度不足，光影反差也比较大。因此多用于黑色电影、犯罪片及类似风格电影。</p><p>例如《教父》</p><ul><li><strong>光作为电影中戏剧冲突的元素</strong></li></ul><p>通过光影的反差来表现人物与环境之间的冲突，人物之间的冲突或是人物自身的冲突等。</p><h2 id="光的种类"><a href="#光的种类" class="headerlink" title="光的种类"></a>光的种类</h2><p>根据电影中光的方向可分为</p><ul><li>主光</li><li>背光</li><li>补光</li></ul><h3 id="主光"><a href="#主光" class="headerlink" title="主光"></a>主光</h3><p>主光是最重要的光源，它会直接影响到电影画面的色温和亮度等，因此也常常被称为造型光或是基调光。</p><p>对于同一场戏中的各个镜头而言，不论景别怎样变化，也不论实际拍摄的时间和地点有何不同，“主光” 的方位必须是统一的，而不能随意变化。</p><p>在电影拍摄时，主光一般位于主体事物的斜前方。其主要作用是呈现电影画面中事物的基本面貌。</p><h3 id="背光"><a href="#背光" class="headerlink" title="背光"></a>背光</h3><p>背光又称轮廓光，在进行电影拍摄时，一般处于主体事物的后上方，背光的主要作用是区分电影画面中的主体与背景，勾画被摄对象的轮廓并突出主体，从而使电影画面的影调层次更加富于变化，增加画面的美感。</p><h3 id="补光"><a href="#补光" class="headerlink" title="补光"></a>补光</h3><p>补光又称辅助光，辅助光的光源可以是柔和的散光灯，也可以是反光板，在电影拍摄时，一般处于主体事物的正前方，且靠近摄影机的位置。</p><p>主要作用是弥补主光的不足，照亮主光所不能照亮的侧面，控制画面中亮处和暗处之间的层次与反差，从而显示阴影部分的质感。即 “补光” 是帮助 “主光” 完成形象塑造的光线。</p><p>“补光” 不能强于 “主光”，也不能干扰 “主光”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这三种光的方式，被称作三点布光法，也是好莱坞最经典的布光原则。作为一种最简单且最为常见的布光方法，<strong>三点布光</strong>可以满足基本的电影拍摄要求。同时很多复杂的电影布光方法，也都源于三点布光。</p><p>”<strong>三点布光</strong>“ 是构成电影布光的基石。</p><h1 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h1><p>色彩在电影中最初是作为一种虚构的视觉呈现，用来展示梦幻的感受，从而彰显出电影所独有的视觉表现手法。</p><h2 id="色彩的功能"><a href="#色彩的功能" class="headerlink" title="色彩的功能"></a>色彩的功能</h2><ul><li>信息功能</li><li>构图功能</li><li>情绪功能</li></ul><h3 id="信息功能"><a href="#信息功能" class="headerlink" title="信息功能"></a>信息功能</h3><p>是指可以通过画面中的不同色彩来辨识事物。</p><p>绿色的草地是春天的象征，金色的麦田代表着丰收，人体覆盖着白布则意味着死亡。</p><h3 id="构图功能"><a href="#构图功能" class="headerlink" title="构图功能"></a>构图功能</h3><p>是指通过色彩在电影画面中的面积大小及其亮度的不同，所形成的艺术效果。</p><h3 id="情绪功能"><a href="#情绪功能" class="headerlink" title="情绪功能"></a>情绪功能</h3><p>“色彩的情绪功能” 与 “光对电影情绪和氛围的影响” 相仿。鲜艳明亮的色彩和 ”高调光“ 类似，多用于喜剧片、青春片、音乐歌舞片等类型的电影中。</p><p>暗淡阴沉的色彩也与 “低调光” 类似，多用于黑帮片、侦探片等类型的电影中。</p><h2 id="色彩的种类"><a href="#色彩的种类" class="headerlink" title="色彩的种类"></a>色彩的种类</h2><h3 id="红色（刺激色）"><a href="#红色（刺激色）" class="headerlink" title="红色（刺激色）"></a>红色（刺激色）</h3><p>红色对于人们的视觉来说，是一种刺激的颜色，它既能够激活生命力和激情，又能让人变得焦虑。同时红色也象征着权力，它既可以赋予好人权力，也可以赋予坏人权力，这取决于故事的需要。</p><p>黑客帝国中的红蓝药丸，《天能》中的红蓝门，正时间和反时间。</p><h3 id="黄色（矛盾色）"><a href="#黄色（矛盾色）" class="headerlink" title="黄色（矛盾色）"></a>黄色（矛盾色）</h3><p>黄色除了是热情与火热的象征，电影中的黄色也是一种矛盾的颜色，既可以提供线索，也可以进行警示。</p><p>同时，黄色作为太阳的颜色，还能够让人们感受到强烈的生命能量。</p><h3 id="蓝色（知性色）"><a href="#蓝色（知性色）" class="headerlink" title="蓝色（知性色）"></a>蓝色（知性色）</h3><p>blue 忧伤</p><p><strong>忧伤能使人思考</strong>。</p><p>蓝色离知性最近，离感性最远。</p><p>灰蓝色是色谱中最难引发欲望的颜色，绿蓝色显得更为活泼有激情。</p><p>靓丽的蓝色可以代表广阔的天空，灰暗的蓝色则是压抑的象征。</p><h3 id="绿色（分裂色）"><a href="#绿色（分裂色）" class="headerlink" title="绿色（分裂色）"></a>绿色（分裂色）</h3><p>既代表希望生存与希望，也代表死亡与危险。尤其是在战争题材电影中，绿色作为分裂色的特点得到了最充分的诠释与应用。</p><p> 绿色是自然界常见的颜色，它的涵义也是丰富多元的。尤其是绿色作为矛盾色在电影场景中的恰当使用，就既可以增强画面的视觉冲击，又能够引发人们对色彩更多的思考。</p><h3 id="紫色（虚无缥缈）"><a href="#紫色（虚无缥缈）" class="headerlink" title="紫色（虚无缥缈）"></a>紫色（虚无缥缈）</h3><p>在电影中，紫色作为一种虚无缥缈的颜色，紫色往往与非物质联系，预示着某人某事要发生变化或者是变异等。也就是说，电影中的紫色大多有着消失和逝去的意思。</p><p><strong>暗示幻想的破灭</strong>。</p><h1 id="电影构图"><a href="#电影构图" class="headerlink" title="电影构图"></a>电影构图</h1><p>“电影构图”，是指为了表现一定的思想情感或意境氛围，在电影的空间范围内运用审美的心理形象，符号的位置关系等，而组成具有说服力的艺术整体。</p><ul><li>画面构图</li><li>镜头构图</li></ul><h2 id="画面构图"><a href="#画面构图" class="headerlink" title="画面构图"></a>画面构图</h2><p>电影画面构图借鉴了许多绘画构图的表现手法，然而两者最大的差异，就是绘画构图的边框是丰富多元的，可以根据具体的画面内容和创作者的艺术理念进行不同形状的边框设计。</p><p>《我不是潘金莲》，<em>这个在刚开始看的时候，很奇怪，电影不能全部覆盖屏幕。</em></p><p>采用了圆形画幅的边框设计，并以圆形和正方形交替出现的画面构图，来表现中国文化中的方圆理念。</p><p><em>天圆地方，铜钱也是这个概念。</em></p><p>电影画面包括</p><ul><li>主体</li><li>陪体</li><li>环境</li><li>空白</li></ul><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>主体并不一定要在画面的正中间，例如《大话西游》的至尊宝。《布达佩斯大饭店》是以绝对对称的画面构成。</p><p>这里也借鉴了，黄金分割率的概念。</p><p> 电影画面中的顶部、底部或是左侧、右侧等边缘，往往是观众最容易忽视的区域。如果画面中的人物处于这些区域，一般是导演想故意造成某种隐喻，旨在暗示人物的软弱无力或无足轻重。</p><p>《黄土地》画面中，都是在这些区域。</p><h3 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h3><ul><li>地平线</li></ul><p>电影画面中的地平线具有烘托主体，加强视觉冲击和平衡画面的作用。</p><p>处于画面下方的地平线则可以产生一种辽阔感，形成较强的主管视觉效果。</p><p>处于电影画面上方的地平线，则能够产生一种纵深感，形成较强的宏观视觉效果。</p><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>“空白” 作为画面的重要组成部分，在具体电影画面中往往体现为“留白”。</p><ul><li>电影画面中的留白具有营造影片意境的作用。</li><li>电影画面中的留白还具有表现人物内心世界的作用。</li><li>电影画面中的留白还能够突出主体，增加视觉冲击力，并体现不同对象之间的呼应关系。</li></ul><h2 id="镜头构图"><a href="#镜头构图" class="headerlink" title="镜头构图"></a>镜头构图</h2><ul><li>景别</li><li>景深</li><li>角度</li><li>运动</li></ul><p>还有大全景、大特写、中远景、中近景等</p><h3 id="景别"><a href="#景别" class="headerlink" title="景别"></a>景别</h3><p>“景别” 是指由于摄影机与被摄物体之间的距离不同，从而形成被摄物体在电影画面中的大小不同。电影中的景别主要有 “全景” ”中景“ ”近景“ ”特写“ 这四种最基本的类型，以及由这四种基本类型所延伸出的多元景别。</p><p><strong>全景</strong></p><p>“全景” 是指人物的全身或场景的全貌都在电影画面中。其主要作用就是交代环境。</p><p>电影开场的全景镜头也可以称作 “建构镜头”。例如《阿甘正传》就是以全景镜头开始的。</p><p>特点：既能够完整呈现人物的形体动作，又能够清楚的展示人物与环境之间的关系。</p><p><strong>中景</strong></p><p>“中景” 是指人物的大半身，即膝盖以上都在电影画面中。通常所说的 “膝上髋下” 镜头就是中景镜头。其主要作用是不仅可以让观众看清楚画面中人物的表情，而且有利于展示人物的形体动作。</p><p>特点：能够有效增强画面的纵深感，表现出相应的环境与氛围，同时可以通过镜头的组接，平稳的叙述剧情。</p><p><strong>近景</strong></p><p>“近景” 是指人物的胸部以上，或者是物体的局部在电影画面中。主要作用是传达人物的内心世界，因此就成为刻画人物性格最有力的景别。</p><p><strong>特写</strong></p><p>“特写” 是指人物肩膀以上的头像或物体，动作的细节占据整个电影画面，环境和背景淡化。其主要作用是强调造型的渗透力，或形成某种心理暗示。</p><p>特点：能够表现人物细微的情绪变化，使观众在视觉和心理上都能够收到较强的感染。</p><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>“景深” 是指电影画面所能够表现的前后左右的距离，即一个画面内部所反映的空间大小。</p><ul><li>大景深</li><li>小景深</li></ul><p>“大景深” 是指电影画面纵深的清晰范围大（都是清晰的）。</p><p>“小景深” 是指电影画面纵深的清晰范围小（突出主体，虚化陪体/环境/空白）。</p><p>影响景深的因素：<br>摄影机镜头的光圈、焦距等。</p><p>焦距越短，景深越大；焦距越长，景深就越小。</p><h3 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h3><p>“角度”，就是指电影镜头的拍摄角度，通常包括 “平视角度” “仰视角度” “俯视角度“ 三种。</p><ul><li>平视角度</li><li>俯视角度</li><li>仰视角度</li></ul><p>一般体现人物强弱关系，会用仰视角度拍摄强势的人，用俯视角度拍摄弱势的人。更具体的，可以参考博然讲电影的 “让子弹飞”  的拉片。</p><h4 id="平视角度"><a href="#平视角度" class="headerlink" title="平视角度"></a>平视角度</h4><p>“平视角度”，是指摄影机处于人眼等高的位置。</p><p>为了达到某种特殊的艺术效果，使用压低“平视角度”的高度，以儿童或者小动物的视角进行拍摄。</p><h4 id="俯视角度"><a href="#俯视角度" class="headerlink" title="俯视角度"></a>俯视角度</h4><p>“俯视角度”，是指摄影机处于视线的上方，即形成 “往下看” 的视觉效果。</p><p>特点：使景物的层次分明，并且容易形成压迫感。</p><p>凸显弱势</p><h4 id="仰视角度"><a href="#仰视角度" class="headerlink" title="仰视角度"></a>仰视角度</h4><p>“仰视角度” ，是指摄影机处于视线的下方，即形成 “抬眼看” 的视觉效果。</p><p>仰视角度常常用来表现主体的力量感。</p><p>如果是表现正面角色，则会有称赞、赞颂之意。</p><p>如果是表现反面角色，则通常会形成一种威胁感或者是压迫感。 </p><h3 id="电影镜头的运动"><a href="#电影镜头的运动" class="headerlink" title="电影镜头的运动"></a>电影镜头的运动</h3><p>镜头的角度决定了电影的视点，镜头的运动则是电影的视觉呈现能够丰富多样充分彰显电影艺术表现力的重要因素。</p><ul><li>推</li><li>拉</li><li>摇</li><li>移</li><li>升</li><li>降</li><li>甩</li><li>跟</li></ul><p>升、降、甩（基本没人用了）这几个是《电影批评》中补充的。</p><h4 id="推"><a href="#推" class="headerlink" title="推"></a>推</h4><p>“推” 是指沿摄影机光轴方向向前移动的接近式拍摄，其特点是电影画面由大景别连续过渡变小。</p><p>主要作用：突出电影画面中心和细节，并强化视觉冲击。</p><h4 id="拉"><a href="#拉" class="headerlink" title="拉"></a>拉</h4><p>“拉” 是指沿摄影机光轴方向向后移动的远离式拍摄；其特点是指画面的范围越来越大，被摄体也由单一变为多元。</p><p>主要作用：让观众在看清主体的基础上，扩大所呈现的空间以便使更多的信息入画，从而有利于观众了解主体与环境，局部与整体的关系。</p><h4 id="摇"><a href="#摇" class="headerlink" title="摇"></a>摇</h4><p>“摇”，是指摄影机的位置不动，只是角度变化；可以是 “左右摇” 或者是 “上下摇”，也可以是 “斜摇” 或者是 “旋转摇”。其特点是改变拍摄角度或拍摄对象，自由度和灵活性较强。</p><p>主要作用：介绍环境，突出人物的行动目的和意义。 </p><h4 id="移"><a href="#移" class="headerlink" title="移"></a>移</h4><p>”移“ 是指摄影机沿水平的各个方向移动并同时进行拍摄。其特点是镜头的方向不变，而只是移动摄影机。</p><p>主要是通过铺设轨道来实现移。</p><p>主要作用：展示空间，因为它能够产生巡视的视觉效果，同时还可以把一些事物连接起来从而表现复杂的空间环境。</p><h3 id="跟"><a href="#跟" class="headerlink" title="跟"></a>跟</h3><p>“跟” 是指摄影机始终跟随被摄主体进行拍摄。其特点是运动着的主体始终在电影画面中，从而可以连续且详尽的表现其活动情形。</p><p>长镜头？手持摄像机？</p><p>主要作用：能突出运动中的主体，又能交代运动的方向、速度和周围环境等。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>推、拉、摇、移、跟这五种形式在电影的具体拍摄中，往往都是根据导演的叙事目的或者是艺术表现的需要等而混合交替地使用。</p><h1 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h1><ol><li>基本特性</li><li>类型</li><li>功能</li></ol><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>《视听》</p><p>我们孕育于声音之中，诞生于视觉世界。</p><p>电影孕育于视觉世界，诞生于声音之中。</p><p>声音出现之后，电影才真正成为视听合一的艺术。  </p><p>声音作为进入电影的最后一个至关重要的元素，对电影艺术的成熟和完善有着决定性的作用。</p><p>从物理学的角度来看，声音有三个基本特性</p><ol><li>音调</li><li>音色</li><li>音高</li></ol><h3 id="音调"><a href="#音调" class="headerlink" title="音调"></a>音调</h3><p>🈯️声音频率的高低。</p><p>音调高：轻、短、细</p><p>音调低： 重、长、粗</p><p>儿童声音的音调要比成人的音调高，女性声音的音调要比男性声音的音调高。 </p><h3 id="音色"><a href="#音色" class="headerlink" title="音色"></a>音色</h3><p>也称 “音品”，是指声音的特质和色彩。 </p><p>每一个人，每一种乐器和所有能够发出声音的物体的音色都不相同。</p><h3 id="音高"><a href="#音高" class="headerlink" title="音高"></a>音高</h3><p>也称 “音量”。指人耳对听到声音大小、强弱的主观臆断感受。</p><p>人们把对声音的感受量化为可以监测的指标，单位为 “分贝”（DB）。</p><p>电影中，通过不同音高来变现不同叙事情景或是人物心理等。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>人声</li><li>音效</li><li>音乐</li></ol><h3 id="人声"><a href="#人声" class="headerlink" title="人声"></a>人声</h3><p>即指人的声音。</p><p>电影中的 “人声” 分为 “对白” 和 “旁白”。</p><p>“对白” 也称 “台词”，是指两人或多人之间的对话。</p><p>“旁白” 则是指由电影画面外的人声对故事情节，人物心理等进行叙述或抒情议论，以传递更为丰富的信息。</p><h3 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h3><p>也称 “声效”，是指由声音所制造的听觉效果。</p><p>电影的 “音效” 包括 “环境音效” 和  “动作音效”。</p><p>“环境音效” 指电影中自然环境的声音；</p><p>“动作音效” 则是指人物动作或者物体所发出来的声音。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>“音乐” 作为电影声音的重要组成部分，是诠释影片的一把钥匙，好的音乐甚至可以助力一部影片的成功。</p><p>”电影音乐“ 可分为 ”电影乐曲“ 和 “电影歌曲”。</p><p><strong>电影乐曲</strong></p><ul><li>主题音乐</li></ul><p>“主题音乐” 往往是一段完整的音乐，其能够表达一定的思想，感情和主题，同时能够贯穿剧情并统一电影风格，是电影的核心音乐。</p><p>如《阿甘正传》的主题音乐 “在风中飘” （FORREST GUMP）。</p><ul><li>背景音乐</li></ul><p>也称 “配乐” 或是 “伴乐”，是指在电影中作为背景衬托的音乐。</p><p>作用：增强影片的情感表达，让观众有身临其境的感受。</p><ul><li>主题曲</li></ul><p>指在一部电影中反复出现，表现主题思想或者概括影片基本内容的歌曲。 </p><p>如《亲爱的》结尾主题曲 “亲爱的小孩”。</p><ul><li>插曲</li></ul><p>指穿插在电影中的短小乐曲，具有贯穿剧情的作用。</p><p><strong>总结</strong></p><p>电影音乐具有确立场景、突出感情色彩、增强故事流畅感、强化影片高潮的作用。</p><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ol><li>信息功能</li><li>内部引导功能</li><li>外部引导功能</li></ol><p><strong>信息功能</strong></p><p>指通过声音传达特定影片或故事信息。</p><p><strong>内部引导功能</strong></p><p>声音的内部引导功能，指声音在电影中对人物内心及情绪等的表现。 </p><p><strong>电影声音的处理原则</strong> </p><p>声音层次</p><p>声音透视</p><p>音桥</p><p>画外声音</p><p>声音蒙太奇</p><p>首先，要根据声音在电影画面中的重要程度来处理声音的层次。</p><p>处理好 “对白” “音乐” “音效” 之间的关系。</p><p>如在人物对话中音乐的声音不要超过人声等。</p><p>其次，在进行电影声音处理时还要主要声音透视的问题。 </p><p>“声音透视”，是指电影画面中相应的声音呈现要符合日常生活中，人们对声音的普遍感知经验。</p><p>例如，人物靠近或远离时，声音要相应变大或者变小。 </p><p>进行电影声音处理时的一个特殊的手段：建立 “音桥”。</p><ul><li>有源声音</li><li>无源声音</li></ul><p>有源声音</p><p>指声音与电影画面中的一个声源互相联系。</p><p>无源声音</p><p>某种声音的声源没有出现在电影画面中，那就是 “无源声音”。</p><p>“音桥” 即利用声音与画面中声源的关系形成镜头之间的连续性，从而使声音具有一种 “桥梁” 的功能。</p><p>电影的声音处理还要注意 “画外声音” 的运用。</p><p>“画外声音” 是指声源没有出现在电影画面中的声音。</p><p>“画外声音” 可以使电影画面得以延伸。与音桥类似，可以表达出更多的信息。  </p><p>“声音蒙太奇” 即声音的剪辑。</p><p> 通过声音的排列或是组合表现特定的情感，产生更多的意义。</p><h1 id="剧作"><a href="#剧作" class="headerlink" title="剧作"></a>剧作</h1><p>一部电影的创作过程，大致要经历</p><ol><li>前期剧本写作</li><li>中期拍摄</li><li>后期剪辑</li></ol><p>完成 剧作、导演、表演、拍摄、剪辑等。完成时间也从几个月到几年不等。</p><h2 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h2><ol><li>电影文学剧本</li><li>电影分镜头剧本</li><li>电影完成台本</li></ol><h3 id="电影的基本组织结构"><a href="#电影的基本组织结构" class="headerlink" title="电影的基本组织结构"></a>电影的基本组织结构</h3><p>电影的最小单位：镜头</p><p>镜头 —— 场 —— 情节段落 —— 剧本。</p><h3 id="电影文学剧本"><a href="#电影文学剧本" class="headerlink" title="电影文学剧本"></a>电影文学剧本</h3><p>即我们日常最容易接触到的电影剧本类型。</p><p>作为电影创作的第一步，由编剧完成。</p><p>“电影文学剧本” 要以 “场” 为单位进行写作。</p><p>要明确标出每一场的 “场次” 及相应的 “场景”。</p><p>具体文字表述，则与小说的语言比较接近，即要写出故事的详细发生发展过程和人物对话等。  </p><h3 id="电影分镜头剧本"><a href="#电影分镜头剧本" class="headerlink" title="电影分镜头剧本"></a>电影分镜头剧本</h3><p>也称 “导演台本”，是在电影开始拍摄之前，由导演根据 “电影文学剧本” 创作完成。</p><p>“电影分镜头剧本” 要以 “镜头” 为单位进行写作。</p><p>不仅要详细标明 “第几场” 的 “第几个镜头”，而且要明确写出每一个镜头的 “景别”。</p><p>《罗生门》第一个镜头讲解。 </p><h3 id="电影完成台本"><a href="#电影完成台本" class="headerlink" title="电影完成台本"></a>电影完成台本</h3><p>也称 “镜头记录本”，是在电影拍摄结束之后，由场记完成。</p><h3 id="电影剧本的运作方式"><a href="#电影剧本的运作方式" class="headerlink" title="电影剧本的运作方式"></a>电影剧本的运作方式</h3><p>有两种</p><ol><li>先确定选题，然后再找编剧编写剧本。 </li><li>制片商或导演看中了某个小说或是剧本的创意，便就出资购买相应版权，然后邀请原作者或其他编剧来创作剧本。</li></ol><h2 id="改编"><a href="#改编" class="headerlink" title="改编"></a>改编</h2><p>改编是电影剧本的一个重要来源，根据相关数据全世界每年至少有一半的电影剧本都是改编而来的。</p><p>总体来看，电影剧本的改编，主要有</p><ul><li>忠于原著</li><li>节选</li><li>复合</li><li>取意</li><li>颠覆</li></ul><h3 id="忠于原著"><a href="#忠于原著" class="headerlink" title="忠于原著"></a>忠于原著</h3><p>指电影改编保留原作的故事和人物，力求忠实于原著的内容。</p><p>特点：将抽象的文字转化为具象的视听语言。</p><h3 id="节选"><a href="#节选" class="headerlink" title="节选"></a>节选</h3><p>指将原著中最精彩的部分，或是相对完整的一段，提炼后进行改编创作。</p><p>从其中抽出来一部分，删除多余的线索和人物，化繁就简的进行电影剧本创作。</p><p>因为电影的时长有限，很多鸿篇巨制的文学作品不可能在 2 个小时左右的电影中完全呈现。</p><p>如根据经典革命小说《林海雪原》截取了精彩片段，改编成了《智取威虎山》。</p><h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><p>指将原本独立的两个或多个故事整合，从而形成一个新的作品。</p><p>《罗生门》就是将日本作家芥川龙之介的两部小说《罗生门》和《筱竹丛中》进行复合。</p><p>《皮绳上的魂》也是融合藏族作家扎西达娃的两部小说，《西藏，系在皮绳结上的魂》和《去拉萨的路上》</p><h3 id="取意"><a href="#取意" class="headerlink" title="取意"></a>取意</h3><p>仅保留原作的人物关系活基本的故事框架，而进行新的剧本创作。</p><p>《满城尽带黄金甲》就是取意自曹禺先生的经典话剧《雷雨》，只是将故事的背景改为五代十国，而人物设置和人物关系则与《雷雨》如出一辙。</p><h3 id="颠覆"><a href="#颠覆" class="headerlink" title="颠覆"></a>颠覆</h3><p>指对原作进行彻头彻尾的改编，虽然有的仍然是用原作的名字，或是使用原作中人物的名字，但故事内容已经面目全非。</p><p>《大话西游》这种系列，就是对西游的彻底的颠覆。</p><h1 id="导演"><a href="#导演" class="headerlink" title="导演"></a>导演</h1><p>导演：电影的 “总工程师”</p><p>导演需要参与的阶段</p><ol><li><p>前期筹备</p></li><li><p>中期拍摄</p></li><li><p>后期剪辑</p></li></ol><h2 id="前期筹备阶段"><a href="#前期筹备阶段" class="headerlink" title="前期筹备阶段"></a>前期筹备阶段</h2><p>首先就是对一部电影进行最初的构思，即在开拍之前形成自己的想法，并与编剧沟通修改剧本。 </p><p>建立剧组，即通常所说的 “建组”。</p><p>通常会选用与自己有过合作的工作人员，旨在减少磨合的时间、提高工作效率。 如：王家卫与摄影师杜可风，侯孝贤与摄影师李屏宾。</p><p> 演员的挑选工作，根据影片中的角色设置和相关的剧情需要，挑选那些符合电影中的人物气质或是有过类似人物演出经验的演员。当然，某些导演也会经常会与某位演员合作，例如冯小刚的喜剧片中总会有葛优。宁浩的喜剧片中也总有黄渤的身影。</p><h2 id="中期拍摄阶段"><a href="#中期拍摄阶段" class="headerlink" title="中期拍摄阶段"></a>中期拍摄阶段</h2><p>中期拍摄是一部电影创作过程中持续时间最长的时期。</p><p>导演在中期拍摄阶段身兼数职，是电影拍摄工作的主要组织者。指导摄影机前的演员表演，指导摄影、美术、录音等。 </p><h2 id="后期剪辑阶段"><a href="#后期剪辑阶段" class="headerlink" title="后期剪辑阶段"></a>后期剪辑阶段</h2><p>与剪辑师一起进行影片的后期剪辑。即在剪辑师将素材按照 “分镜头剧本“ 进行 ”粗剪“ 的基础上，由导演参与进行 ”精剪“，并在历经多次的反复修改之后，最终完成一部电影的创作。</p><p>后期剪辑师导演一次再次创作的过程。 因为可以根据所拍摄的素材和新的思考，对影片内容进行适当的调整。</p><h1 id="表演"><a href="#表演" class="headerlink" title="表演"></a>表演</h1><p>目前全世界有两大表演艺术体系。</p><ol><li><strong>斯坦尼斯拉夫斯基表演体系</strong></li><li><strong>布莱希特表演体系</strong></li></ol><p>还有观点将中国戏曲的表演艺术体系，即梅兰芳演剧体系列为世界上第三种表演艺术体系，指一种高度程式化的表演。</p><p><strong>斯塔尼斯拉夫斯基表演体系</strong></p><p>也称 “体验派”，创立者是苏联人斯塔尼夫拉夫斯基。</p><p>其核心观点就是要求演员 “化身为角色”，并 “要有真正的情感体验”。</p><p>《演员的自我修养》是真的有这本书，而且还是斯塔尼斯拉夫斯基写的。在全世界都影响非常的深远。</p><p>*<em>布莱希特表演体系 *</em></p><p>也称 “间离派”，创立者是德国人贝托尔特·布莱希特。</p><p>核心观点：要求演员与角色保持一定的距离，演员要高于角色、驾驭角色，要表现剧中的人物而不是融入人物之中。</p><p>一部电影会有数量不等的演员参与演出，少则几个多则成百上千。</p><h2 id="演员"><a href="#演员" class="headerlink" title="演员"></a>演员</h2><p>演员的分类，大致可以分为</p><ol><li>主角</li><li>配角</li><li>群众演员</li><li>客串演员 </li><li>替身</li><li>特技演员</li></ol><p>电影的发展之初，是借鉴了戏剧的表演手法，随着电影的发展成熟，其表演也与戏剧产生了明显的差异。</p><h2 id="电影表演的特点"><a href="#电影表演的特点" class="headerlink" title="电影表演的特点"></a>电影表演的特点</h2><h3 id="电影的表演风格是生活化的"><a href="#电影的表演风格是生活化的" class="headerlink" title="电影的表演风格是生活化的"></a>电影的表演风格是生活化的</h3><p>绝大部分电影都要求演员的表演要真实自然，同时随着现代科技发展出现的愈发细致入微的特写镜头等，更加要求演员的表演要真实自然。</p><h3 id="电影表演是-“导演的艺术”"><a href="#电影表演是-“导演的艺术”" class="headerlink" title="电影表演是 “导演的艺术”"></a>电影表演是 “导演的艺术”</h3><p>戏剧表演是 “演员的艺术”，因为导演的所有构思都要由演员来完成。</p><p>电影演员的表演，则更多的被掌握在导演的镜头语言中。</p><h3 id="电影表演呈现出一种-“镜头之美”"><a href="#电影表演呈现出一种-“镜头之美”" class="headerlink" title="电影表演呈现出一种 “镜头之美”"></a>电影表演呈现出一种 “镜头之美”</h3><p>一方面因为电影演员面对的不是观众而是摄影机，于是就打破了舞台的封闭，另一方面蒙太奇等电影语言，也促成电影表演突破时空的限制。</p><p>电影演员对作品具有不可支配性，同时表演过程还具有被迫中断性。</p><p>在戏剧表演中，演员是主导，因为戏剧作品要依靠演员在舞台上的一气呵成；</p><p>电影演员则需要根据实际情况在摄影机前不断的重复表演，并且随时可能被迫中断。 </p><h1 id="拍摄"><a href="#拍摄" class="headerlink" title="拍摄"></a>拍摄</h1><p>拍摄：电影语言的实现 。</p><p>电影拍摄是以 “场” 为单位进行的，发生在同一场景中的要集中拍摄。以一部90分钟的电影为例，一般会有一百多“场”。如果把重复的场景合并计算，一部电影大概要拍摄三十至五六十场不等。</p><p>一部电影的拍摄顺序，是先拍外景再拍内景。</p><p>因为室外的天气复杂多变的，并且拍外景的时候，可以顺便搭内景。</p><p>电影的拍摄顺序并不是按照故事的发生，发展过程，也<strong>不是按照电影剧本的顺序</strong>，而是遵循 “先外景后内景” 的拍摄原则。</p><h2 id="电影拍摄方式"><a href="#电影拍摄方式" class="headerlink" title="电影拍摄方式"></a>电影拍摄方式</h2><p><strong>电影的拍摄还有几种非常规的方式</strong> </p><ol><li>顺序</li><li>无剧本拍摄</li><li>偷拍</li></ol><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>是指完全按照故事的发展顺序进行电影拍摄。</p><p>受制于演员的档期、天气的变化、场地的租用等限制。</p><h3 id="无剧本拍摄"><a href="#无剧本拍摄" class="headerlink" title="无剧本拍摄"></a>无剧本拍摄</h3><p>指导演在没有剧本的情况下进行电影拍摄。</p><p>《重庆森林》《堕落天使》等都是无剧本的情况下拍摄完成的。</p><h3 id="偷拍"><a href="#偷拍" class="headerlink" title="偷拍"></a>偷拍</h3><p>偷拍在电影创作中并不十分常用。</p><p>也有导演采用偷拍的方式，以实现电影场景的真实与原生态。</p><p>如张艺谋的《秋菊打官司》。</p><h2 id="场记"><a href="#场记" class="headerlink" title="场记"></a>场记</h2><p>是电影拍摄过程中非常重要的一项工作。</p><p>主要人物是在电影拍摄的同时，记录现场的一些注意事项；</p><ul><li><p>电影画面相关信息。</p></li><li><p>如道具摆设人物站位等。</p></li><li><p>演员的服装配饰。</p></li><li><p>人物对话的改动。</p></li></ul><h1 id="剪辑"><a href="#剪辑" class="headerlink" title="剪辑"></a>剪辑</h1><h2 id="剪辑过程"><a href="#剪辑过程" class="headerlink" title="剪辑过程"></a>剪辑过程</h2><p>一般来说，一部电影要经历三次创作过程。</p><p>第一次</p><p>是编剧编写剧本，即以文字塑造电影的视听形象。</p><p>第二次</p><p>是导演执导拍摄，是用摄影机把文字幻化为影像，并以胶片或者数字的形式进行保存。</p><p>第三次</p><p>剪辑师剪辑素材，是让电影真正成为可以放映的影像。</p><p>剪辑的过程一般来说分为下面几步：</p><ol><li>选择镜头</li><li>制定剪辑方案</li><li>初剪</li><li>复剪</li><li>精剪</li><li>综合剪</li></ol><h3 id="选择镜头"><a href="#选择镜头" class="headerlink" title="选择镜头"></a>选择镜头</h3><p>一部 90 分钟的电影，往往会拍摄几百甚至上千个镜头。 而所有的素材累积在一起，至少也有十多个小时，因此，剪辑工作的第一步就是对镜头进行选择。</p><h3 id="制定剪辑方案"><a href="#制定剪辑方案" class="headerlink" title="制定剪辑方案"></a>制定剪辑方案</h3><p>结合之前所选择的镜头，根据剧本制定剪辑方案，从而完成剪辑工作的蓝本。</p><h3 id="初剪"><a href="#初剪" class="headerlink" title="初剪"></a>初剪</h3><p>也称 “粗剪”，是指根据 “分镜头剧本” 完成剪辑初稿，形成电影的雏形，即一个没有特效和音乐的版本。</p><h3 id="复剪"><a href="#复剪" class="headerlink" title="复剪"></a>复剪</h3><p>复剪是在初剪基础之上进行的更为精细的剪辑，进而使影片逐渐定型。</p><h3 id="精剪"><a href="#精剪" class="headerlink" title="精剪"></a>精剪</h3><p>即在复剪基础上的再次查漏补缺。</p><h3 id="综合剪"><a href="#综合剪" class="headerlink" title="综合剪"></a>综合剪</h3><p>主要就是调整、增加镜头或者片段，最终完成一部可供放映的电影。</p><p>也是导演和剪辑师在影片创作过程中的最后冲刺。</p><h2 id="蒙太奇"><a href="#蒙太奇" class="headerlink" title="蒙太奇"></a>蒙太奇</h2><p>原为法国建筑学名词，意为 “组装、装配 ”。</p><p>指把电影所要讲述的故事分为若干个场景拍摄，然后再进行组接，从而形成一个具有逻辑顺序的艺术整体。</p><h2 id="蒙太奇的发展"><a href="#蒙太奇的发展" class="headerlink" title="蒙太奇的发展"></a>蒙太奇的发展</h2><ol><li>卢米埃尔时期</li><li>梅里爱时期</li><li>格里菲斯时期</li></ol><h3 id="卢米埃尔时期"><a href="#卢米埃尔时期" class="headerlink" title="卢米埃尔时期"></a>卢米埃尔时期</h3><p>在电影刚刚出现时，还没有剪辑的概念。</p><p>当时的一个镜头就是一部电影，时间长度大约在一分钟左右。</p><h3 id="梅里爱时期"><a href="#梅里爱时期" class="headerlink" title="梅里爱时期"></a>梅里爱时期</h3><p>电影引入了许多戏剧的创作理念，剪辑也是针对没有景别转换的固定取景。</p><h3 id="格里菲斯时期"><a href="#格里菲斯时期" class="headerlink" title="格里菲斯时期"></a>格里菲斯时期</h3><p>电影摆脱了戏剧观念的束缚，成为一门真正独立的艺术。</p><p>首次使用了分镜头。</p><p>让摄影机运动起来。</p><p>首创了叙事蒙太奇。</p><h2 id="剪辑的艺术功能"><a href="#剪辑的艺术功能" class="headerlink" title="剪辑的艺术功能"></a>剪辑的艺术功能</h2><ol><li>表现电影的叙事和时空</li><li>表现电影的思想和情感</li><li>表现电影的运动和节奏</li></ol><h3 id="表现电影的叙事和时空"><a href="#表现电影的叙事和时空" class="headerlink" title="表现电影的叙事和时空"></a>表现电影的叙事和时空</h3><ol><li>故事时间</li><li>电影时间</li></ol><p>故事时间：指电影中所讲述的故事的实际发生时间。</p><p>可能是一天、一年，或者是许多年。</p><p>电影时间：是指电影讲述这个故事所需要的时间。</p><p>即电影的时长，一般 “电影时间” 都在 2 小时左右。</p><p>《敦刻尔克》天上一天，地上一年。</p><p>“故事时间” 和 “电影时间” 有下列三种关系：</p><p>第一种：故事时间 &gt; 电影时间。最常见</p><p>第二种：故事时间 &lt; 电影时间。《罗拉快跑》</p><p>第三种：故事时间 = 电影时间。非常少见，例如《正午》</p><p>任何一部电影都离不开剪辑，是剪辑形成了电影的戏剧冲突，强化了电影的艺术表现。</p><h1 id="音乐歌舞片"><a href="#音乐歌舞片" class="headerlink" title="音乐歌舞片"></a>音乐歌舞片</h1><p>电影类型片</p><p>“类型片” 是指按照不同类型的规定而生产出来的影片。作为好莱坞大制作厂标准化生产的产物，“类型片” 以 “制片厂制度” 为基础，以追求经济利益最大化为目的。 </p><p>类型片有三个最基础的元素</p><ol><li><p>公式化的情节</p></li><li><p>定型化的人物</p></li><li><p>图解式的视觉形象</p><p>在世界百余年的发展历程中，主要形成了</p></li></ol><ul><li>音乐歌舞片</li><li>喜剧片</li><li>犯罪片</li><li>战争片</li><li>科幻片</li></ul><p>等电影类型。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>“音乐歌舞片” 是指以音乐舞蹈作为一部影片的观看中心，音乐和舞蹈共同进入叙事并成为叙事核心的电影类型。</p><p> 也是好莱坞历史最悠久，特征最明确的类型片。</p><h2 id="主要模式"><a href="#主要模式" class="headerlink" title="主要模式"></a>主要模式</h2><p>第一种电影的叙事时空完全舞台化。</p><p> 人物和故事情节等都处于虚构的环境中。</p><p>如</p><p>《雨中曲》《西区故事》《红磨坊》等。</p><p>第二种是影片有着较为写实的叙事时空，音乐歌曲是主人公的表演展示。</p><p>歌舞表演与电影叙事之间有着较为明晰的界限，音乐歌舞只是构成电影叙事的一部分。</p><p> 《红菱艳》《名扬四海》等。     </p><p>第三种是上述两种模式的并存。</p><p>既有随性而起的歌舞表演作为电影叙事的一部分，又有明确的歌舞表演段落。</p><p>《音乐之声》</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><h3 id="20-世纪-30-年代"><a href="#20-世纪-30-年代" class="headerlink" title="20 世纪 30 年代"></a>20 世纪 30 年代</h3><p>音乐歌舞片的 “黄金时代”。</p><p>特点：“后台” 歌舞片</p><p>以 后台 矮星故事为核心，主要讲述年轻女孩成名的故事。</p><p>代表作品是 1933 年的《第四十二街》</p><p>该片表现了正统爵士、踢踏舞的节奏韵律和动作美感，成为音乐歌舞片 “黄金时代” 的标志。</p><p> 音乐歌舞片之所以在上世纪 30 年代的好莱坞迎来黄金时代，主要有几方面原因：</p><ol><li>社会原因</li></ol><p>当时美国社会刚刚经历过前所未有的经济大萧条，社会矛盾激化，而音乐歌舞片中的歌舞升平，则能够为观众提供高质量的娱乐。</p><ol start="2"><li>“海斯法典” 的颁布</li></ol><p>1930 年著名的 “海斯法典“ 颁布后，电影中性和暴力的内容受到严格限制，于是音乐歌舞片的数量便开始剧增。</p><h3 id="20世纪-40-50-年代"><a href="#20世纪-40-50-年代" class="headerlink" title="20世纪 40-50 年代"></a>20世纪 40-50 年代</h3><p>特点：</p><p>受第二次世界大战的影响，观众对音乐歌舞片的兴趣降低，影片的数量也随之减少。</p><p>呈现出以乐观叙事为主的特点。</p><p> 代表作</p><p>《一个美国人在巴黎》《雨中曲》 </p><h3 id="20-世纪-60-年代的音乐歌舞片"><a href="#20-世纪-60-年代的音乐歌舞片" class="headerlink" title="20 世纪 60 年代的音乐歌舞片"></a>20 世纪 60 年代的音乐歌舞片</h3><p>进入 60 年代之后，由于电视强烈冲击，好莱坞为了留住电影观众，便投入更高的成本拍摄场面豪华、明星云集的音乐歌舞巨片，于是一批根据百老汇歌舞剧改编的影片便应运而生。</p><p>如《窈窕淑女》《音乐之声》《西区故事》</p><h3 id="20-世纪-70-80-年代的音乐歌舞片"><a href="#20-世纪-70-80-年代的音乐歌舞片" class="headerlink" title="20 世纪 70-80 年代的音乐歌舞片"></a>20 世纪 70-80 年代的音乐歌舞片</h3><p>背景：</p><p>西方社会的大变革时期：“嬉皮士运动” 的影响不断蔓延，“迪斯科” 也风靡全世界。</p><p>特点：</p><p>“青春派” 音乐歌舞片便在这一时期开始繁荣；更加突出镜头的跳跃与连接。</p><p>代表作 1982 年的《迷墙》</p><p>真人动画的超现实音乐歌舞片。</p><h3 id="20-世纪-90-年代以来的音乐歌舞片"><a href="#20-世纪-90-年代以来的音乐歌舞片" class="headerlink" title="20 世纪 90 年代以来的音乐歌舞片"></a>20 世纪 90 年代以来的音乐歌舞片</h3><p>特点：</p><p>类型杂糅、风格多样。</p><p>《舞出一片天》以芭蕾和嘻哈，演绎白人和黑人之间的爱情故事。还有《红磨坊》《芝加哥》等反映美国社会问题的音乐歌舞片。</p><h1 id="西部片"><a href="#西部片" class="headerlink" title="西部片"></a>西部片</h1><p>“西部片” 是指以美国西部拓荒为背景，以美国西部的荒野、小镇、牛仔和马尾主要视觉场景，反映文明与蛮荒、个人与社会、本民族与异域文明之间冲突的影片。</p><p>作为美国文化的典型代表，西部片产生于美国并主要在美国拍摄。其故事大多来源于美国西部文学或相关历史事件。作为典型的电影类型片西部片具有明确的类型片三要素：</p><ol><li>公式化的情节</li></ol><p>西部片的情节几乎都是警察、牛仔等孤胆英雄对抗印第安人、匪徒等恶势力，并最终取得胜利。</p><ol start="2"><li>定型化的人物</li></ol><p>正面人物：牛仔、淑女</p><p>反面人物：亡命歹徒、印第安人</p><p>中间人物</p><ol start="3"><li>图解式的视觉形象</li></ol><p>山谷、沙漠、荒凉的小镇或印第安营地，是西部片不变的外景；</p><p>简陋的驿站、酒馆、小木屋则是西部片不变的内景。</p><p>左轮手枪、马匹、皮裤、牛仔帽等也是西部片反复出现的道具。</p><p>西部片色彩和画面构图特点：</p><p>大量使用黄色调。</p><p>画面构图风格粗狂，多使用广角镜头，并讲究地平线的使用。</p><h2 id="“意大利西部片”"><a href="#“意大利西部片”" class="headerlink" title="“意大利西部片”"></a>“意大利西部片”</h2><p>“通心粉西部片”</p><p>特点：</p><p>印第安人的形象销声匿迹。</p><p>美国西部片往往在影片中大量呈现雄伟壮丽的美国西部自然风光，且以全景和远景镜头居多。 </p><p>相比之下，意大利西部片由于大多没有在美国拍摄，因此就较少呈现自然景观。</p><p>多以变焦镜头和景深镜头为主，同时大量使用特写镜头。</p><p>还有配乐方面</p><p>美国西部片习惯使用传统的管弦交响乐，旨在呈现一种磅礴的气势，并使影片具有一定的史诗气概。</p><p>也有的使用民谣风格的插曲，旨在给影片增加一种忧郁的气质。</p><p>意大利西部片的配乐则更为强烈，极富抒情性和感染力。</p><p>美国西部片代表作《荒野大镖客》《黄昏双镖客》《黄金三镖客》</p><p>意大利西部片代表作《姜戈》</p><p><strong>暴力美学《被解救的姜戈》</strong></p><h2 id="西部片发展史"><a href="#西部片发展史" class="headerlink" title="西部片发展史"></a>西部片发展史</h2><p>20世纪 30 -60 年代</p><p>《关山飞渡》改编自莫泊桑的《羊脂球》</p><p>《红河》</p><p>20 世纪 60-70 年代</p><p>日薄西山了</p><p> 《安邦定国志》、《小巨人》</p><p>《狼城脂粉侠》、《虎豹小霸王》</p><p>20 世纪 70-80年代</p><p>被遗忘</p><p>《天堂之门》</p><p>20 世纪 90 年代</p><p>重现辉煌</p><p>1990 年，由科斯特纳自导自演的《与狼共舞》，以一种正确的态度面对历史，并为印第安人正名，该片获得奥斯卡 7 项大奖。</p><p>《不可饶恕》</p><p>21 世纪之后的西部片</p><p>特点：传统的西部片的类型元素减少、新类型元素不断增加的特点。</p><p>《狂风沙》</p><h1 id="中国西部片"><a href="#中国西部片" class="headerlink" title="中国西部片"></a>中国西部片</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>以展示自己国家西部独特的历史文化、讲述西部故事为主要特征，具有鲜明的地域特色。</p><p>美国西部片的主体几乎都是征服于占领，而中国的西部片的主题则是发展与进步。</p><p>美国西部片的主角大多是英雄，而中国的西部片的主角则多为生活在西部的普通人，影片也主要关注个体的生命际遇。</p><p>美国西部片属于商业类型片，中国西部片则属于现实主义电影。</p><p>集中出现在新时期以后。</p><p>主要类型有四</p><ol><li>讲述中国西北黄土高原和黄河沿岸人们生活的影片。 《人生》《老井》《黄土地》《秋菊打官司》等</li><li>反映西部少数民族生活和相关宗教题材的影片。《猎场扎撒》<strong>《盗马贼》</strong>《黑骏马》《东归英雄传》《静静地嘛呢石》《冈仁波齐》</li><li>讲述我国西部沙漠戈壁传奇故事的影片。《新龙门客栈》《双旗镇刀客》</li><li>演绎西部地区的故事，并带有强烈商业色彩的影片。《红河谷》《黄河绝恋》《天地英雄》</li></ol><h2 id="发展-1"><a href="#发展-1" class="headerlink" title="发展"></a>发展</h2><ul><li>奠基期</li><li>徘徊期</li><li>发展期</li><li>成熟期</li></ul><p>《大红灯笼高高挂》</p><p><strong>《可可西里》</strong>（巡山队）</p><p>《三枪拍案惊奇》（是真的无聊）</p><p>《无人区》《一个勺子》</p><h1 id="喜剧片"><a href="#喜剧片" class="headerlink" title="喜剧片"></a>喜剧片</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>所谓喜剧片，是指以产生笑的效果为特征的电影类型。 </p><p>特点：</p><p>多元的 “笑”。</p><p>有的讽刺丑恶落后，有的歌颂光明美好。 </p><p>其目的都是为了让观众在笑中得到愉悦，或是在笑中获得启发。</p><h2 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h2><p>主要类型</p><ol><li>浪漫爱情喜剧</li><li>讽刺喜剧</li><li>闹剧</li><li>轻喜剧</li></ol><h3 id="浪漫爱情喜剧"><a href="#浪漫爱情喜剧" class="headerlink" title="浪漫爱情喜剧"></a>浪漫爱情喜剧</h3><p>《一夜风流》《罗马假日》</p><p>都是通过误会、巧合等演绎出令人难忘的浪漫爱情故事。</p><p>《风月俏佳人》《西雅图未眠夜》《四个婚礼和一个葬礼》</p><p>《北京遇上西雅图》（？？？？？深受观众喜爱吗？）</p><h3 id="讽刺喜剧"><a href="#讽刺喜剧" class="headerlink" title="讽刺喜剧"></a>讽刺喜剧</h3><p>“讽刺喜剧”，是指以尖锐的讽刺和嘲笑，揭露、抨击现实中不好的事物。</p><p>喜剧外表下潜藏着的讽刺，则是对社对人生更深层思考。</p><p>《淘金记》《摩登时代》</p><p><strong>《驴得水》</strong>（确实是近代国内的上乘之作）</p><h3 id="闹剧"><a href="#闹剧" class="headerlink" title="闹剧"></a>闹剧</h3><p>“闹剧” 往往采用大量的插科打诨，具有荒唐意外的情节，人物形象也是高度夸张或是十分滑稽。</p><p> 《憨豆先生》囧系列电影</p><h3 id="轻喜剧"><a href="#轻喜剧" class="headerlink" title="轻喜剧"></a>轻喜剧</h3><p>虽然喜剧味道不是很浓，但却会让人感到温馨，同时能够反映某些社会现实。即让观众在发出会心笑声的同时进行思考。</p><p> <strong>《甲方乙方》《私人订制》</strong>针砭(bīan)时弊</p><p>1997 年过去了，我很想它。</p><p>地主家也没有余粮了啊。</p><h2 id="西方喜剧片的发展"><a href="#西方喜剧片的发展" class="headerlink" title="西方喜剧片的发展"></a>西方喜剧片的发展</h2><p>启斯东电影公司。</p><p>《启斯东警察》</p><h3 id="一-20-世纪-30-年代：“社会喜剧”"><a href="#一-20-世纪-30-年代：“社会喜剧”" class="headerlink" title="一 20 世纪 30 年代：“社会喜剧”"></a>一 20 世纪 30 年代：“社会喜剧”</h3><p>特点：</p><p>具备较为强烈的社会意识，强调电影的戏剧结构和文化品位。</p><p>刘别谦《少奶奶的扇子》</p><h3 id="二-20-世纪-50-年代：“两性喜剧”"><a href="#二-20-世纪-50-年代：“两性喜剧”" class="headerlink" title="二 20 世纪 50 年代：“两性喜剧”"></a>二 20 世纪 50 年代：“两性喜剧”</h3><p>特点：<br>强调两性意识和现实感。</p><p>《热情似火》</p><h3 id="三-20-世纪六七十年代的个性喜剧"><a href="#三-20-世纪六七十年代的个性喜剧" class="headerlink" title="三 20 世纪六七十年代的个性喜剧"></a>三 20 世纪六七十年代的个性喜剧</h3><p>特点：</p><p>强烈的个性化</p><p> 《安妮·霍尔》<strong>《发条橙》</strong>。。。</p><p><strong>《毕业生》</strong>、《斯卡布罗集市》《寂静之声》</p><h3 id="四-20世纪-80-年代以来的喜剧片"><a href="#四-20世纪-80-年代以来的喜剧片" class="headerlink" title="四 20世纪 80 年代以来的喜剧片"></a>四 20世纪 80 年代以来的喜剧片</h3><p>特点：</p><p>更加符合时代发展和社会语境。</p><h2 id="中国喜剧片的发展"><a href="#中国喜剧片的发展" class="headerlink" title="中国喜剧片的发展"></a>中国喜剧片的发展</h2><h3 id="一、第一部喜剧片"><a href="#一、第一部喜剧片" class="headerlink" title="一、第一部喜剧片"></a>一、第一部喜剧片</h3><p>现存最早的一部中国电影：1922 年 “明星电影公司” 出品的喜剧片《劳工之爱情》。</p><h3 id="二、1949-年之前的中国喜剧片"><a href="#二、1949-年之前的中国喜剧片" class="headerlink" title="二、1949 年之前的中国喜剧片"></a>二、1949 年之前的中国喜剧片</h3><p>特点：</p><p>呈现出抨击社会黑暗，批判封建礼教，追求个性解放和婚恋自由的主题。</p><p>《月老离婚》《四月里底蔷薇处处开》《呆中福》</p><h3 id="三、“十七年”"><a href="#三、“十七年”" class="headerlink" title="三、“十七年”"></a>三、“十七年”</h3><ul><li>讽刺喜剧</li><li>歌颂喜剧</li><li>轻喜剧</li></ul><p>《五朵金花》《今天我休息》</p><p>《大李、小李和老李》《锦上添花》《魔术师的奇遇》</p><h3 id="四、新时期以后：多样化的喜剧片"><a href="#四、新时期以后：多样化的喜剧片" class="headerlink" title="四、新时期以后：多样化的喜剧片"></a>四、新时期以后：多样化的喜剧片</h3><ul><li>改革喜剧——主要反映改革开放之初的新生活和新状态。《车水马龙》《赵钱孙李》《愁眉笑脸》《生财有道》等</li><li>荒诞喜剧——以黄建新导演的 “赵书信两部曲” 为代表。《黑炮事件》《错位》《顽主》。1988 年的《顽主》 是中国喜剧电影从传统走向现代的标志。传统喜剧片以辛辣的讽刺和滑稽的情趣为特点；而现代喜剧片则渗透着悲凉、绝望和黑色风格。 </li><li>系列喜剧  ——陈佩斯和陈强父子主演的 “二子系列”《二子开店》，以及上海导演张刚创作的反映社会问题的阿满系列《面目全非》、《笑出来的眼泪》</li><li>动作喜剧——代表作品：成龙的 “功夫+喜剧” 电影。特点：喜剧和动作在影片中占有同等重要的位置。《醉拳》《警察故事》《快餐车》</li><li>无厘头喜剧——代表人物：周星驰。特点：以无限夸张的喜剧桥段表现社会的冷漠或人性的丑陋，通过刻画底层小人物的遭遇让观众在笑中带泪。《喜剧之王》《食神》《少林足球》等 。</li><li>贺岁喜剧—— 代表人物：冯小刚。特点：采用市民文化策略表现普通百姓的悲欢。《甲方乙方》《不见不散》《没完没了》《私人订制》等。</li><li>侦探喜剧——融合了悬疑、喜剧、推理、惊悚、爱情等各种商业元素。代表作：宁浩的疯狂的系列，王宝强主演的唐人街探案系列。《疯狂的石头》《疯狂的赛车》《唐人街探案1》《唐人街探案2》。唐人街探案系列当让你爽的电影看就好了。</li></ul><h1 id="武侠片"><a href="#武侠片" class="headerlink" title="武侠片"></a>武侠片</h1><h2 id="概说"><a href="#概说" class="headerlink" title="概说"></a>概说</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>“武侠片” 又称 “功夫片” 或者 “武术片”，是指以中国功夫和武侠传奇为主要表现对象的电影类型。</p><p>作为唯一一种由中国首创，并主要由中国拍摄的电影类型，武侠片以其独有的艺术魅力和娱乐风格。在中国电影发展史中具有无法取代的历史地位和现实意义。</p><h3 id="二、“武侠片”-VS-”动作片“"><a href="#二、“武侠片”-VS-”动作片“" class="headerlink" title="二、“武侠片” VS ”动作片“"></a>二、“武侠片” VS ”动作片“</h3><p>”动作片“ 是指以人或机械的动作为主要形式，表现基本的社会价值观，满足大众相关审美需求的电影类型。</p><p>《极速飞车》《速度与激情》等。也就是说 “动作片” 包括 “武侠片”，“武侠片” 是一种以人的动作为主的 “动作片”。</p><h3 id="三、中国第一部武侠片"><a href="#三、中国第一部武侠片" class="headerlink" title="三、中国第一部武侠片"></a>三、中国第一部武侠片</h3><p>1925 年由 “天一电影公司” 出品的 《女侠李飞飞》 是我国第一部武侠片。</p><p>还创造了一个行当：武术指导。</p><p>二 武侠片关键词：“武术指导”</p><p>几乎所有的电影行当都是由外国人创立的：制片、编剧、导演、摄影、美术、服装、道具等。</p><p>代表人物：刘家良、袁和平 、程小东。</p><p>《杀死比尔》袁和平</p><p>《忍者神龟》刘家良</p><p>“武术指导” 也称 “动作指导” 或 ”武术设计“。</p><ol><li>最早出现： 1928 年的《火烧红莲寺》</li><li>确立：第一次创作热潮，即 1928-1931 年间，“武术指导” 开始作为固定的职务确立下来。</li><li>发展：上世纪 50 年代，几乎每一部武侠片中都有 “武术指导”。</li><li>成熟：60 年代，得益于 “邵氏” 武侠片的繁荣，“武术指导” 的作用愈发凸显。</li><li>快速发展：70 年代之后，由于武侠片客观的经济效益，“武术指导” 的待遇也水涨船高。</li></ol><h2 id="武侠片的分类"><a href="#武侠片的分类" class="headerlink" title="武侠片的分类"></a>武侠片的分类</h2><ul><li>神怪传奇类武侠片</li><li>人物传记类武侠片</li><li>古装刀剑类武侠片</li><li>功夫技击类武侠片</li><li>谐趣喜剧类武侠片</li><li>魔幻神话类武侠片</li></ul><h3 id="神怪传奇类武侠片"><a href="#神怪传奇类武侠片" class="headerlink" title="神怪传奇类武侠片"></a>神怪传奇类武侠片</h3><p>神怪传奇类武侠片的历史最为悠久，其以我国民间的神圣武侠文学为原型，且主要依赖特技技术。</p><p> 1982 年的《火烧红莲寺》</p><p>《倩女幽魂》《青蛇》</p><h3 id="人物传记类武侠片"><a href="#人物传记类武侠片" class="headerlink" title="人物传记类武侠片"></a>人物传记类武侠片</h3><p>人物传记类武侠片与我国历史上的多位武术家密切相关。</p><p>《方世玉》《霍元甲》《黄飞鸿》</p><p>在百余年的历史上，截至目前共拍摄了 105 部 “黄飞鸿电影”，创造了世界电影史的一个记录。</p><p>《叶问》《一代宗师》（念念不忘，必有回响）</p><h3 id="古装刀剑类武侠片"><a href="#古装刀剑类武侠片" class="headerlink" title="古装刀剑类武侠片"></a>古装刀剑类武侠片</h3><p>古装刀剑类武侠片繁荣于 20 世纪 60 年代，并形成了中国武侠电影的第二次创作高潮。</p><p>《独臂刀》《碧血剑》</p><p>《龙门客栈》《大醉侠》《侠女》</p><h3 id="功夫技击类武侠片"><a href="#功夫技击类武侠片" class="headerlink" title="功夫技击类武侠片"></a>功夫技击类武侠片</h3><p>功夫技击类武侠片是最接近中国功夫的武侠电影类型，其特点是以真功夫折服观众，并强调武侠和武德。</p><p>李小龙</p><p>《唐山大兄》《精武门》《龙争虎斗》《猛龙过江》</p><h3 id="谐趣喜剧类武侠片"><a href="#谐趣喜剧类武侠片" class="headerlink" title="谐趣喜剧类武侠片"></a>谐趣喜剧类武侠片</h3><p>20 世纪 70 年代，随着中国电影的商业化发展，最具商业价值的喜剧元素开始进入武侠片，并形成了将喜剧夸张表演与武打动作结合的谐趣喜剧类武侠片。</p><p>成龙</p><p>《蛇形刁手》《醉拳》</p><h3 id="魔幻神话类武侠片"><a href="#魔幻神话类武侠片" class="headerlink" title="魔幻神话类武侠片"></a>魔幻神话类武侠片</h3><p>是在电影技术发展的前提下，以虚拟数字技术为特征，以虚构故事为内容的武侠电影类型。</p><p>《蜀山：新蜀山剑侠》《蜀山传》</p><h2 id="武侠片的经典场景"><a href="#武侠片的经典场景" class="headerlink" title="武侠片的经典场景"></a>武侠片的经典场景</h2><ol><li>盘肠大战</li><li>竹林大战</li><li>飞檐走壁与凌波微步</li><li>客栈大战</li><li>舞狮大战</li></ol><h3 id="盘肠大战"><a href="#盘肠大战" class="headerlink" title="盘肠大战"></a>盘肠大战</h3><p>最早出自于中国古典戏曲《界牌关》。后来被武侠片借用，其中以张彻的 “阳刚电影” 为主要代表。</p><p> 《大刺客》</p><p>（暴力美学）</p><h3 id="竹林大战"><a href="#竹林大战" class="headerlink" title="竹林大战"></a>竹林大战</h3><p>《侠女》《白发魔女传》《青蛇》《卧虎藏龙》</p><p>《十面埋伏》不是也是么。</p><p>《英雄》对竹林大战进行了改造，“胡杨林大战”。</p><h3 id="飞檐走壁与凌波微步"><a href="#飞檐走壁与凌波微步" class="headerlink" title="飞檐走壁与凌波微步"></a>飞檐走壁与凌波微步</h3><p>吊威亚来实现。</p><p>“威亚”，即英文单词 “钢丝” 的音译。“飞檐走壁” 和 “凌波微步” 都采用 “吊威亚” 的方式，只是通过不同的落点来形成不同的视觉效果。</p><h3 id="客栈大战"><a href="#客栈大战" class="headerlink" title="客栈大战"></a>客栈大战</h3><p>客栈大战作为一种极具中国文化特色的电影场景，体现了武侠电影创作对中国传统戏曲空间表现手法的借鉴，即突出空间的舞台化。</p><p>《大醉侠》《龙门客栈》《卧虎藏龙》</p><h3 id="舞狮大战"><a href="#舞狮大战" class="headerlink" title="舞狮大战"></a>舞狮大战</h3><p>由于早期的 “武术指导” 多为 “龙虎武师”，于是就促成了舞狮与武侠电影创作的结合。</p><p>体现了武侠片对中国传统文化的借鉴与汲取，从而彰显出中国武侠电影的民族文化气质。</p><h1 id="本文分析：电影的视听语言与叙事形式"><a href="#本文分析：电影的视听语言与叙事形式" class="headerlink" title="本文分析：电影的视听语言与叙事形式"></a>本文分析：电影的视听语言与叙事形式</h1><h2 id="电影造型性、运动性与节奏"><a href="#电影造型性、运动性与节奏" class="headerlink" title="电影造型性、运动性与节奏"></a>电影造型性、运动性与节奏</h2><h3 id="电影批评的职能"><a href="#电影批评的职能" class="headerlink" title="电影批评的职能"></a>电影批评的职能</h3><p>认识影片物质形态，提示影片价值要点；</p><p>呈现电影知识系统，辅助未来创作改进；</p><p>促进影人与社会互动，提升观众审美能力。</p><p> 如 <strong>安德烈·巴赞</strong></p><h3 id="电影批评的专业素养"><a href="#电影批评的专业素养" class="headerlink" title="电影批评的专业素养"></a>电影批评的专业素养</h3><p>能够运用专业知识、审美经验和批判意识打开观众视野。</p><p>如何获得专业素养。</p><p>解读电影视听语言与叙事形式的本文分析是非常重要的一种批评方法。</p><p>重点：探讨电影的造型、运动性与节奏。</p><p>镜头的内部元素：</p><ul><li>色彩</li><li>光线</li><li>画面构图</li><li>声音</li></ul><p>都具有造型的功能。</p><p>运动又有：</p><ul><li>被拍摄物体的运动</li><li>摄影机的运动</li><li>综合运动</li></ul><p>《修女艾达》</p><p>黑白色彩赋予影像一种理性，让观众思考艾达的选择。</p><p>在构图上，艾达往往处于画框右侧或左侧底部，这是在表明人物尚未摆脱历史与现实的束缚。</p><p>“阴阳脸” 高反差布光象征她在宗教和尘世之间犹豫徘徊。绝大部分镜头是固定镜头，这是在象征表达艾达还没有确定自己的未来。但在电影的结尾，当艾达确定了自我追求后，电影是一个运动的长镜头结束故事，电影由此展现出一个修女自我意识的觉醒。</p><h3 id="电影节奏"><a href="#电影节奏" class="headerlink" title="电影节奏"></a>电影节奏</h3><ul><li>内部节奏</li><li>外部节奏</li></ul><p><strong>内部节奏</strong></p><p>由多种因素综合而成，如事件和情节的安排，以及场面调度。</p><p><strong>外部节奏</strong></p><p>主要指向镜头的剪接。它受到镜头的长度和幅度两个元素影响，长度指镜头时长以及镜头所表现内容的时间延续感，幅度则指的景别。</p><p>1966 年《一个男人和一个女人》<strong>《这个杀手不太冷》</strong></p><p> 《这个杀手不太冷》在杀手出场的时候，用了 19 个镜头，这 19 个镜头全部都是特写镜头固定镜头，并且每个镜头的时长都比较短，从而营造人物的神秘和迅捷。</p><h2 id="《你从未在此》"><a href="#《你从未在此》" class="headerlink" title="《你从未在此》"></a>《你从未在此》</h2><p>关注一个男人如何走出童年暴力与战争所带来的心理创伤。</p><p>电影片名出来之前，电影开始的这个部分，安排了三场戏。</p><ol><li>蒙太奇与场面调度</li><li>特写与全景</li><li>固定于运动</li></ol><p>跳接：</p><p>跳接指的是两个镜头内的主体相同，而摄影机距离及角度上差距不大，当两个镜头连接在一起时，在银幕上便会明显地跳一下。</p><p>喜剧之王在向柳飘飘表白，也是用的跳接， 用了两个周星驰的特写镜头，来表明主人公忐忑不安的心理。</p><h1 id="电影作者论与文本细读"><a href="#电影作者论与文本细读" class="headerlink" title="电影作者论与文本细读"></a>电影作者论与文本细读</h1><h2 id="电影作者论"><a href="#电影作者论" class="headerlink" title="电影作者论"></a>电影作者论</h2><p> 时间上追溯到 1948 年 3 月 30 日。地域上追溯到法国。 </p><p>摄影机——自来水笔：新先锋派的诞生。</p><p>它意味着电影必将逐渐挣脱纯视觉形象、绝画面、直观故事和具体表象的束缚，成为与文字语言一样灵活、一样精妙的写作手段。</p><p>—— 阿斯特吕克</p><p>《糟糕的相遇》</p><p>后来女演员又主演了《一个男人和一个女人》</p><p>巴赞《论作者策略》</p><p>其实一个导演的作品时参差不齐的，比如导演奥逊威尔斯，他的《公民凯恩》开启了美国电影的新时代，《阿卡丁先生》只是一部二流作品。</p><h2 id="王家卫的家和卫"><a href="#王家卫的家和卫" class="headerlink" title="王家卫的家和卫"></a>王家卫的家和卫</h2><p>按时间排序</p><ol><li>《旺角卡门》</li><li>《阿飞正传》</li><li>《东邪西毒》</li><li>《重庆森林》</li><li>《堕落天使》</li><li>《春光乍泄》</li><li>《花样年华》</li><li>《2046》</li><li>《蓝莓之夜》</li><li>《一代宗师》</li></ol><p>王家卫电影的秘密就在他的名字当中，家与卫有着先锋前卫的影像，注重日常生活细节的叙事，从而给人以奇异而熟悉的感觉。</p><p>《阿飞正传》</p><p>拒绝与逃离，沉迷与顿悟。</p><p>《春光乍泄》</p><p>跳接</p><p>《花样年华》</p><h2 id="情调与母题的集合体"><a href="#情调与母题的集合体" class="headerlink" title="情调与母题的集合体"></a>情调与母题的集合体</h2><p>《2046》</p><p>用不同的背景音乐来配合人物出镜。</p><p>越轴，预示不好的场景。关于越轴，在《电影批评》中有介绍。</p><p>天台的镜头。带花的和不带花的，表现得不一样。</p><h1 id="类型成规与现实经验"><a href="#类型成规与现实经验" class="headerlink" title="类型成规与现实经验"></a>类型成规与现实经验</h1><h2 id="电影的范式与革新"><a href="#电影的范式与革新" class="headerlink" title="电影的范式与革新"></a>电影的范式与革新</h2><p>安德烈·巴赞把类型电影称为一种寻找内容的形式， 可以从以下三个维度来理解。</p><ul><li>制作者</li><li>影片</li><li>观众</li></ul><p>类型电影一般具有</p><ul><li>公式化的情节</li><li>定型化的人物</li><li>图解式的视觉</li><li>基本的价值理念和道德观念</li></ul><p>《侠骨柔情》</p><h2 id="《青少年警队》反警匪类型的创作踪迹"><a href="#《青少年警队》反警匪类型的创作踪迹" class="headerlink" title="《青少年警队》反警匪类型的创作踪迹"></a>《青少年警队》反警匪类型的创作踪迹</h2><p>淡化类型惯例，放大现实生活经验从非写实转向写实，这是很多反类型电影的一种创作方法。</p><p>1994 年《这个杀手不太冷》的饰演的风尘女子的角色，麦温。当时是导演吕克贝松的女友，后来自己也成为了导演。《青少年警队》就是她的作品。</p><p>正如巴赞所指出的：</p><p><strong>电影好比女引座员拿着的小手电筒，那摇曳的灯光像闪烁不定的彗星，划过我们醒着做梦的黑夜，那是银幕周围向四面扩展的漫无边际的空间</strong></p><h1 id="叙事学理论与英雄冒险历程"><a href="#叙事学理论与英雄冒险历程" class="headerlink" title="叙事学理论与英雄冒险历程"></a>叙事学理论与英雄冒险历程</h1><h2 id="电影叙事学的两种走向"><a href="#电影叙事学的两种走向" class="headerlink" title="电影叙事学的两种走向"></a>电影叙事学的两种走向</h2><ol><li>借用格雷马斯的理论探讨对影像中的叙事结构。</li><li>借用热内特的叙事角度学说，探讨水在叙述的问题。</li></ol><p>普罗普《民间故事形态学》</p><p>对民间故事的叙事功能进行研究，提炼出七种行动范畴和六个叙事单元。</p><p>格雷马斯则提出六个动素和一个意义矩阵。</p><p> 《第五元素》《功夫熊猫》《银河护卫队》都可以按照这个理论来解读。</p><ul><li>准备单元</li><li>纠纷单元</li><li>转移单元</li><li>抗争单元</li><li>归来单元</li><li>接受单元</li></ul><p>《罗生门》举例</p><h3 id="王牌特工·特工学院"><a href="#王牌特工·特工学院" class="headerlink" title="王牌特工·特工学院"></a>王牌特工·特工学院</h3><p>受到普罗普的影响，神话学家坎贝尔在他的著作《千面英雄》 对神话传统进行了分析，得出了一种叙事模式。</p><p>一个从平凡世界召唤出来，并踏上冒险旅程的英雄，他进入到一个既有盟友也有敌人并且充满磨难的世界，最后英雄要到达一个隐秘的洞穴，这样一个接受终极考验的场所，胜利之后英雄回归到发生改变的日常生活中。</p><p>很多电影都是这样的一个叙事。</p><p>例如《王牌特工·特工学院》</p><p><strong>特工电影分为两类：</strong></p><p>一、非写实的戏剧情节</p><p>007《谍影重重》系列</p><p>二、类型片融入大量现实经验，毫无高科技与绚丽的动作。</p><p>英国 70 年代《义普克雷斯档案》。</p><p><strong>母题</strong></p><p>电影里任何有意义且重复出现的元素。</p><p>母题可能是物品、颜色、地点、声音，也可以是打光法或摄影机的位置。</p><h1 id="欧洲先锋派电影"><a href="#欧洲先锋派电影" class="headerlink" title="欧洲先锋派电影"></a>欧洲先锋派电影</h1><h2 id="欧洲先锋派电影运动"><a href="#欧洲先锋派电影运动" class="headerlink" title="欧洲先锋派电影运动"></a>欧洲先锋派电影运动</h2><h3 id="概说-1"><a href="#概说-1" class="headerlink" title="概说"></a>概说</h3><p>欧洲先锋派电影运动是指上世界 20 年代出现在欧洲的一次实验电影运动，其以法国和德国为中心，同时涉及意大利、英国、法国等多个欧洲国家。</p><p> 欧洲先锋派电影运动的发展阶段</p><ol><li>第一先锋派电影</li><li>第二先锋派电影</li><li>第三先锋派电影</li></ol><p><strong>第一先锋派电影</strong></p><p>即印象主义阶段，主要以 “法国印象主义电影” 为代表，从 1917 年到 1929 年贯穿 “欧洲先锋派电影运动” 的始终。</p><p>印象主义</p><p>设法忘掉你前面的物体，准确地画下你所观察到的颜色和形状，直到达到你最初的印象为止</p><p>——莫奈</p><p><strong>第二先锋派电影</strong></p><p>即超现实主义阶段，主要以 20 年代的 “法国超现实主义电影” 和 “德国表现主义电影” 为核心。</p><p><strong>第三先锋派电影</strong></p><p>即记录电影阶段，主要活跃于 1927 年至 1930 年间，指由卡瓦尔康所创立的 “记录电影流派”，以他在 1926 年拍摄的记录电影《只有几小时》为标志。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>出现于 20 世纪 20 年代，与当时的科技发展、文化思潮、社会背景，以及电影自身的变革需求等紧密相关。</p><ol><li>电影技术的进步</li></ol><p>从第一次世界大战结束到 1929 年资本主义世界爆发的大规模的经济危机之前，欧洲国家经历了一段相对稳定的和平发展时期，这一时期的科技进步，为电影的发展奠定了良好的物质基础。</p><p>摄影机、胶片、灯光设备等都取得了长足的进步。</p><ol start="2"><li>现代主义思潮</li></ol><p>第一次世界大战在欧洲思潮文化界引发了巨大的反应，人们开始怀疑甚至否定以往的社会观念和精神文明成果，于是现代主义思潮在 19 世纪末快速发展。</p><p>以弗洛伊德的精神分析学说影响最大，其间接促成表现主义电影和超现实主义电影的出现。</p><ol start="3"><li>工业革命的冲击</li></ol><p>工业革命使现代机械逐渐取代了人在社会生产中的地位，人们越来越深的感受到工业化的压抑与制约，因此追求个人化的表达，也就成为了一种新的社会发展趋势。</p><ol start="4"><li>“欧洲先锋派电影” 也是电影自身发展所必然要经历的一个阶段。</li></ol><p>第一次世界大战之后，欧洲大多数国家的电影市场都被好莱坞占据，欧洲电影在艺术上几乎停滞，并呈现出较为严重的商业化倾向。</p><p>卡努杜与 “第七艺术”。</p><p>可以说，欧洲先锋派电影运动在一定程度而言，就是努力将电影发展为一门独立艺术的探索与实践。</p><h2 id="第一先锋派"><a href="#第一先锋派" class="headerlink" title="第一先锋派"></a>第一先锋派</h2><h3 id="“印象主义”-与-“印象主义电影”"><a href="#“印象主义”-与-“印象主义电影”" class="headerlink" title="“印象主义” 与 “印象主义电影”"></a>“印象主义” 与 “印象主义电影”</h3><p>第一先锋派是指以法国为中心的 “印象主义电影”。</p><p>“印象主义” 最早出现于绘画，由法国画家莫奈的《日出印象》为代表的绘画流派。</p><p>“印象主义” 绘画主张以色调的分离、色彩的闪烁等手法来表现对大自然的主观印象，反对当时思想保守、题材僵化和手法老旧的学院派绘画，提倡革新与突破。</p><p>法学电影史学家朗格卢瓦首先在电影中使用 “印象主义” 一词。</p><p>德吕克、杜拉克、莱皮埃、冈斯为代表的电影流派。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>电影表现内容</li></ol><p>“印象主义电影” 认为，电影作为艺术家表达自我的情感场所，要描写人物的内心细微变化。</p><p> 1919 年德吕克和杜拉克联合创作的电影《西班牙的节日》</p><ol start="2"><li>电影的摄影技巧</li></ol><p>“印象主义电影” 的导演们在创作实践中积极使用各种新的摄影技巧，旨在以新的摄影手段表现人物的心理状态。</p><p>代表作 1922 年冈丝拍摄的电影《车轮》</p><ol start="3"><li>科技的进步也带来了电影器材的发展</li></ol><p>“印象主义电影” 的导演们在创作实践中积极使用各种新的摄影技巧，旨在以新的摄影手段表现人物的心理状态。 </p><p>1927 年，冈丝的《拿破仑》就使用了最新的摄影机镜头和宽格画面。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>以 “印象主义电影” 为核心的 “第一先锋派”，在电影的心理表现、摄影镜头的运用、后期剪辑等方面的探索和实践，极大丰富了电影的表现能力，这些创新也成为了当时法国电影与好莱坞抗衡的手段。</p><p>1924 年德吕克去世后，“印象主义电影” 开始逐渐解体：其中一部分人转向拍摄商业电影，另一部分则选择与商业电影彻底决裂的先锋派道路。</p><p>到 1929 年，“印象主义电影” 基本停止创作。</p><h2 id="第二先锋派（理论基础）"><a href="#第二先锋派（理论基础）" class="headerlink" title="第二先锋派（理论基础）"></a>第二先锋派（理论基础）</h2><p><strong>主要特点</strong></p><p>超现实主义</p><p><strong>相关概念</strong></p><ol><li>“立体主义”</li><li>“未来主义”</li><li>“达达主义”</li></ol><p><strong>立体主义</strong></p><p>最早出现于绘画领域，其特点是反对传统的写实主义，注重形式，强调表现人对外界事物的主观印象和感受。</p><p>先有作品而后进行理论归纳。</p><p><strong>纯电影</strong></p><p><strong>抽象电影</strong></p><p><strong>未来主义</strong></p><p>先有理论的提出，然后由理论指导创作实践。</p><p>出现于 1909 年的 “未来主义”，反对传统的艺术主张，强化运动之美和速度之美。</p><p>1916 年，“未来主义电影宣言” 发表，提出电影要发挥能动性，超越对现实的简单机械复制。</p><p><strong>达达主义</strong></p><p>兴起于第一次世界大战时期的瑞士，最早也是出现在绘画和文学领域，后来被引入到电影中。</p><p>以婴儿的发音为命名，直接表达了旨在婴儿呀呀学语期间对周围事物的纯生理反应，进而指出文艺创作应该像婴儿学说话那样，排除思想干扰，只是表现感官的印象 。</p><p>总体看来，“立体主义” 和 “未来主义” 反对传统艺术的观点，“达达主义” 对传统艺术观念的颠覆，都与 “先锋派电影” 有着内在的一致性。</p><h3 id="纯电影"><a href="#纯电影" class="headerlink" title="纯电影"></a>纯电影</h3><p>“纯电影” 反对叙事，主张将电影从其它艺术的束缚中解放出来，强调通过剪辑凸显电影画面的节奏感，即让画面压倒电影中的其它元素，主宰一切并单独起作用。</p><p>如莱谢尔在 1923 年的《机器的舞蹈》 </p><p>《纯电影的五分钟》</p><h3 id="抽象电影"><a href="#抽象电影" class="headerlink" title="抽象电影"></a>抽象电影</h3><p>“抽象电影” 作为一种追求最纯粹的电影形式的先锋电影，深受抽象主义绘画的影响，强调为形式而形式，为艺术而艺术；认为电影不仅是视觉节奏的艺术，还应该是光的艺术。</p><p>1921 年 《车轮》 1924 年 《对角线交响乐》，</p><p>1921 年《第二十一号节奏》1926 年《电影习作》等。</p><p>杜拉克</p><p>1928 年《958 号唱片》1929 年《阿拉伯花饰》。</p><h3 id="达达主义电影"><a href="#达达主义电影" class="headerlink" title="达达主义电影"></a>达达主义电影</h3><p>深受 “达达主义” 影响的 “达达主义电影”，继承和发展了 “未来主义电影” 的创作特点。</p><p>1923 年《回归理性》</p><p>1924 年 《幕间休息》</p><p>促进了法国超现实主义电影的出现。</p><h2 id="第二先锋派"><a href="#第二先锋派" class="headerlink" title="第二先锋派"></a>第二先锋派</h2><h3 id="法国超现实主义电影"><a href="#法国超现实主义电影" class="headerlink" title="法国超现实主义电影"></a>法国超现实主义电影</h3><p>兴起于 20 世纪 20 年代，主要是将绘画和文学中的 “超现实主义” 创作方法用于电影。</p><p>经典作品，主要有达利的《记忆的永恒》、《内战的预感》等。</p><p>秉承超现实主义文学家安德烈·布列松的相关理论主张：强调真实的无理性行为、梦幻的重要意义，以及不协调的形象所产生的情绪力量等。</p><p>深受弗洛伊德精神分析学说的影响，以探索对人物意识的表现为重点。</p><p>开山之作，杜拉克在 1927 年拍摄的《贝壳与僧侣》</p><p>布努埃尔 1928 年 《一条安达鲁狗》</p><p>后来的电影研究者有关变态心理和无理性行为等的呈现，都归结为 “超现实主义” 在电影中的具体体现。</p><p>《爱德华大夫》《眩晕》《西北偏北》《群鸟》等。总体来说 ”法国超现实主义电影“ 不再像之前的 “纯电影” 和 “抽象电影” 那样，过分关注物体的线条与图形，也不再具有过于强烈的节奏感，而是转为关注人物的内心深处。</p><h3 id="德国表现主义电影"><a href="#德国表现主义电影" class="headerlink" title="德国表现主义电影"></a>德国表现主义电影</h3><p>时间：1919-1926 年</p><p>特点：将文学、戏剧和绘画中的表现主义手法用于电影创作，电影布景呈现出失真和变形的状态。</p><p>罗伯特·维内在 1919 年拍摄的影片 《卡里加里博士》</p><h2 id="第三先锋派"><a href="#第三先锋派" class="headerlink" title="第三先锋派"></a>第三先锋派</h2><p><strong>欧洲先锋派电影运动中的 “第三先锋派”，是一个记录电影流派</strong>。</p><p>其创作深受苏联电影眼睛派导演维尔托夫的两部影片《电影真理报》《电影眼睛》的影响和启发，在创作中拜托了之前先锋派电影对现实的逃避，而更多去关注现实生活。</p><p>第三先锋派创作出了一批被称为 “城市交响乐” 的纪实电影。</p><p>《柏林：城市交响曲》 《雨》<strong>《持摄影机的人》</strong>《尼斯印象》</p><p>拉不孔在 1928 年拍摄影片的 《贫民窟》，这部电影开创了反应社会问题的记录电影的创作先河。</p><p>“纪录片教父” 格里尔逊在 1929 年拍摄的纪实电影片《漂网渔船》，也是 “第三先锋派” 的代表作品。</p><p><strong>三个阶段的共同点</strong></p><p>不以商业盈利为目的，不以讲述故事为宗旨；</p><p>以探索无声电影的纯粹视觉表现和美学特征为主要使命。</p><p><strong>背景</strong></p><p>20 世纪 20 年代末，在资本主义世界全面爆发经济危机的社会背景下，同时伴随着有声电影的发明与普及。“欧洲先锋派电影运动” 逐渐走向终结。</p><p><strong>影响</strong></p><p>“印象主义电影” 对电影光线的处理和对电影影调的整体把握，以及对各种运动镜头的探索与实践，尤其是高速摄影和低速摄影的发明等，一直被沿用至今。</p><p>“表现主义电影” 中的场面调度和灯光、场景布置的方法等，也深刻的影响了后来的电影创作，尤其是恐怖电影和黑色电影受其影响最为深刻。</p><p>除了在电影视觉表现方面的探索和实践，“欧洲先锋派电影运动” 还提供了一种新的用电影观察世界的方法，提出了电影与世界、与社会发生联系的新的可能。 </p><h1 id="苏联蒙太奇电影学派"><a href="#苏联蒙太奇电影学派" class="headerlink" title="苏联蒙太奇电影学派"></a>苏联蒙太奇电影学派</h1><h2 id="概说-2"><a href="#概说-2" class="headerlink" title="概说"></a>概说</h2><p>“苏联蒙太奇电影学派”，形成于 20 世纪 20 年代中期的苏联，以库里肖夫、爱森斯坦、普多夫金等人为主要代表。</p><p>致力于探索新的电影表现手段以表现新时代的革命电影艺术。</p><p>通过对 “蒙太奇” 的实验和研究，“苏联蒙太奇学派” 创立了 “电影蒙太奇” 的系列理论，并将理论运用于电影的创作实践。</p><p>《战舰波将金号》《母亲》</p><p>“苏联蒙太奇学派” 出现于 20 世界 20 年代的苏联的原因：</p><p>新生的苏维埃政权为 “蒙太奇学派” 奠定了意思形态的基础。</p><p><strong>好莱坞的 ‘平行蒙太奇“ 仅仅是将电影片段进行组接，只具有叙事学意义；而苏联电影则将蒙太奇变为具有比拟隐喻、双关等意味的概念，从而以 ”影像的革命“ 同步苏联 ”革命的影像“。 ——爱森斯坦</strong></p><p>20 年代盛极一时的俄国形式主义思潮也为 “蒙太奇学派” 提供了方法论。</p><p>先锋派意识，马雅可夫斯基的未来派诗歌，康定斯基的未来派绘画。</p><p>当时电影创作的物质匮乏也在客观上促使苏联电影人对残存电影胶片进行更为细致、微观的探索。</p><p>对电影胶片再次剪辑。</p><p>“苏联蒙太奇学派” 对电影蒙太奇技巧的全面运用，使苏联电影在当时拥有了最为强劲的节奏感和冲击力，并影响了后来的好莱坞商业电影拍摄，尤其是动作片中快速、凌厉的画面剪辑。</p><p>著名电影史学家大卫·波德维尔曾经利用统计学原理分析指出</p><p>20 世纪 20 年代 的苏联电影通常包含 600 到 2000 个镜头，镜头的平均长度为 2 到 4秒。</p><p>1919 年到 1928 年间的好莱坞电影，所包含的镜头数量则是 500 到 1000 之间，镜头的平均长度为 5 到 6 秒。</p><p>1967 年的《邦妮与克莱德》的镜头的平均长度为 3.8 秒。</p><h2 id="意义与影响"><a href="#意义与影响" class="headerlink" title="意义与影响"></a>意义与影响</h2><p>”苏联蒙太奇学派“ 对电影蒙太奇类型的探索，至今仍然是许多电影创作的灵感来源。</p><p>维尔托夫所拍摄的《持摄影机的人》。</p><h2 id="代表人物与主要观点"><a href="#代表人物与主要观点" class="headerlink" title="代表人物与主要观点"></a>代表人物与主要观点</h2><p>库里肖夫、维尔托夫、爱森斯坦、普多夫金。</p><p>库里肖夫不仅是苏联电影导演和电影理论家，作为一名老师，他还培养了爱森斯坦、普多夫金等苏联蒙太奇学派中坚力量。</p><h3 id="一、库里肖夫效应实验"><a href="#一、库里肖夫效应实验" class="headerlink" title="一、库里肖夫效应实验"></a>一、库里肖夫效应实验</h3><p>关键字：男演员、面无表情、特写镜头。与一盆汤、一口安放死者的棺材、和一个小女孩三个不同的镜头剪辑在一起。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/04/25/Pq5YzbNsB7jKkQ9.jpg" alt="下载.jpeg"></p><p>结论：</p><p>造成观众情绪反应的不是单个镜头的内容，而是画面剪辑的结果。</p><h3 id="二、维尔托夫与-“电影眼睛理论”"><a href="#二、维尔托夫与-“电影眼睛理论”" class="headerlink" title="二、维尔托夫与 “电影眼睛理论”"></a>二、维尔托夫与 “电影眼睛理论”</h3><p>《持摄影机的人》</p><p>将统一天内苏联几个不同城市的场景剪辑在一起，从而形成一部展示苏维埃政权城市生活和电影眼睛巨大力量的纪实影片。</p><p>电影眼睛理论：</p><ol><li>摄影机是人眼不能所比拟的电影眼睛。</li><li>电影工作和要记录现实生活，出其不意的捕捉现实生活中的细节。</li><li>零散的素材可以通过剪辑表现出一定的主题和意义。</li></ol><h3 id="三、爱森斯坦"><a href="#三、爱森斯坦" class="headerlink" title="三、爱森斯坦"></a>三、爱森斯坦</h3><p>库里肖夫的土地，继承并发展了老师对电影镜头组接的研究，并指出</p><ul><li>镜头之间的冲突会产生最大的张力。</li><li>任意两个片段并列在一起必然结合为一个新的概念，即 “镜头 A + 镜头 B = 新的意义 C”。</li></ul><p>1925 年《战舰波将金号》</p><p>观念：</p><p>通过电影画面的剪接能够形成丰富的影像元素，并具有强烈的理性隐喻。</p><p>《辛德勒的名单》在这部电影的结尾手工染色的红旗🚩得到启发，红色衣服的小女孩。</p><h3 id="四、普多夫金"><a href="#四、普多夫金" class="headerlink" title="四、普多夫金"></a>四、普多夫金</h3><p>电影镜头之间的组接是产生意义叠加的手段，每一个镜头就像是建筑物的每一块砖头，整合起来就能够构成一个有机整体。</p><p>即 “镜头 A + 镜头 B”组合生成的是 “镜头 AB” 意义的加成。</p><p>蒙太奇是要为电影叙事服务的，并将其分为</p><ol><li>“平行蒙太奇” </li><li>“对比蒙太奇”</li><li>“隐喻蒙太奇” </li><li>“交叉蒙太奇”</li><li>“复现蒙太奇” </li></ol><p>五种类型；并强调蒙太奇不仅能够表现戏剧冲突，而且具有抒情的特性，从而拓展了蒙太奇对电影主题的表现。</p><p>高尔基的小说改编的电影《母亲》鉴赏。</p><h1 id="意大利新现实主义电影运动"><a href="#意大利新现实主义电影运动" class="headerlink" title="意大利新现实主义电影运动"></a>意大利新现实主义电影运动</h1><p>20世纪四五十年代，意大利新现实主义电影是第二次世界大战结束后最重要的电影现象。作为继欧洲先锋派电影运动之后，世界电影史上第二次大规模的电影运动，意大利新现实主义电影运动在多维度多层次都构成了新的电影现象与电影文化 。</p><p>当时的意大利电影人有感于二战后严峻的社会现实，就拍摄了一批具有进步意义的纪实影片。电影创作者们将摄影机搬到城市的大街小巷。以贫穷、失业、犯罪等社会问题为切入点，将普通人的生活呈现在大银幕上，反映战争带给人们的伤害，从而表达反法西斯战争的主题。</p><p>从 1945 年到 50 年代奠定了 “新现实主义电影” 的创作风格，影响深远。</p><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><h3 id="一、得益于意大利政府的支持"><a href="#一、得益于意大利政府的支持" class="headerlink" title="一、得益于意大利政府的支持"></a>一、得益于意大利政府的支持</h3><p>为了与好莱坞电影相抗衡，抢占本土市场，建立意大利的民族电影工业，也是为了发挥电影的意识形态宣传功能。</p><p>1934 年创办了威尼斯电影节。</p><p>1937 年建立了罗马电影城，不仅是世界上最大的电影制片厂之一，而且至今还在意大利电影的发展中发挥着重要作用。</p><p>第二次世界大战之前，意大利已经发展成为欧洲的电影大国。</p><h3 id="二、受到二战期间现实主义创作的影响"><a href="#二、受到二战期间现实主义创作的影响" class="headerlink" title="二、受到二战期间现实主义创作的影响"></a>二、受到二战期间现实主义创作的影响</h3><ol><li><p>纪实风格的盛行。</p></li><li><p>电影的叙事，拍摄技巧日趋成熟。</p><p>意大利电影人提出 “把摄影机扛到大街上去” 的口号，以纪实性的手法进行电影拍摄。</p></li></ol><p>《罗马十一时》</p><p>《偷自行车的人》</p><p>“意大利新现实主义电影“ 的镜头语言特点也比较突出，其普遍采用长镜头作为表现真实空间的一种手段，同时几乎每个长镜头都能够成为相对完整的一段。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>实景拍摄能够实现一种电影化的真实空间表现，同时也避免了舞台观念的戏剧用光。采用非职业演员的做法既是对明星制的否定，也更为突出了电影的真实性。</p><p>还惯以去戏剧化的结构进行叙事，即不使用倒叙闪回等复杂的叙事手法，只是按照自然的时间顺序展开故事。从而形成情节松散，结局开放的特点。</p><p>还有方言的使用。例如 CIAO 有很多意思，在《我的天才女友》剧中，经常用到，意大利语，有是你好或者再见的意思。</p><h2 id="代表人物"><a href="#代表人物" class="headerlink" title="代表人物"></a>代表人物</h2><p>三位大师</p><ol><li>罗西里尼</li><li>德·西卡</li><li>维斯康蒂</li></ol><h3 id="罗西里尼"><a href="#罗西里尼" class="headerlink" title="罗西里尼"></a>罗西里尼</h3><p>通常认为 1945 年拍摄的影片《罗马，不设防的城市》，是 “意大利新现实主义电影” 的开山之作，也是罗西里尼 “战争三部曲” 的第一部。</p><p>另外两部是 1946 年的《战火》（被称为欧洲版的《公民凯恩》）1938 年的《德意志零年》</p><p>描述的二战时期，意大利地下反抗组织和法西斯斗争的故事。</p><p>从《罗马，不设防的城市》开始，“意大利新现实主义电影运动” 就开始形成比较明确的纪实风格与现实主义特点，以及精妙的电影叙事技巧与英雄神话结合的创作思路。</p><h3 id="德·西卡"><a href="#德·西卡" class="headerlink" title="德·西卡"></a>德·西卡</h3><p>1948 年拍摄的电影《偷自行车的人》是 “意大利新现实主义电影” 的经典之作，也是世界电影史上<strong><a href="https://kknews.cc/entertainment/jv6jyby.html" target="_blank" rel="noopener">十大不朽影片之一</a></strong>，该片集中代表了新现实主义电影的美学特征。</p><p>也深刻影响了我国第六代电影导演王小帅的创作《十七岁的单车》</p><p>《孩子们注视着我们》、《擦鞋童》 、《温别尔托·D》等。</p><h3 id="维斯康蒂"><a href="#维斯康蒂" class="headerlink" title="维斯康蒂"></a>维斯康蒂</h3><p>1942 年编剧并导演的电影处女作《沉沦》，而被称为新现实主义之父。《沉沦》改编自詹姆斯凯恩斯的侦探小说《邮差只按两次铃》，影片通过对社会中下层百姓的关注和对意大利贫苦生活的展示，成为意大利新现实主义电影运动蓬勃开展的前奏。</p><p>1948 年编导的《大地在波动》。</p><p>《大地在波动》是 “意大利新现实主义电影运动” 的重要代表作品，维斯康蒂也正是凭借这部影片，成为与罗西里尼和德·西卡齐名的 “意大利新现实主义电影” 的三位大师之一。</p><h3 id="德·桑蒂斯"><a href="#德·桑蒂斯" class="headerlink" title="德·桑蒂斯"></a>德·桑蒂斯</h3><p>《罗马十一时》、《橄榄树下无和平》</p><h2 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h2><p>“意大利新现实主义电影运动” 的出现与发展，首先是建立在作为当时时代任务的基础之上，因此当战争逐渐远去，社会主要矛盾随之转移、变化后，即 “意大利新现实主义电影运动” 进入 20 世纪 50 年代，便开始逐渐走向衰落。</p><p>另一个原因是其美学基础在时代变革语境下的变化。客观而言，意大利电影的美学基础，并不是新现实主义的朴素风格和严肃，恰恰相反其美学基础是深受意大利即兴喜剧和歌剧影响的电影，宏大浮夸的史诗巨片以及庸俗的电影情节剧等。</p><p>“意大利新现实主义电影运动” 的影响力不容小觑，尤其是作为电影纪实美学的成功典范，“意大利新现实主义电影” 彰显了电影作为大众传播媒介的使命和意义。</p><h1 id="法国新浪潮电影运动"><a href="#法国新浪潮电影运动" class="headerlink" title="法国新浪潮电影运动"></a>法国新浪潮电影运动</h1><h2 id="概说-3"><a href="#概说-3" class="headerlink" title="概说"></a>概说</h2><p>是世界电影史上继 20 世纪 20 年代的欧洲先锋派电影运动，40 年代的意大利新现实主义电影运动之后，第三大规模的电影运动。</p><p>20 世纪 50 年代末至 60 年代初，在法国突然涌现出由一些不知名的年轻人竞相拍摄电影的现象，人们将其称为 “法国新浪潮电影运动”。</p><p>深受意大利新现实主义电影纪实风格的影响，尤其是对社会现实和对普通人的关注等，作为第二次世界大战之后全世界规模最大，影响最深的电影运动。法国新浪潮电影运动在短短几年的时间里，在思潮崛起的法国掀起了汹涌澎湃的电影浪潮，并形成了三个影响深远的创作团体。</p><p>第一个团体：</p><p>是以《电影手册》杂志为阵地，由资深影评人领衔的 “《电影手册》” 派。</p><p> 第二个团体：</p><p>是居住在巴黎塞纳河左岸的职业电影导演，以及一些其他领域的文艺工作者转向拍摄电影的 “左岸派”。</p><p>第三个团体：<br>是以直接记录手法为基本特征进行电影创作的 “真实电影派”。</p><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>（一）战争的影响和好莱坞电影的冲击</p><p>第二次世界大战结束后，战争的破坏和好莱坞的大量倾销，使法国电影深入重重危机之中。面对这样的状况，同时为了对抗好莱坞电影，法国电影人提出发扬 “优质电影传统” 的口号。</p><p>一方面将大量的名著改编为电影，另一方面讲究高成本制作，在电影中强调布景的华丽和陈设的精美，同时推崇明星制。这样拍摄出来的电影，虽然在一定程度上挽救了濒临崩溃的法国电影业，但是僵化的创作模式也使电影丧失了原创价值。以及法国诗意现实主义所特有的清新写实传统。 </p><p>（二）西方人文主义思潮的蔓延</p><p>（三）“法国电影资料馆” 对 “新浪潮电影运动” 的出现起到了决定性的作用</p><p>1936 年成立的法国电影资料馆。</p><p>再次讲解《罗生门》。</p><p><strong>罗生门是日本京都罗城的城门，后来通常被借指人世与地狱之界门，事实与假象之别。</strong></p><p><strong>我甚至听说过住在罗生门这儿的鬼，因为害怕人类的凶残而逃走</strong>。——《罗生门》电影</p><p>背景很重要，《罗生门》是日本作家芥川龙之介1915年创作的短篇小说，情节取材于日本古典故事集《今昔物语》<sup>百度百科</sup>。那时的日本，资本主义高速蓬勃发展，同时又是一个天灾人祸的乱世。社会动荡，经济萧条，民不聊生，处于京都的罗生门附近都已经是格外的荒凉<sup>来自知乎</sup>。</p><p>你让一个极度贫穷的人，去遵守道德，以及触及了人的利益时，你让他去维持本性，这是很难的。</p><p>已经看完罗生门，其实就是一故事，经由了三个人讲述，每个人都美化了自己的行为，最后一个人讲出的事情的真正过程。人心是这样，尤其是在所谓的鬼附身，由死人讲出的话，更是荒唐。和尚代表着一种圣母的存在吧，开始就像太宰治一样，对人充满了失望，太宰治失望的是自己，和尚失望的是他人。就是摆烂，不做行动，懦弱，但怀着一颗 “善良” 的心。</p><p>倒数第二场镜头，樵夫那笑容，有点诡异，我觉得应该是后面会把这小孩给卖了，和卖匕首一样。</p><p>最后一个镜头是拍到了罗生门那块牌匾，点个电影名字吧。</p><h2 id="电影手册派"><a href="#电影手册派" class="headerlink" title="电影手册派"></a>电影手册派</h2><p>是法国新浪潮电影运动中，最重要的一个团体。其代表人物有阿斯特吕克、巴赞、特吕弗、戈达尔等。</p><h3 id="阿斯特吕克：“摄影机——自来水笔”"><a href="#阿斯特吕克：“摄影机——自来水笔”" class="headerlink" title="阿斯特吕克：“摄影机——自来水笔”"></a>阿斯特吕克：“摄影机——自来水笔”</h3><p>1948 年第 144 期的《法国银幕》杂志上，发表了《新先锋派的诞生：摄影机——自来水笔》一文，提出摄影机——自来水笔的观点。</p><p>指出电影已经成为一种拥有自己的语言、可以自由表达思想情感的工具；正如作家用笔写作一样，电影导演可以用摄影机 “写作” 并表达个人意念。</p><p>“摄影机——自来水笔” 成为了 “法国新浪潮电影运动” 的理论先驱。</p><p>我的补充（<strong>源自《电影批评》</strong>）：</p><p>法国著名的电影理论家、当代电影理论的奠基人克里斯蒂安·麦茨精当的论断：并非由于电影是一种语言，它才讲述了如此精彩的故事；而是由于它讲述了如此精彩的故事，才使自己成为了一种语言。</p><p>意大利著名电影导演、理论家帕索里尼在他的电影论文《诗的电影》一文中指出：电影本质上是一种新语言。他认为电影使用的是某种 “表情符号系统”，这一副好系统先于语法而存在，因为 “世界上没有一部形象词典”。以为电影导演必须首先创造他所需的词汇，即选取他的拍摄对象，将其创造为自己的形象符号，尔后方才进入美的创造。</p><p>电影语言不通于自然语言。</p><ol><li>自然语言是一种任意的、无理据的、约定俗成的符号系统，而电影语言是一种有理据的 “短路” 符号，其能🈯️约等于其所指。</li><li>电影语言没有最小单位。即使最单纯的影像，也有内涵表意的现象发生。</li><li>由于 “世界上没有一部形象词典”，电影语言始终只是一种语言，而非语言系统。因此，电影叙事更多地依赖着诸多成规和惯例。</li></ol><h3 id="巴赞：“电影是现实的渐近线”"><a href="#巴赞：“电影是现实的渐近线”" class="headerlink" title="巴赞：“电影是现实的渐近线”"></a>巴赞：“电影是现实的渐近线”</h3><p>1951 年法国著名的《电影手册》杂志创办，巴赞在第一期杂志上刊文提出，电影是现实的渐近线的观点，并指出杂志社要以挖掘和扶持电影作者为己任。这些使得《电影手册》很快声名鹊起。巴赞也成为了杂志的核心人而无，还被誉为 “法国新浪潮电影运动” 的精神之父。</p><h3 id="特吕弗与-“作者论”"><a href="#特吕弗与-“作者论”" class="headerlink" title="特吕弗与 “作者论”"></a>特吕弗与 “作者论”</h3><p>时任《电影手册》杂志编辑的特吕弗发表了《法国电影的某种倾向》一文，他在文章中。</p><ul><li>批判和抨击当时的法国电影制度。</li><li>首次提出 “作者论”，指出电影的真正作者不应该是编剧，而应该是在一系列电影中坚持题材和风格一贯性的导演，即导演应该是自己作品的作者。</li></ul><p>1958 年，特吕弗拍摄了短片《顽童》，该片和电影《通往绞刑架的电梯》《漂亮的吉尔塞》 等都成为了法国新浪潮电影运动的先声之作。</p><p>1959 年特吕弗拍摄的影片《四百下》获得戛纳国际电影节的最佳导演奖，为法国电影赢得了荣誉，也成为 “新浪潮电影运动” 的标志性作品。</p><h3 id="戈达尔"><a href="#戈达尔" class="headerlink" title="戈达尔"></a>戈达尔</h3><p>在 1960 年拍摄的影片《筋疲力尽》可以说是石破天惊。</p><p>这部影片从 20 世纪 40 年代的美国黑帮片中吸取灵感，从内容到形式都毫无规律可循，随意的拍摄方式完全无视好莱坞电影的经典模式，然而却开启了一个更为自由和个人化的电影创作路径。尤其是戈达尔的电影美学观念，还为场面调度与蒙太奇学派的对立，找到了一条新的出路。以至于法国电影资料馆馆长朗格卢瓦都心悦诚服的认为电影史可分为戈达尔之前和戈达尔之后。</p><h2 id="左岸派"><a href="#左岸派" class="headerlink" title="左岸派"></a>左岸派</h2><p>在《电影手册》派创作繁荣的同时，当时生活在巴黎的另外一批电影艺术家，还拍摄出了多部与传统电影叙事技巧大相径庭的影片。由于这些人都居住在巴黎塞纳河的左岸，因而得名左岸派。</p><p>下面内容来自维基百科。</p><p>在<a href="https://zh.wikipedia.org/wiki/法國" target="_blank" rel="noopener">法国</a><a href="https://zh.wikipedia.org/wiki/巴黎" target="_blank" rel="noopener">巴黎</a>地区，<strong>左岸</strong>（法语：La Rive Gauche，法语发音：<a href="https://zh.wikipedia.org/wiki/Help:法語國際音標" target="_blank" rel="noopener">[la ʁiv ɡoʃ]</a>）指流经市区的<a href="https://zh.wikipedia.org/wiki/塞納河" target="_blank" rel="noopener">塞纳河</a>南岸地区，塞纳河北岸地区则称<a href="https://zh.wikipedia.org/wiki/右岸" target="_blank" rel="noopener">右岸</a>。“左岸”具有文化和<a href="https://zh.wikipedia.org/wiki/意识形态" target="_blank" rel="noopener">意识形态</a>意味，并衍生出<a href="https://zh.wikipedia.org/w/index.php?title=左岸公社&action=edit&redlink=1" target="_blank" rel="noopener">左岸公社</a>、<a href="https://zh.wikipedia.org/w/index.php?title=左岸文化&action=edit&redlink=1" target="_blank" rel="noopener">左岸文化</a>、<a href="https://zh.wikipedia.org/wiki/左岸咖啡" target="_blank" rel="noopener">左岸咖啡</a>等词汇，以及<a href="https://zh.wikipedia.org/wiki/房地产" target="_blank" rel="noopener">房地产</a><a href="https://zh.wikipedia.org/wiki/广告" target="_blank" rel="noopener">广告</a>中<strong>也常用左岸彰显文化品味</strong>。</p><p><strong>使用情况</strong></p><p>在<a href="https://zh.wikipedia.org/wiki/法国" target="_blank" rel="noopener">法国</a>，自东向西流动的<a href="https://zh.wikipedia.org/wiki/塞纳河" target="_blank" rel="noopener">塞纳河</a>穿过首都<a href="https://zh.wikipedia.org/wiki/巴黎" target="_blank" rel="noopener">巴黎</a>，将巴黎分隔为左右两边。塞纳河以北称为<a href="https://zh.wikipedia.org/wiki/右岸" target="_blank" rel="noopener">右岸</a>，有许多的<a href="https://zh.wikipedia.org/wiki/奢侈品" target="_blank" rel="noopener">精品店</a>及<a href="https://zh.wikipedia.org/wiki/酒店" target="_blank" rel="noopener">大宾馆</a>。在<a href="https://zh.wikipedia.org/wiki/塞纳河" target="_blank" rel="noopener">塞纳河</a>以南的部分称之为左岸。在这里有许多的<a href="https://zh.wikipedia.org/wiki/學院" target="_blank" rel="noopener">学院</a>及文化教育机构，以<a href="https://zh.wikipedia.org/wiki/年輕人" target="_blank" rel="noopener">年轻人</a>居多<a href="https://zh.wikipedia.org/wiki/消费" target="_blank" rel="noopener">消费</a>也较便宜。<a href="https://zh.wikipedia.org/wiki/拉丁区" target="_blank" rel="noopener">拉丁区</a>即是位于左岸。</p><p><a href="https://zh.wikipedia.org/wiki/File:Arrondissements_de_Paris.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://upload.wikimedia.org/wikipedia/commons/4/4c/Arrondissements_de_Paris.jpg" alt="img"></a></p><p>如图塞纳河南岸即为左岸</p><p>巴黎左岸包含了<a href="https://zh.wikipedia.org/wiki/巴黎区份" target="_blank" rel="noopener">巴黎的六个区</a>：</p><ul><li><a href="https://zh.wikipedia.org/wiki/巴黎第五区" target="_blank" rel="noopener">巴黎第五区</a>，万神殿区(quartier du Panthéon)</li><li><a href="https://zh.wikipedia.org/wiki/巴黎第六区" target="_blank" rel="noopener">巴黎第六区</a>，卢森堡区(Luxembourg)</li><li><a href="https://zh.wikipedia.org/wiki/巴黎第七區" target="_blank" rel="noopener">巴黎第七区</a>，波旁宫区(Palais Bourbon)</li><li><a href="https://zh.wikipedia.org/wiki/巴黎十三区" target="_blank" rel="noopener">巴黎第十三区</a>，戈博兰区(Gobelins)</li><li><a href="https://zh.wikipedia.org/wiki/巴黎十四区" target="_blank" rel="noopener">巴黎第十四区</a>，天文台区(l’Observatoire)</li><li><a href="https://zh.wikipedia.org/wiki/巴黎十五区" target="_blank" rel="noopener">巴黎第十五区</a>，沃吉哈赫区(Vaugirard)</li></ul><p>塞纳河畔，左岸的咖啡？</p><h3 id="”左岸派“-的出现"><a href="#”左岸派“-的出现" class="headerlink" title="”左岸派“ 的出现"></a>”左岸派“ 的出现</h3><p>代表人物有阿伦·雷乃、阿涅斯·瓦尔达、玛格丽特·杜拉斯等。其实左岸派并没有形成一个学派或是团体，他们只是有着长久的友谊，艺术趣味也比较相投，并且在创作上经常互相帮助的一群艺术家。</p><h3 id="代表人物-：阿仑·雷乃"><a href="#代表人物-：阿仑·雷乃" class="headerlink" title="代表人物 ：阿仑·雷乃"></a>代表人物 ：阿仑·雷乃</h3><p>1959 年《广岛之恋》与特吕弗的《四百下》同时出现在戛纳国际电影节上，虽然只是一部参展影片，但在当时的影响力却非常大。并成为法国新浪潮电影运动的重要代表作品，这不影片根据法国女作家玛格丽特·杜拉斯的同名小说改编。讲述一位法国女演员与日本建筑师之间的爱情故事。阿仑·雷乃在影片中没有正面描写战争的残酷，也摒弃了传统的线性叙事，而是将战争隐藏在爱情故事的背后，在剪辑上也是打破过去、现在、未来的时空界限，以无技巧闪回3的叙事结构淡化了故事的时间界限。</p><p>电影《广岛之恋》既具有创作者的独特风格，又带有浓厚的文学气息，被称为是 “西方电影史上从传统时期进入现代时期的一部划时代的作品”。</p><p>阿仑·雷乃尝试以无连贯性的情节和意识流的时空跳跃，作为电影表达自我观念的方式。并在 1961 年拍摄出影片《去年在马里昂巴德》，这部充满文学味道的电影，依然是通过拼贴的电影语言，探索真实与虚幻之间的关系，并试图从潜意识层面表现主人公的行为举止。同时，这部现代主义的电影文本还由于电影语言过于晦涩，也被后人不断的解读。</p><h3 id="“左岸派”-的特点"><a href="#“左岸派”-的特点" class="headerlink" title="“左岸派” 的特点"></a>“左岸派” 的特点</h3><p>“法国新浪潮电影运动” 的另一个创作团队，“左岸派” 所创作的电影往往被称作 “作家电影”。</p><p>具体来说，有以下几方面的特点：</p><ol><li>左岸派电影创作者在进行电影剧本选择时，不主张改编文学作品，而更愿意拍摄专门为电影撰写的剧本。</li><li>由于文学作者的身份使然，“左岸派” 导演更重视对电影中人物内心世界的揣摩与表现，而轻视对外部环境的描写。</li><li>不同于 “《电影手册》派” 轻视电影拍摄技巧的半即兴式创作，“左岸派” 在电影拍摄时非常讲究相关首发与技巧的运用。</li></ol><h2 id="”真实电影“"><a href="#”真实电影“" class="headerlink" title="”真实电影“"></a>”真实电影“</h2><p>除了上述两种派系，还出现了以现实主义题材见长的真实电影。</p><p>“真实电影” 作为一种源于纪录片写实主义的电影类型，在 “法国新浪潮电影运动” 时期，秉承了 “苏联蒙太奇学派” 代表人物维尔托夫的 “电影眼睛理论”，主张摄影机是记录社会生活的眼睛，要摒弃拍摄者的主观认知，从而让表现世界的真实本质。 </p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>“真实电影” 继承了 “《电影手册》 派” 即兴创作，周期短、投入低、使用非职业演员等特点。</p><p>不同的是，“真实电影” 对现实主义题材的表现要比 “《电影手册》派” 更为彻底。</p><p>“真实电影” 还为故事片创作提供了最大限度保持真实性的参考。</p><p>如电影《四百下》中对街景的处理，就借鉴了真实电影的创作手法。</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>“法国新浪潮电影运动” 在 1961-1962 年间达到辉煌之后便迅速衰落。</p><p>1962 年底《电影手册》杂志还出版了 “新浪潮专号”，对 “法国新浪潮电影” 进行总结。</p><h3 id="法国新浪潮电影特点"><a href="#法国新浪潮电影特点" class="headerlink" title="法国新浪潮电影特点"></a>法国新浪潮电影特点</h3><p><strong>拍摄方面</strong></p><p>以外景为主，很少在摄影棚内拍摄；外景也多为实景，以凸显电影的真实感。</p><p>推崇巴赞的 “摄影机本体论”，即注重电影的照相功能，在实景拍摄中也是利用的自然光、进行肩扛跟拍这种与新闻片拍摄类似的手法。</p><p><strong>电影剪辑方面</strong></p><p>以镜头直接切换和跳接的方式，取代了原本复杂的快速剪辑，从而淡化了蒙太奇的时空转换功能，有效控制了电影的长度和节奏。</p><p><strong>电影产业方面</strong></p><p>致力于推动 “导演中心制” 的形成，从而促成新一代法国电影人的崛起。</p><h3 id="法国新浪潮电影运动的影响"><a href="#法国新浪潮电影运动的影响" class="headerlink" title="法国新浪潮电影运动的影响"></a>法国新浪潮电影运动的影响</h3><p><strong>对欧洲的影响</strong></p><p>在欧洲，“新现实主义” 的诞生地意大利，在 “法国新浪潮电影运动” 的鼓舞下，迅速崛起了一批青年导演。如贝托鲁奇、帕索里尼等。</p><p>波兰、捷克、匈牙利等东欧国家也受到影响，电影制作风格开始比之前更为简化。</p><p>处于战后重建阶段的德国也深受其影响，一批德国青年导演在1962 年发表了著名 “奥伯豪宣言”，开始了 “德国新电影运动”。</p><p><strong>对亚洲的影响</strong></p><p>首先受到冲击的是日本。在其影响下，以大岛渚和吉田重为代表的日本电影人，先是在 “松竹电影公司” 内部掀起了一场革命，随即扩展到整个日本的电影业。</p><p>大岛渚在 1960 年拍摄的影片《日本之夜与雾》 直接套用了法国电影《夜雨雾》的名字。</p><p>吉田喜重（吉田喜重，又名吉田喜重）的代表作品《不务正业的人》也是完全借鉴戈达尔《精疲力尽》的电影语言，以表现迷失中的日本青年。</p><p>同时，我过第五代、第六代电影导演的创作，也在一定程度上受到法国新浪潮电影运动的影响。</p><h1 id="日本东方美学电影"><a href="#日本东方美学电影" class="headerlink" title="日本东方美学电影"></a>日本东方美学电影</h1><h2 id="日本电影的发展"><a href="#日本电影的发展" class="headerlink" title="日本电影的发展"></a>日本电影的发展</h2><p>日本电影作为亚洲电影重要切独特的一支，以别具风格的民族美学特征和对电影艺术多样化的贡献，在世界影坛中有着不可忽视的地位。</p><h3 id="一、早期日本电影"><a href="#一、早期日本电影" class="headerlink" title="一、早期日本电影"></a>一、早期日本电影</h3><p>早在 19 世纪末开始独立拍摄电影时，日本就将 “电影” 改名为 “映画“，从而使电影一开始就具有明确的民族文化特征。</p><p>一定程度而言，日本电影并没有真正经历无声片时代。因为伴随着电影在日本出现的，还有一种叫做辩士的职业。</p><p>辩士：</p><p>指电影的旁白者，其主要的工作是朗诵电影的对白、讲解电影故事；有时甚至还会为了配合某位 “辩士” 的讲解而调整电影的放映。</p><p>“辩士” 作为世界电影史上的一种独特现象，是深受日本戏剧影响的结果。</p><p>日本传统的 “能乐”、“歌舞伎”、“偶人净琉璃” 等，其表演和演唱分别都由专人担任，同时还有专人负责评述剧情，即视觉和声音的表演分工明确，这种手法被借用到电影中，就出现了辩士。</p><p>默片与 “辩士” 的组合，其实就是日本戏剧 “声画分离” 模式的延伸，因此日本观众对此十分熟悉切适应。 这种艺术形式，本质上暗合了布莱希特的间离派理论。</p><p>我想起了一部电影《默片解说员》，算是喜剧吧。</p><h3 id="二、有声片时代的日本电影"><a href="#二、有声片时代的日本电影" class="headerlink" title="二、有声片时代的日本电影"></a>二、有声片时代的日本电影</h3><p>20 世纪 30 年代，有声片的出现使日本电影呈现出全新的面貌：</p><p>（一）“辩士” 遭遇到了淘汰</p><p>（二）日本出现了有声片的创作高潮</p><p>松竹、日活、东宝等电影公司都争先恐后的创作有声片。沟口健二、小津安二郎等在无声片时代就具有一定影响力的导演，也都积极投入有声片的创作。还有后来的<strong>黑泽明</strong>也在 40 年代初进入了日本影坛。在第二次世界大战之前的几年，日本已经发展成为了世界电影大国。第二次世界大战结束的最初几年，作为战败国的日本被美国控制，直到 1951 年美国从日本撤离后，日本电影才又开始重新开始独立发展。</p><h3 id="三、二战后的日本电影"><a href="#三、二战后的日本电影" class="headerlink" title="三、二战后的日本电影"></a>三、二战后的日本电影</h3><ul><li>”松竹“ ”日活“ ”东宝“ 等老牌电影公司努力打造自身的类型片优势，并采用好莱坞类似的工业流水线生产。</li><li>日本影坛也迎来了大师辈出的 “黄金时代”。</li></ul><p>不仅有黑泽明、市川昆等老牌电影导演继续活跃在影坛，他们勇于尝试新技术，寻找电影表现的突破，甚至还为了寻求资金将目光投向国外，邀请外国制片商投资。而且还有今村昌平、大岛渚、新藤兼人、筱田正浩等二战期间涌现出的新导演。他们也以多样化的创作丰富了日本电影的艺术表现。</p><h3 id="四、类型片的创作"><a href="#四、类型片的创作" class="headerlink" title="四、类型片的创作"></a>四、类型片的创作</h3><p>战后的日本经济在美国扶植下逐渐恢复，科技进步也非常迅猛，这就给电影的发展带来了良好的契机。于是，在现代特技效果流行的背景下，日本出现了以视觉奇观为核心的商业动作大片创作热潮。</p><p>东宝：1954 年 《哥斯拉》（教程上这里应该有出入）</p><p><strong>哥斯拉</strong>（<strong>ゴジラ</strong> <strong><em>Gojira</em></strong> <a href="https://zh.wikipedia.org/wiki/日語書寫系統" target="_blank" rel="noopener">?</a>，英語：<strong>Godzilla</strong>），為<a href="https://zh.wikipedia.org/wiki/日本" target="_blank" rel="noopener">日本</a><a href="https://zh.wikipedia.org/wiki/東寶株式會社" target="_blank" rel="noopener">東寶株式會社</a>製作的怪獸，日本影史上最悠久，世界影史上公認最經典最有名的怪獸角色。</p><p>最早的哥斯拉是一部受到<a href="https://zh.wikipedia.org/wiki/美國" target="_blank" rel="noopener">美國</a>《<a href="https://zh.wikipedia.org/wiki/金刚_(1933年电影)" target="_blank" rel="noopener">金剛</a>》影響的怪獸電影，描述受到<a href="https://zh.wikipedia.org/wiki/輻射" target="_blank" rel="noopener">輻射</a>污染的海域中出現一隻身高達50公尺的怪獸哥吉拉。哥吉拉後來成為日本類似<a href="https://zh.wikipedia.org/wiki/電影" target="_blank" rel="noopener">電影</a>、<a href="https://zh.wikipedia.org/wiki/動畫" target="_blank" rel="noopener">動畫</a>、<a href="https://zh.wikipedia.org/wiki/漫畫" target="_blank" rel="noopener">漫畫</a>的怪獸原型，對於日本動漫作品的怪獸形象有非常深遠的影響。</p><p>怪兽片从此也成为日本最具特色的电影类型。</p><p>老牌的电影公司还在不断寻求能够留住观众的电影类型。</p><p>如松竹公司就拍摄了寅次郎的故事系列电影，并从 1969 年到 1995 年间连续拍摄了 48 部，创造了世界电影史上，由同一个演员主演系列电影的数量之最。</p><p>此外，那些富有神秘色彩的日式惊悚片，想象力丰富且制作精良的动画片等，也都逐渐成为了极具日本特色的电影类型片。</p><p>《你的名字》的鉴赏</p><h2 id="小津安二郎"><a href="#小津安二郎" class="headerlink" title="小津安二郎"></a>小津安二郎</h2><p>日本电影人物众多，创作风格也各有千秋，而在国际上影响力最大的，是三位殿堂级的人物。</p><ol><li>古典大师<strong>小津安二郎</strong></li><li>现代主义巨匠<strong>黑泽明</strong></li><li>后现代拼贴高手<strong>北野武</strong></li></ol><p>小津安二郎</p><p>最能代表日本电影民族特色的导演；</p><p>宁静、悠远的美学风格；</p><p>被视为真正的古典主义。</p><h3 id="叙事特点"><a href="#叙事特点" class="headerlink" title="叙事特点"></a>叙事特点</h3><p>大多聚聚焦普通日本人的日常生活状态，尤其擅长对家庭成员之间的关系进行细致入微的描写，故事常以传统日本家庭在现代化进程中受到的冲击为主要矛盾。</p><p>第一种，表现父母与儿女之间的关系。</p><p>大多是描写儿女婚姻问题所引发的情感波澜，而在实质上反映日本传统价值观中的亲情和责任问题。</p><p>代表作品如</p><ul><li><p>《晚春》</p></li><li><p>《彼岸花》（推荐）</p></li><li><p>《麦秋》</p></li><li><p>《秋刀鱼之味》（推荐）</p></li></ul><p>第二种，是表现就在社会转型过程中，随着传统大家庭的解体，儿女对父母绝对服从观念的淡化所引发的关系变化，于是年轻人变得以自我为中心，年迈父母常常陷入孤独和失落，因此影片大多充满淡淡的忧伤和凄凉。</p><p>代表作品</p><p>《东京物语》</p><p>《浮草》</p><p>《小早川家之秋》</p><p>第三种，是表现夫妻之间的情感矛盾。</p><p>尽管影片中的夫妻由于各种原因产生不和，但都以彼此原谅、婚姻和家庭也都得到维护为结局，即完全符合东方文化中 ”相濡以沫” 的婚恋观。</p><p>代表作品如</p><p>《早春》</p><p>《茶泡饭之味》等</p><p>这些影片大都以顺序的方式叙事，很少有闪回等时空变化，而旨在以最自然的方式将故事娓娓道来；同时台词也极其散淡平实，达到了一种 “言有尽而意无穷” 的效果。</p><p>无论是战前还是战后，小津安二郎的电影都远离政治风云，只是通过对现实生活和市井人物的细腻描绘，即为质朴的表现出日本社会在 20 世纪的变化。尤其是传统观念与现代观念的碰撞与融合。</p><p>《东京物语》鉴赏</p><h3 id="视听语言特点"><a href="#视听语言特点" class="headerlink" title="视听语言特点"></a>视听语言特点</h3><p>首先，他惯用于使用低角度的机位，以 30 度的左右的仰视角度拍摄人物。因为这个角度既符合日本席地而坐的习惯，也体现出日本民族讲究礼仪的谦恭态度。</p><p>其次，小津安二郎偏爱使用静止的长镜头，拒绝戏剧化的蒙太奇和复杂运动镜头。</p><p>在拍摄人物对话时，多以正面为主，并直接切换，不刻意制造剪辑点，一切以平实为基调。</p><p>场景多为室内，即传统的日本民居，并巧妙利用室内门窗或家具的线条来展示电影画面构图的美感。</p><p>《秋刀鱼之味》鉴赏。</p><p>作为古典主义大师，其电影的最大价值就是对日本传统文化内涵的准确表达，而非流于表面的符号堆砌。可以说，是小津安二郎让日本电影发出了最民族的声音。</p><h2 id="黑泽明"><a href="#黑泽明" class="headerlink" title="黑泽明"></a>黑泽明</h2><p>黑泽明的电影具有较强的现代性，同时电影的形式和内容，也都更具创新和国际视野。甚至开创了世界影坛的风气之先。</p><h3 id="题材特点"><a href="#题材特点" class="headerlink" title="题材特点"></a>题材特点</h3><p>在电影选材方面，黑泽明涉猎较广，从古装时代剧到社会问题剧，甚至先锋实验性质的电影都有创作。</p><p>1990 年，80 岁的黑泽明获得了第 62 届奥斯卡终身成就奖。成为第一位获得该奖项的亚洲电影人。也是在这一年，黑泽明自编自导了一部极具先锋实验性的影片《梦》。</p><p>该片以</p><ul><li><p>太阳雨</p></li><li><p>桃园</p></li><li><p>风雪</p></li><li><p>隧道</p></li><li><p>乌鸦</p></li><li><p>红色富士山</p></li><li><p>垂泪的魔鬼</p></li><li><p>水车之村</p></li></ul><p>八个梦贯穿了几乎人类社会的所有主题，同时黑泽明还对不同梦境中的不同场景，配合了不同的色彩。</p><h3 id="视听语言特点-1"><a href="#视听语言特点-1" class="headerlink" title="视听语言特点"></a>视听语言特点</h3><ul><li>擅长拍摄动作场面和宏大场景。</li><li>喜欢用多机位以营造单一机位难以实现的全方位视觉感受。（如电影罗生门的开头，樵夫进入森鲮的段落，就是多个机位的拍摄）</li></ul><p>黑泽明的电影时而呈现出强烈的运动感，时而又尝试极具抽象意味的长镜头，种种变化使其影响风格与传统的日本电影有了很大的区别。黑泽明对电影视听语言的探索超越了国界，启发了全世界许多导演的灵感。</p><p>如星球大战系列电影就深受其影响。</p><h3 id="艺术表现特点"><a href="#艺术表现特点" class="headerlink" title="艺术表现特点"></a>艺术表现特点</h3><p>黑泽明电影虽然与日本歌舞伎的叙事传统相距较远，但却更符合西方戏剧的精神内涵：表现个人对命运的挣扎与反抗。</p><p>黑泽明的多部电影都改编自西方名著，如</p><ul><li>莎士比亚的《麦克白》-&gt;《蜘蛛巢城》</li><li>《李尔王》-&gt;《乱》</li></ul><p>黑泽明的电影还渗透着西方的 “现代性” 思想。</p><p>电影《罗生门》就通过几位当事人对同一件事情的不同叙述，表现出人对世界认识的相对性及所谓真相的不可知。</p><p>这种结论与伯格曼，费里尼等欧洲现代主义电影作者所传达的理念有很多相似之处。</p><p>黑泽明还拍摄了多部反映社会现实问题的影片。</p><p>如《生之欲》《八月狂想曲》等。</p><p>这些影片具有高度概念化的抽象意味，除了少数流露出悲观的情绪之外，大多是以慈悲和宽容的胜利告终。这种价值观具有一定的国际视野，也是黑泽明被世界影坛推崇的原因之一。</p><h3 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h3><p>黑泽明电影虽然与纯粹的日本电影有所不同，但又绝不是对西方电影的简单模仿。</p><h2 id="北野武"><a href="#北野武" class="headerlink" title="北野武"></a>北野武</h2><p>20 世纪 90 年代，北野武的横空登场震动了平静许久的日本影坛。其特立独行的影响风格，别具一格的剪辑手法，虽然让评论一时哑然，但都不得不认可他的才华与创造力。</p><p>《菊次郎的夏天》里面的坏大叔，就是北野武。</p><h3 id="题材特点-1"><a href="#题材特点-1" class="headerlink" title="题材特点"></a>题材特点</h3><ul><li>题材来源非常广泛。警匪片《凶暴的男人》《花火》黑帮片《奏鸣曲》《大佬》青春片《坏孩子的天空》古装片《座头市》等</li><li>在电影创作体现出一种自由和游戏的态度。《那年夏天，宁静的海》《玩偶》《菊次郎的夏天》《双面北野武》</li></ul><h3 id="视听语言特点-2"><a href="#视听语言特点-2" class="headerlink" title="视听语言特点"></a>视听语言特点</h3><p>多用蓝色作为多部电影的基调，以表现人物的特殊心理状态，并成为了他独特的个人标志。</p><p>北野武特别热衷于表现暴力，同时这种暴力又都是突如其来的发生，不带有任何美化和温情的处理；在处理打斗动作时，电影画面往往突然定格，以突出动作的震撼力。</p><p>北野武的电影镜头经常也是随心所欲的移动，跟随主人公漫无目的的闲逛。 </p><p>有时甚至还会在一系列的连续动作中突然切换到另一个画面。 </p><p>与此同时，绘画、文字、照片等也都经常随意出现在北野武电影画面中，被用来构成叙事。</p><h3 id="叙事特点-1"><a href="#叙事特点-1" class="headerlink" title="叙事特点"></a>叙事特点</h3><ul><li><p>在北野武的电影中看不到日本传统歌舞伎表演的影子，但是随处可见驾轻就熟的黑色幽默与尖锐深刻的讽刺。</p></li><li><p>北野武电影中的人物往往是孤独与茫然的，故事中也很少有人道主义的精神胜利，主人公看待世界的眼也常常是冷酷、悲观的。如《菊次郎的夏天》</p></li><li><p>北野武的电影还有着明确的当代日本文化体现。</p></li></ul><p>虽然游戏式的拼贴掩盖了那些外在的日本电影特征，但对情感的收敛表达，对死亡的迷恋，以及日本传统文化符号，深受日本漫画影响的电影桥段等，都能够让观众联想到混杂了多种文化基因的当代日本文化。</p><h2 id="日本电影美学：矛盾性"><a href="#日本电影美学：矛盾性" class="headerlink" title="日本电影美学：矛盾性"></a>日本电影美学：矛盾性</h2><h3 id="矛盾性"><a href="#矛盾性" class="headerlink" title="矛盾性"></a>矛盾性</h3><p><strong>特点：“唯美与残酷” 的相伴而生</strong>。</p><p>这种矛盾既体现在单独的影像文本中，也体现在导演的个人创作中。</p><p>如女性电影大师沟口健二的多部影片</p><p>《西鹤一代女》《雨月物语》《近松物语》总是将美好的主人公残忍的推向不幸，而似乎只有在施虐和折磨中，才能凸显出主人公的外表美和人性美。</p><p>日本受自然条件等影响，地震等灾害频发，于是那些美好的事物很容易在瞬间被毁灭。正如日本电影中频繁出现的樱花的象征意义。瞬间的绚烂和霎那的凋谢。</p><p>《你的名字》鉴赏</p><p>也正是这种绝望之美，使日本电影中的唯美总是与残酷相伴，尤其是在爱情片中，电影创作者往往在用尽笔墨刻画男女主人公的情感之后，总会有突如其来的离别或是死亡，这一模式在电影中多次出现。</p><p>如《伊豆的舞女》《雪国》《失乐园》等。</p><p><strong>特点：“含蓄与直露” 并存的情感表达</strong>。</p><p>日本导演总是通过对男女主人公表情神态的准确把握，巧妙的通过镜头设计来含蓄的传达人物情感。与含蓄的情感表达相对，日本电影并不忌讳对暴力的直接呈现，尤其是在武士题材的电影中，暴力元素已经深深扎根。如北野武的代表作《座头市》等。</p><p>与世界其他国家的电影相比，日本电影的抒情性非常强烈，十分重视自然景物在电影中的作用，如四季的更迭，气象的变化等都在电影中得到了充分的体现。</p><p>许多日本电影直接以自然景物或四时季节命名，如《浮草》《麦秋》《八月狂想》《那年夏天，宁静的海》《细雪》等。</p><p>与中国的古装片类似，日本电影还从本国文学作品文学和民族剧中吸收了很多素材，“古装时代剧” 作为日本一种长盛不衰的电影类型，其服装、道具、台词、表演等都具有浓重的民族文化特色。</p><h2 id="民族性"><a href="#民族性" class="headerlink" title="民族性"></a>民族性</h2><p>究其原因，虽然日本的生活方式已经相当西化，但日本人的行为举止却保留了很多传统特色，如鞠躬、点头、跪坐等；这些程式化的繁琐礼节深刻影响着日本电影在世界影坛的形象，并成为日本电影名族性的基本表现。</p><p>《战国英豪》《椿十三郎》</p><h1 id="香港电影新浪潮电影"><a href="#香港电影新浪潮电影" class="headerlink" title="香港电影新浪潮电影"></a>香港电影新浪潮电影</h1><h2 id="概说-4"><a href="#概说-4" class="headerlink" title="概说"></a>概说</h2><p>1896 年，“电影之父” 卢米埃尔兄弟派几名技师来远东地区放映电影并拍摄一些风光素材，第一站便到了香港。</p><p>随后，美国人在上海创办的亚细亚影戏公司也来到香港。1909 年拍摄的由香港那人梁少坡导演并主演的故事片《偷烧鸭》，开启了香港本土电影的制作历史，同时，也开启了“警匪片” 的制作历史。</p><p>1913 年出现了完全由香港人创作、香港公司出品的第一部影片《庄子试妻》是香港电影史的正式开端。</p><p>黎民伟编剧并主演，由黎北海主导。</p><p> 香港电影的各个时期</p><ul><li>三十年代——成长期</li><li>四十年代——沦陷期和复苏期</li><li>五、六十年代——繁荣期 </li></ul><p>出现了一批实力雄厚的电影制片机构：长城、凤凰、邵氏、中联、电懋等。</p><p> 代表性导演：朱石麟、李翰祥等以及一批艺术水准颇高的电影佳作。如</p><p>《一板之隔》《貂蝉》《江山美人》《故园春梦》 这些作品大多取材于历史，且常与戏曲等传统艺术形式相结合，体现出一种华丽精致的戏剧式风格。</p><p>四十年代作为亚洲四小龙的香港，经济空前繁荣，成为极具规模的现代商业都市，西方文化观念经由各种传播媒介，大量涌入香港人的视野，逐渐被香港大众，尤其是新一代香港人所接受。香江文化和西方文化的碰撞，触发了香港新浪潮运动。</p><h2 id="香港新浪潮运动"><a href="#香港新浪潮运动" class="headerlink" title="香港新浪潮运动"></a>香港新浪潮运动</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li><p><strong>一大批热爱电影的年轻人在国外接受了正规的电影教育</strong>。</p><p>就读伦敦电影学院的严浩，就读于美国德州大学奥斯丁分校电影专业的徐克，就读于南加州大学电影专业的方育平等，谭家明也曾于1975年被派往美国旧金山进修电影制作，他们把在海外学到的先进的电影理念和新颖的叙事技巧引入香港本土电影题材。创作出一批令人耳目一新的影片，开创了香港电影前所未有的新局面，这成为新浪潮电影运动强有力的思想支柱和人才保障。</p></li><li><p>电视机构对创作人才的锤炼</p><p>方育平、徐克、严浩、谭家明、许鞍华等曾在电视机构担任编导，一方面通过电视剧、电视电影等创作技巧，另一方面广泛而深入地了解香港当代社会的形态和心态，为新浪潮电影运动的到来作了艺术和题材上的准备。</p></li><li><p>电影杂志《电影双周刊》的摇旗呐喊，也是新浪潮电影运动得以兴起的重要推手。</p><p>该杂志，通过对年轻电影人及其作品的评介鼓励，促进了社会各界对新浪潮电影运动的关注和认同。 该杂志海创办了<strong>香港电影金像奖</strong>。第一届到第四届的最佳影片奖，全部由新浪潮电影运动的作品包揽。 </p><p>分别是《父子情》《投奔怒海》《半边人》《似水流年》，这对新浪潮电影运动的其他年轻导演，无疑是巨大的鼓舞 。</p></li></ol><p>在以上几个原因的推动下，香港新浪潮电影运动应运而生，并成为当代香港电影史上最重要、最具国际影响力的电影革新运动。</p><h2 id="代表人物及作品"><a href="#代表人物及作品" class="headerlink" title="代表人物及作品"></a>代表人物及作品</h2><h3 id="严浩"><a href="#严浩" class="headerlink" title="严浩"></a>严浩</h3><p>1978 年，“无线” 电视台的严浩和余允抗与电影导演陈欣健合组 “影力公司”，拍摄了被公认为 “新浪潮” 电影运动开山之作的《茄哩啡》。</p><p>茄哩啡是粤语俗是“跑龙套”，kelefe是广东话的说法。</p><p>小人物，误打误撞变大明星，喜剧方式呈现。</p><p>《夜车》《公子娇》《似水流年》成为香港新浪潮电影运动的代表人物。</p><h3 id="方育平"><a href="#方育平" class="headerlink" title="方育平"></a>方育平</h3><p>在 1981 年执导的《父子情》，1983 年执导的 《半边人》 分别夺得香港电影金像奖第一届、第三届最佳影片奖，同时也是香港新浪潮电影运动的代表作品。</p><p>《父子情》一改传统香港电影华丽精致的戏剧式风格，代之以自然平实的叙事和清新恬淡的影像风格，在娓娓道来的凡人琐事中，展现香港平民生活的真实质感，体现出法国新浪潮电影运动的影响。</p><h3 id="徐克"><a href="#徐克" class="headerlink" title="徐克"></a>徐克</h3><p>1979 年到1980 年，徐克拍摄了《蝶变》、《地狱无门》、《第一类型危险》三部风格奇诡的影片，成为新浪潮电影中最特别的代表作。</p><p>这三部影片表面上都有一个商业类型片的外壳，但在叙事及拍摄手法上却是对类型片的颠覆。</p><p>《蝶变》刻画了一个混乱的武林世界，颠覆了香港传统武侠片中的侠义江湖。</p><p>《地狱无门》则刻画了一个“吃人”的世界，充满当时对当代香港社会的影射和隐喻。令人不免想到鲁迅先生的狂人日记。</p><h3 id="许鞍华"><a href="#许鞍华" class="headerlink" title="许鞍华"></a>许鞍华</h3><p>1979 年《疯劫》，用创新的艺术手法，讲述了一桩扑朔迷离的杀人案件。其中，大量使用的自然光效，心里化叙事手段等现代电影技巧，赋予传统惊悚类型片一个全新的面貌。并传达出导演对当代香港社会女性出镜的思考。</p><p>之后，相继执导了《撞到正》、《胡越的故事》、《投奔怒海》等经典影片。</p><p>除了以上代表人物以外，章国明、谭家明、冼杞然、翁维铨、于仁泰 、卓伯棠等年轻（当时年轻）导演们也推出了新作，他们的作品迅速在香港影坛掀起了一股奔涌的浪潮。以新颖独特的艺术成就，影响着香港电影的整体创作态势。</p><h2 id="艺术成就和意义"><a href="#艺术成就和意义" class="headerlink" title="艺术成就和意义"></a>艺术成就和意义</h2><h3 id="艺术成就"><a href="#艺术成就" class="headerlink" title="艺术成就"></a>艺术成就</h3><ul><li><p>题材选择</p><p>“新浪潮” 电影与传统商业电影逃避现实的态度不同，而是选择直面香港社会现实问题，注重对香港本土风貌的展示，注重对个人经验和集体回忆的书写，也关注女性命运，对国家、民族、海外华人等重大议题也并不回避，在思想内容上极大提升了香港电影的内在品质。</p></li><li><p>电影类型</p><p>“新浪潮” 电影打破了此前香港电影的类型藩篱，大胆地对不同的类型元素进行重新组合，翻新了一些旧有的类型片，创造了一些新的类型片，使香港电影呈现出类型丰富、形式多元的新格局。</p></li><li><p>艺术风格</p><p>新浪潮电影导演特别重视电影叙事模式的革新和电影语言的重建，他们把从西方现代电影中学习来的新浪潮电影叙事手法和视听语言技巧完美地融入本土题材，创造出与传统商业电影迥然不同的艺术新风格。</p></li></ul><h3 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a>艺术</h3><p>香港 “新浪潮” 电影运动从整体上提高了香港电影的思想性和艺术性，带动了香港本土电影的复兴，提供了艺术与美学上的新观念，客观上完成了从粤语片传统的伦理套路到现代电影关于人性、生命、社会等普世价值观的过渡。</p><p>同时，也为香港电影业输入了大量的人才，并促成了电影机构的新兴和调整，改善了香港的影视文化环境，堪称香港电影史上最重要的一次电影革新运动。</p><h1 id="台湾新电影运动"><a href="#台湾新电影运动" class="headerlink" title="台湾新电影运动"></a>台湾新电影运动</h1><h2 id="概说-5"><a href="#概说-5" class="headerlink" title="概说"></a>概说</h2><ul><li>1925 年出现了台湾人自己拍摄的第一部影片《谁之过》</li><li>从 1925 年到 40 年代末，是台湾电影草创时期，银幕上依然以日本电影占据主流，本土电影发展缓慢。</li><li>20 世纪五、六十年代，由于台湾地区经济的发展，台海局势的相对稳定，台湾当局反共抗俄的制片方针有所松动。台湾电影出现了短暂的繁荣，出现了以李行、白景瑞为代表的 “健康写实主义” 电影。代表作《蚵女》《养鸭人家》等。</li><li>民营电影公司则大量制作以 “言情片” 和 “武侠片” 为主的商业电影公司。《婉君表妹》、《烟雨濛濛》持续了二十年的琼瑶热。武侠片则以1967 年的《龙门客栈》为潮头，迅速风行台湾。</li><li>到了 20 世纪 70 年代末期，台湾电影陷入商业电影的畸形繁荣之中。犯罪、赌博🎲、打斗:facepunch:、青少年嬉闹、滑稽胡闹以及噱头集锦式的电影以及老套的爱情文艺片、流于教条的军教片充斥于银幕之上。引发了人们对于台湾电影艺术前途的担忧。</li><li>1983 年，琼瑶推出了《昨夜之灯》后解散巨星公司，爱情文艺片年代就此告一段落。 </li><li>同年（1983 年），三位大师导演胡金铨、李行和白景瑞联合执导神怪武侠片《大轮回》，企图挽救濒死的电影市场，可惜票房成绩依然不如人意。</li></ul><p>这两大事件标志着台湾电影陷入低谷期，亟(jí)待新的血液。</p><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><ol><li>欧洲电影的影响</li><li>青年导演的崛起</li><li>香港新浪潮电影的影响</li></ol><h3 id="欧洲电影的影响"><a href="#欧洲电影的影响" class="headerlink" title="欧洲电影的影响"></a>欧洲电影的影响</h3><p>1965 年创刊的《剧场》杂志，1917 年创刊的《影响》杂志，都曾用大量的篇幅介绍欧洲电影，为 80 年代台湾电影的出现奠定了理论基础和人才基础。</p><p>1979 年第 16 届金马奖开始增加国际影展部分，不但使青年电影人获得更多接触欧洲电影的机会，而且还培养了一批高素质的观众。</p><h3 id="青年导演的崛起"><a href="#青年导演的崛起" class="headerlink" title="青年导演的崛起"></a>青年导演的崛起</h3><p>20 世纪 60 年代是台湾商业电影的黄金年代。吸引了很多年轻人到欧美国家攻读电影专业，如就读于美国加州大学的电影科的杨德昌，就读于美国纽约州雪城大学电影研究所的柯一正，就读于美国哥伦比亚影艺学院系的万仁等。他们在七十年代学成归来，为台湾电影带来新的观念和方法。</p><p>在六、七十年代进入电影界、曾追随过健康写实主义电影导演的本土新生代，如陈坤厚、侯孝贤、张毅等，也组成了新的电影创作阵营。他们经过台湾媒体对欧洲电影的评介，以及金马奖国际影展对新电影的知识，技巧的普及，与海外归来的新导演在电影创作理念的沟通上毫无隔阂。</p><p>1983 年，“中影” 公司大胆起用年轻作家小野、吴念真组成 “二人小组” 负责选报题材，并审核或参与别人创作的题材。使战后成长的一代，第一次有机会进入电影体制的决策层，对新电影的产生和发展也起到重要作用。</p><h3 id="香港新浪潮电影的影响"><a href="#香港新浪潮电影的影响" class="headerlink" title="香港新浪潮电影的影响"></a>香港新浪潮电影的影响</h3><p>1980 年 10 月，在金马奖活动期间，台湾 “新闻局” 在电影图书馆举办了 “香港新锐导演作品观摩座谈” 活动，邀请徐克、谭家明、许鞍华、严浩、梁普智等 7 位 “新浪潮“ 导演携作品参加，与台湾影人进行交流，大大鼓舞了年轻电影人。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>1982 年夏，杨德昌、柯一正、陶德辰、张毅联合执导了四段式集锦片《光阴的故事》成为新电影的滥觞之作。四个短片分别为《小龙头》《指望》《跳蛙》《报上名来》，通过讲述四个人生不同阶段的故事，表现人的成长，人际关系的演变，和过去三十年里台湾社会形态的变迁。这部影片奠定了新电影运动的基本特色。</p><ul><li><p>低成本的投资</p></li><li><p>“成长与历史” 的主题</p></li><li><p>写实清新的影像风格</p><p>1983 年，曾壮祥、侯孝贤、万仁联合执导了三段式集锦片《儿子的大玩偶》，成为新电影运动的另一部代表作品 。三个短片分别涉及三个主题，</p></li></ul><ol><li><p>《小琪的那顶帽子》</p><p>以美丽女孩小琪帽子下丑陋的疤痕影射台湾经济繁荣的背后遭受到来自日本的经济侵略。</p></li><li><p>《儿子的大玩偶》</p><p>通过男青年坤树为电影院做活动广告人的故事，展现台湾从农业社会向工业社会转型之际小人物艰难谋生境遇。</p></li><li><p>《苹果的滋味》</p><p>则以一个充满荒诞感的故事展示了朝鲜战争爆发之后台湾对美国经济援助的依赖以及这种依赖对普通台湾人心理的影响。</p></li></ol><p>在台湾新电影运动中的诸多代表人物之中，有以侯孝贤和杨德昌成就最高，影响最大，堪称运动的两大旗手。他们分别从乡村和城市两个角度，记录了台湾社会的沧桑巨变。</p><h3 id="侯孝贤"><a href="#侯孝贤" class="headerlink" title="侯孝贤"></a>侯孝贤</h3><p>侯孝贤生于广东，1948 年移居台湾。1972 年毕业于台湾 “国立艺专” 影剧科。</p><p>他的创作以乡土台湾为起点，对于台湾自身的 “根性” 和历史性发出追问，是 “台湾意识” 强烈外现的重要历史标尺，被称为 “记忆与乡土的书写者”。</p><p>代表作有：书写个人成长记忆的 《冬冬的假期》《童年往事》对于乡村文明与现代都市文明进行比较的《风柜来的人》、<strong>《恋恋风尘》</strong>（推荐）、《尼罗河女儿》。构筑族群历史记忆的《悲情城市》、《戏梦人生》、《好男好女》等。</p><p>其中《悲情城市》以 <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E4%BA%8C%E5%85%AB%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">二·二八事件</a>为背景，讲述了台湾林氏兄弟四人的遭遇和生活，获得威尼斯电影节最佳影片金狮奖。</p><p>滥觞，是一个<a href="https://baike.baidu.com/item/汉语/22488993" target="_blank" rel="noopener">汉语</a>词语，读音为làn shāng，本谓江河发源之处水极浅小，仅能浮起<a href="https://baike.baidu.com/item/酒杯/8395041" target="_blank" rel="noopener">酒杯</a>， [1] 后比喻事物的起源和发端。 [2] 出自《孔子家语·三恕》：“夫江始出于岷山，其源可以滥觞。”</p><h3 id="杨德昌"><a href="#杨德昌" class="headerlink" title="杨德昌"></a>杨德昌</h3><p>杨德昌出生于 1947 年，逝世于 2007 年。大学期间学习控制工程，后到美国学习电脑并获得硕士学位，1981 年回到台湾。</p><p>代表作品</p><p>八十年代《海滩的一天》《青梅竹马》《恐怖分子》</p><p>九十年代《独立时代》《麻将》《一一》</p><p>杨德昌的电影大多立足于都市，聚焦于现代人物质生活丰富和精神空虚的矛盾、人性的 “异化” 之痛和疏离之悲等主题。</p><p>他试图通过电影戳破现代人伪善的面具，发掘那些纯粹天真的东西，因此被称为 “<strong>现代都市文明的省思者</strong>”。</p><p>拍摄于 1991 年，被称为台北三部曲前传的《牯岭街少年杀人事件》，代表杨德昌电影事业的高峰。这部影片改编自 20 世纪 60 年代初的一起真实杀人事件。讲述了家世良好，学习优秀，性格温顺的乖乖仔小四，因为爱上了社会关系复杂的女孩小明，因此陷入到鱼龙混杂的帮派斗争之中。最终沦为杀人凶手的故事，表面上来看这只是一部少年犯罪的影片，但实质上揭示的却是台湾经济起飞时期，社会的动荡、政治的残酷、人性的异化。最终获得金马奖最佳影片和最佳原创剧本两个重量级奖项。</p><h2 id="艺术成就和意义-1"><a href="#艺术成就和意义-1" class="headerlink" title="艺术成就和意义"></a>艺术成就和意义</h2><p>台湾新电影运动在追求电影的思想性和艺术性时，却忽略了电影的大众性、娱乐性、商业性和观赏性。导致台湾观众对于本土电影的反感甚至厌恶，转而投向好莱坞大片的怀抱。这种情况不仅导致了新电影运动在80年代中后期逐渐衰微，而且导致了观众对本土电影失去信心。</p><h3 id="“新电影”-的衰微"><a href="#“新电影”-的衰微" class="headerlink" title="“新电影” 的衰微"></a>“新电影” 的衰微</h3><p>自 1985 年起，台湾产量与发行量较多的电影公司产量不断萎缩，本土电影的票房一路下滑，所以有批评者认为 “新电影运动害惨了台湾电影”。</p><p>1998 年，台湾电影产量不到 20 部。2006 年台湾电影的市场占有率仅有 1.62%，而美国好莱坞电影则占据了 95% 以上的电影票房。</p><h3 id="“新电影”-的艺术成就"><a href="#“新电影”-的艺术成就" class="headerlink" title="“新电影” 的艺术成就"></a>“新电影” 的艺术成就</h3><p>台湾新电影运动以其鲜明的内容和形式特色在华语电影史上写下浓重一笔。</p><p>在题材上，台湾新电影运动不再像言情片和武侠片那样逃避现实，而是努力从日常生活细节或事既有的文学传统中寻找素材，以无比诚恳的态度为当代台湾人的历史、生活及心境塑像。</p><p>《儿子的大玩偶》鉴赏</p><p>在形式上，不强调完整的戏剧结构和情节，善于用散文方式结构剧情，注重用声、光、影像来表达内涵，通过平凡普通的生活细节和场景片断抒发情感，表现出一种清淡、雅致的艺术风格，给观众留下充分的思索空间。</p><p> 主要体现在</p><ul><li>长镜头和景深镜头的大量使用；</li><li>对白中方言的使用；</li><li>大量起用非职业演员</li><li>大量采用实景、外景；偏爱自然光效。</li></ul><p>《童年往事》鉴赏（推荐）</p><p>片断：整体中的一部分，零星而不完整。如：「对于老家，仅剩片断模糊的记忆。」也作「片段」。</p><p>台湾新电影运动与大陆的第五代影像革命、香港新浪潮电影运动并称当代华语电影史上最重要的三次电影革新运动。</p><h1 id="经典好莱坞的“大制片厂制度"><a href="#经典好莱坞的“大制片厂制度" class="headerlink" title="经典好莱坞的“大制片厂制度"></a>经典好莱坞的“大制片厂制度</h1><h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><p>所谓电影工业，是指 “制片”，“发行”，“放映” 的工业体系。</p><p>电影产业则不仅拥有经济属性，而且拥有社会文化属性。</p><h3 id="电影工业与电影产业-1"><a href="#电影工业与电影产业-1" class="headerlink" title="电影工业与电影产业"></a>电影工业与电影产业</h3><p>世界电影工业形成了以美国好莱坞为中心，印度宝莱坞和你离日亚的尼莱坞等为中间梯队的格局。</p><p>好莱坞电影工业的发展主要经历了 20 世纪三四十年代的 “经典好莱坞时期” 和六七十年代的 “新好莱坞时期”。</p><p>虽然这两个阶段的电影工业有着不同的发展背景，亦呈现出不同的面貌。但在制作、发行、放映三个环节都有这强烈的好莱坞电影工业风格。从而不仅称为美国社会经济的重要支柱，而且深刻影响着其他国家的电影生产。</p><p>地理学上的好莱坞诞生于 1908 年初，当时导演弗兰西斯鲍格斯为拍摄电影《基督山伯爵》和摄影师来到洛杉矶郊外的这个荒凉村落，建立了第一座摄影棚。当时出售这块土地的人随口命名为其好莱坞。</p><p>1905 年，美国第一家专门放映电影的剧院在宾夕法尼亚州的匹斯堡开张，因其入场费只需一枚五分的镍币而得名 “镍币影院”。</p><p>凭借着低廉的价格，镍币电影院开创的早期电影放映模式大获成功。并推动美国电影放映业的快速发展。直到 1910 年，镍币影院才被更大更豪华的电影放映厅逐渐取代。</p><p>1908 年，美国第一个电影 “托拉斯” 组织，爱迪生的 “电影专利公司” 成立，该公司由美国爱迪生公司（就是那个搞发明的爱迪生，排挤特斯拉的那位）和沃格拉夫公司等七家公司和法国的百带梅里爱两家公司联合组成。</p><p> “电影专利公司” 从各种电影技术发明者那里取得了 16 项专利权，获得了电影胶片唯一生厂商 “柯达公司” 的专卖权。</p><p>关键还在于，电影专利公司还借助法律对相关行业进行控制与垄断。</p><p>同时，该公司在 1910 年成立了专门负责发行的通用影片公司，从而全面控制了美国的电影业。</p><p>“电影专利公司” 这种将制片、发行、放映通过合并、兼并或是购买股权、签署协议等方式集中在一起的垂直整合方式，有效的形成了一种 “纵向垄断”。</p><p>夺笋啊。</p><p>然而，这种垄断却引发了美国独立制片商和发行商的极大愤恨。而当时的好莱坞不仅拥有四季宜人的气候，价格低廉的劳动力和复杂奇特的地形等。关键是，远离纽约和芝加哥又临近墨西哥边境，即电影专利公司一旦提出诉讼，他们很快就可以逃离美国。</p><p>在这样的背景下，众多电影公司便纷纷涌进好莱坞。</p><p>“电影专利公司” 从 1912 年开始丧失在美国电影市场的优势，直到 1917 年彻底消失。究其原因：</p><ol><li>为了降低制作成本，尽量进行标准化的生产，但是并没有将生产流程推向规模化，仍然是 “手工作坊式” 的生产。</li><li>“电影专利公司” 生产的影片主要在当街店铺、杂耍场和 “镍币影院” 放映，观众也以下层民众和移民为主，因此经济效益就可想而知。</li><li>“电影专利公司” 的最大失误，在于企图通过垄断 “制片业” 来垄断整个电影行业，然后事实证明，垄断 “发行业” 和 “放映业” 才是最有效的途径。</li></ol><p>后面好莱坞的八大电影公司，最初都是从放映业开始逐渐扩大影响力和控制范围。</p><p>1913 年，卡尔·莱默尔在好莱坞建立 “环球影城”，标志着好莱坞电影从 “手工作坊” 转变为 “工业化生产”；随后影响遍及全世界的 “八大电影公司” 逐渐形成。这八大电影公司包括 “五大” 和 “三小”。三小。。。。</p><p><strong>五大</strong></p><ul><li><p>派拉蒙（山峰）</p></li><li><p>华纳兄弟（WB）</p></li><li><p>米高梅（🦁️狮子头的那个）</p></li><li><p>福克斯（20th 的那个）</p></li><li><p>雷电华（在1930年代和1940年代，雷电华出品了许多著名影片，如《<a href="https://zh.wikipedia.org/wiki/公民凯恩" target="_blank" rel="noopener">公民凯恩</a>》《<a href="https://zh.wikipedia.org/w/index.php?title=美人计_(电影)&action=edit&redlink=1" target="_blank" rel="noopener">美人计</a>》《<a href="https://zh.wikipedia.org/w/index.php?title=白雪公主_(电影)&action=edit&redlink=1" target="_blank" rel="noopener">白雪公主</a>》《<a href="https://zh.wikipedia.org/wiki/風雲人物_(電影)" target="_blank" rel="noopener">风云人物</a>》《<a href="https://zh.wikipedia.org/wiki/金刚_(1933年电影)" target="_blank" rel="noopener">金刚</a>》等。1950年代开始衰退，逐渐退出了电影界，最终转向了电视方面的发展。）</p><p> 这五家公司不仅控制了制片业，而且拥有最具吸引力和最高票房的影院。它们在美国各大城市争夺观众，并划分了各自的影院势力范围。</p></li></ul><p><strong>三小</strong></p><ul><li>哥伦比亚（图标类似自由女神🗽的那个）</li><li>联艺</li><li>环球（UNIVERSAL 环绕🌍地球）</li></ul><p>是指制片和发行规模都比五大公司要小的。</p><p>在 20 世纪 30 年代，好莱坞遭遇经济危机时，摩根和洛克菲勒两大财团，控制了除华纳兄弟之外的七家定影公司，也正是由于两大财团的介入，使得八大公司之间的关系盘根错节，即根本不可能展开真正意义上的竞争，也不可能彻底垄断市场 。于是在互惠互利的情景下，八大公司逐渐形成了，制片、发行、放映的横向联合。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/05/28/qNjUAP1QgZFHoBa.png" alt="image.png"></p><p>总体来说，由于这种严密的 “纵向垄断” 与 “横向联合”，使得好莱坞在 20 世纪三四十年代不仅包揽了美国电影 90% 的产量，而且有效排挤了独立制片公司和外国电影公司，其产量占据当时全世界的 60%。</p><h2 id="制片特点"><a href="#制片特点" class="headerlink" title="制片特点"></a>制片特点</h2><p>20 世纪 20 至 50 年代，大制作片厂制度在好莱坞逐渐形成，其囊括了流水线的生产方式、制片人中心制、明星制度、学徒式的人才培养机制，和以海斯法典为核心的审查机制等基本要素。</p><blockquote><p>关于海斯法典的，上面提到过，1930 年颁布的。</p><p><strong>电影制作守则</strong>（Motion Picture Production Code）是1930年至1960年适用于<a href="https://zh.wikipedia.org/wiki/美国" target="_blank" rel="noopener">美国</a><a href="https://zh.wikipedia.org/wiki/电影" target="_blank" rel="noopener">电影</a>的行业道德规范，由于时任<a href="https://zh.wikipedia.org/wiki/美国电影制片人与发行人协会" target="_blank" rel="noopener">美国电影制片人与发行人协会</a>主席为<a href="https://zh.wikipedia.org/w/index.php?title=威尔·海斯&action=edit&redlink=1" target="_blank" rel="noopener">威尔·海斯</a>，该守则又被称为“<strong>海斯法典</strong>”（<strong>Hays Code</strong>）。在海斯的领导下，美国电影制片人  与发行人协会，即后来的美国电影协会于1930年采纳了该守则并从1934年开始严格执行。该守则详细说明了在美国面向公众，什么样的电影可以接受，什么样的电影不可接受。1968年，电影制作守则被<a href="https://zh.wikipedia.org/wiki/美国电影分级制度" target="_blank" rel="noopener">美国电影分级制度</a>代替。</p></blockquote><p><strong>大制片厂的最大特点是流水线（Pipeline）的生产方式。1908 年美国人福特开创性以流水线生产方式，通过组装配件进行汽车生产，从而极大降低了成本，也使大规模的批量生产成为可能，被誉为现代大机器生产的代表。</strong></p><p>1913 年，美国独立制片人兼导演托马斯·英斯意识到这种生产方式的价值，便建立了类似的电影生产模式，从此 “流水线的生产方式” 就成为了好莱坞电影工业的标志。</p><p> 随后，在好莱坞的鼎盛时期，这种方式不断成熟。从而既保证了片源的丰富与稳定，又催生了电影类型片的出现。在这种流水线的生产方式中，导演对电影的整体把控权被剥夺了，取而代之的是强化了制片人的控制权，即形成了制片人中心制。</p><p><strong>制片人中心制</strong></p><p>“<strong>制片人中心制</strong>“ 突出了制片人在实现电影商业价值过程中的关键性作用，因为制片人可以根据电影的市场状况，随时更换演职人员，甚至还可以任意更改剧情。</p><p> 好莱坞制片人中心制的经典案例，就是在 1939 年拍摄电影《乱世佳人》时，制片人塞尔兹尼可就曾经先后撤换了三、四位导演。在制片人中心制下，制片人不仅可以撤换导演，也可以随意更换演员。因为大制片厂制度中的演员是获得电影票房、赢得商业利益的重要保证。于是这就意味着制片人既可以发现和捧红某个明星，也可以在一夜之间毁掉某个明星，即形成了好莱坞独有的明星制度。</p><p><strong>明星制度</strong></p><p>好莱坞的 ”明星制度“ 有两个方面含义：</p><p>一是 ”明星签约制“，指通过签订合约使用明星隶属于某个制片公司，而当时明星的签约年限一般都在七年以上，因此明星往往就成为了某个公司的财产。</p><p>二是指大制片公司在进行某些重要的电影创作及宣传时都要围绕明星展开，而旨在使明星成为电影的品牌。</p><p><strong>特点</strong></p><p>“大制片厂制度” 下的好莱坞以 “学徒制” 作为培养电影人才的主要模式。从本质上来看，这种人才培养机制只是教会这些人如何快速融入好莱坞的 “大制片厂制度”，其同时促成了好莱坞电影类型片产生与繁荣。</p><p>“学徒式的人才培养机制” 很容易造成电影人创造力的枯竭，因此好莱坞总是想方设法从欧洲和其他国家挖掘成熟的导演，或是成名的演员等，以补充自身人才培养的缺陷，从而既能够保证好莱坞电影工业的延续，又能够使电影创作不断获得新的灵感与资源。</p><p>好莱坞大制片厂生产的电影，在上世纪三十至六十年代深受《海斯法典》为核心的审查机制的影响。</p><p><strong>海斯法典</strong></p><p>是美国在 1930 年颁布的限制电影内容的审查法规；该法规由时任 “美国电影制片人和发行人协会” 主席的威尔·海斯执行，所以被称作 “海斯法典”。</p><p>《海斯法典》主要有 3 项基本原则和 12 大项禁止的内容。如遵守禁酒令、不得宣扬烧酒、不可详细描述谋杀、盗窃、抢劫的方法等。</p><p>著名的《海斯法典》案例，就是希区柯克在 1946 年拍摄电影《美人计》时，鉴于法典规定吻戏不能超过三秒，于是就让男女演员吻三秒停一下再吻。最后电影中的加里格兰特就抱着英格丽褒曼，连续并间断的吻了两分半钟。</p><p>《海斯法典》在当时对美国电影的影响极大，从 1930 年到 1960 年的每一部影片都要严格遵守其规定。</p><p>1966 年伊丽莎白·泰勒主演的《灵欲春宵》上映，这部获得 13 项奥斯卡提名的影片由于有大量的粗口，第一次明确标出：“18 岁以下观众需要父母陪同观看”。</p><p>以《灵欲春宵》这部电影为节点，《海斯法典》在 1966 年正式废除，取而代之的是美国 “电影分级制度”，从此美国电影翻开了全新的一页。</p><p>值得一题的是，好莱坞大制片厂制度还引进了观众学研究。</p><p>20 世纪 40 年代，由于海外市场的丧失等原因，好莱坞电影的整体市场份额有所下降，为了继续保持对电影市场的控制优势，好莱坞的大制片公司便引入了观众学研究。最早进行电影观众学研究的关键人物是乔治·盖洛普。</p><p>盖洛普在 1938 年底到 1939 年初针对电影《乱世佳人》的观看兴趣分析中，发现了一个问题，很多人都读过《乱世佳人》的小说，但其中绝大部分都没有打算去观看这部改编电影，同时还有约三分之二的人不知道影片主角的扮演者是费雯丽 。基于观众调查的情况，盖洛普告诉这部电影的制片人，一方面要把《乱世佳人》拍成彩色片，另一方面要将宣传重点放在女主角费雯丽身上。也正是得益于盖洛普的观众学研究，《乱世佳人》才创造出了世界电影史上的票房奇迹和艺术奇迹。</p><p>上述这些大制片厂的特点，共同促成了好莱坞电影类型片的出现与繁荣。其实，好莱坞大部分类型片在上世界 20 年代末就已经初具规模，到 30、40 年代更是占据了统治地位。</p><p>当时最经典的类型片有：</p><ul><li>喜剧片</li><li>西部片</li><li>犯罪片</li><li>幻象片等</li></ul><p>关键在于好莱坞还采用热潮更替的方式进行电影类型片的生产，即在观众厌烦了某一种类型之后，会及时更换为另一种类型，如此周转不息的反复轮换，从而保证好莱坞电影一直都是观众的观看热点。</p><h2 id="发行特点"><a href="#发行特点" class="headerlink" title="发行特点"></a>发行特点</h2><p>大制片厂制度下的好莱坞电影工业，在发行发面针对国内市场和国外市场采用了不同的策略，以保证其电影发行的长盛不衰。针对国内的电影发行，好莱坞首先以垄断的方式打击独立制片商和外国电影势力。</p><p>当时好莱坞八大电影公司主要有三种方式操纵电影发行：“成批订片” “盲目订片” 和签订有利于发行商的租片合同。</p><h3 id="成批订片"><a href="#成批订片" class="headerlink" title="成批订片"></a>成批订片</h3><p>是指放映商要想购买某部由大明星主演的影片，就必须同时购买一部由一般演员主演的影片。即使明知道这些电影会亏本，但为了获得明星主演电影的发行权，就不得按照制片公司的要求去批量购买。</p><p>最早出现于 1916 年的派拉蒙公司，后来发展为好莱坞的一种电影发行惯例。尤其是大制片公司都会利用明星的影响力，强制搭售一般的影片。</p><h3 id="盲目订片"><a href="#盲目订片" class="headerlink" title="盲目订片"></a>盲目订片</h3><p>要求放映商在没有看到电影之前，就必须签订放映合同。</p><p>“成批订片” 和 “盲目订片” 作为好莱坞 “大制片厂制度” 的产物，能够有效保证制片这个最不稳定、风险最大的行业获得稳定的收入，刺激制片公司将更多的精力用于制片而不是发行和放映，从而保证 “大制片厂制度” 的稳定运行与经济效益。</p><p>然而这种一揽子交易也在相当程度上损害了独立放映商的利益，同时也限制了外国电影进入美国。</p><p>针对国外的电影发行，早在第一次世界大战期间，好莱坞就以低价销售的策略，轻而易举的占领了外国市场。</p><h3 id="低价销售"><a href="#低价销售" class="headerlink" title="低价销售"></a>低价销售</h3><p>指好莱坞大制片公司通过海外代理机构，以低于竞争对手的价格将电影租给当地放映商，从而控制其它国家电影发行的策略。</p><p>为了保护本土电影市场，20 世纪 20 年代的欧洲不断开展抵抗好莱坞电影的运动。</p><p>好莱坞当然不会示弱。</p><p>一、美国政府对其全力支持，不仅帮助好莱坞制定合理的出口政策，还通过贸易谈判等为电影出口进行辩护。</p><p>二、”八大电影公司“ 也通过设立办事处等进行国外的电影发行，并以投资的方式控制其它国家的电影企业。</p><p>三、美国民众也抵制外国电影的进入。</p><p>1922 年德国表现主义电影的经典之作《卡里加里波士》在洛杉矶举行首映时，美国民众就因为担心电影市场落入德国手中，而展开了强烈的抗议活动。关键在于，好莱坞还不断挖走其它国家的优秀电影人才。</p><p>如对德国电影人才的引进，20 年代中期，弗里兹·朗、刘别谦等优秀的德国电影人相继离开德国去了好莱坞。到 30 年代，更多的欧洲电影人为躲避法西斯的迫害纷纷前往好莱坞，这样虽然给好莱坞带来了全新的艺术理念和创作资源，但是确使本国的优秀电影人才流失，从而不再可能与好莱坞形成竞争。</p><h3 id="放映特点"><a href="#放映特点" class="headerlink" title="放映特点"></a>放映特点</h3><p>除了在制片和发行发面特点鲜明。</p><p>好莱坞 “大制片厂制度” 中的 “放映” 也形成了自己独特的方式，主要有 “映轮——映区——轮空” 和 “双片放映 ”。</p><p><strong>映轮——映区——轮空</strong>，是指在一部电影拍摄完成之后，首先以较高的票价在地段和设施都比较好的 “首轮影院” 放映，一般来说这次首轮这次放映的收入最多。然后在相隔一段时间之后，再进行影片的 “第二轮放映”，而影院的豪华程度、所处的地段和电影票价也都比首轮放映时要低，同时收入也会相应减少。首轮放映和第二轮放映之间的时间间隔期，就被称为 “轮空”。</p><p>事实证明，好莱坞大制片厂制度的这种 “映轮——映区——轮空” 机制，非常有效的控制了电影的放映业，同时成功排斥了独立制片和外国电影。当然也不可避免的损害的广大电影观众的利益。</p><p><strong>双片放映</strong>，是指每次都放映两部影片：第一部是正片，即通常所说的 “A 级片”，第二部是 “加片”，即 “B 级片”。</p><p>一般来说，“加片” 既有大制片公司生产的影片，也会有独立制片公司生产的影片，但是这些电影在制作成本和质量等方面都无法与正片相比，而采用 “双片放映” 的目的，就在于招揽观众和加速大制片公司的资金周转。</p><p>值得一提的是，B 级片在相当程度上为电影新人提供了机会，也为电影的艺术创新留下了难得的空间。因为 B 级片没有 A 级片那么严格，很多难以获得 “A 级片” 拍摄资格的青年电影导演，就可以利用拍摄 “B 级片” 的机会，充分发挥自己的才能；同时 “B 级片” 导演也拥有更多的创作自主权，因此可以在电影的创作中进行创新。</p><p>事实证明，后来的新好莱坞电影的出现，就与 昆汀·塔伦蒂诺、蒂姆·伯顿等当时一大批 B 级片导演的努力密不可分。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>总体来说，大制片厂制度下的制片、发行、放映都成了好莱坞的电影工业体系，从而保证了好莱坞电影的稳定生产与在世界范围的影响力。</p><h1 id="从“经典好莱坞”到“新好莱坞”"><a href="#从“经典好莱坞”到“新好莱坞”" class="headerlink" title="从“经典好莱坞”到“新好莱坞”"></a>从“经典好莱坞”到“新好莱坞”</h1><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><h3 id="社会背景"><a href="#社会背景" class="headerlink" title="社会背景"></a>社会背景</h3><p>从稳定繁荣到动荡不安。</p><p>经典好莱坞电影繁荣的三四十年代，是美国社会的平稳上升期，而六七十年代的美国社会各方面矛盾激化：不仅有第二次世界大战带给人们的心理创伤，而且战后的冷战格局，以及美国奴隶制的历史遗留问题等，都使人们出现了强烈的危机感。</p><p>1963 年 “肯尼迪遇刺” 和同年爆发 “越南战争” 为直接导火索，美国国内开始了大规模的 “反战游行” 和 “民权运动”。</p><p>在文化领域，青年一代的反传统狂潮。如嬉皮士运动，迷恋摇滚乐等也一发不可收拾。在这样的背景下，经典好莱坞电影那种单一闭合的叙事表达，已经不能够满足人们的观影需要，于是便激发了新好莱坞的出现。</p><p>其次，二十世纪美国的娱乐形式也经历了从电影主宰到电视分流的发展过程。1905 年的第一家镍币影院出现后，电影很快就取代马戏团、歌剧院等成为最大的娱乐业。随后八大电影公司通过在制作、发行、放映环节的扩张，在三四十年代达到顶峰。</p><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>然而从六七十年代开始，电视成为了美国人最主要的娱乐方式。同时电影的观众群体也发生了变化。</p><ol><li><p>由于电影以更加通俗大众的方式分流了普通平民阶层的大量观众，那些文化层次较高、收入也较高的人们就成为主要的电影观众，而这些观众都有着一定的反思意识和社会文化参与意识，于是他们期待在电影中看到更多的社会批判内容。</p></li><li><p>另一方面，二战后的生育高峰使 12 至 29 岁的青年人成为新的电影观众群体，并且占到观影总人数的 90%。作为在电视机前长大的一代，他们惯于用眼睛思维，而要想将吸引这部分受众，就必须进行电影语言的创新。</p></li><li><p>经典好莱坞电影的制作、发行、放映完全被八大电影公司垄断；后来美国最高法院判定了八大电影公司的垄断行为，于是它们便放弃了这三个环节中利润最低的放映，同时开始重视利润更大的发行：每年除了制作十几到几十部数量不等的影片之外，也开始自主发行独立生产的影片——这实际上为 “独立制片” 的兴起和电影人摆脱大制片厂制度提供了机会。</p></li><li><p>文化转型：从美国中心 到 “欧洲旨趣” 。</p><p>第二次世界大战结束之后，欧洲电影开始复兴，并且形成了与好莱坞风格迥异的文化表现与艺术特征，而 “意大利新现实主义电影运动” “法国新浪潮电影运动” 等都深深吸引并影响了好莱坞的年轻电影人，于是他们便邀请欧洲电影到美国讲学、交流电影的创作经验。</p></li></ol><p>1967 年的两部影片 《邦尼和克莱德》、《毕业生》为标志，美国正式进入 “新好莱坞电影” 的发展时期。</p><p>其中 《邦尼和克莱德》由舞台和电视出身的导演 阿瑟·佩恩 执导。故事取材于 30 年代美国一对银行抢劫犯的真实经历。他们的犯罪行为被影片呈现为个人反抗社会的壮举。因为电影工作者希望通过这雌雄大盗，进行一种批判性的社会反思。</p><p>影片的类型属于传统的 “强盗片”，但又明显受到 “法国新浪潮电影”，尤其是戈达尔的影响。这部影片的出现在当时引起了全世界的关注：美国《时代周刊》称其是 “美国新浪潮电影” 的化身；英国《女王》杂志称 “1967 年是《邦尼和克莱德》年”。</p><p>相比于《邦尼和克莱德》的传奇色彩，麦克尼·科尔斯执导的《毕业生》（是的，就是那个逃婚后坐到公交上，迷茫眼神的那个），则将目光投向当代美国青年人的生活。准确把握了青年人初入社会时的迷茫，受到青年观众的普遍喜爱与共鸣，同时还留下了《斯卡布罗集市》、《寂静之声》等传唱至今的经典电影歌曲。</p><p>随后，新好莱坞电影便开始快速发展，相继出现了</p><ol><li>丹尼斯·霍珀的《逍遥骑士》</li><li>罗伯特·阿尔特曼的《陆军野战医院》</li><li>乔治·卢卡斯的《美国风情画》</li><li>马丁·斯科塞斯的《穷街陋巷》和《出租车司机》</li></ol><p>等经典之作。</p><p>其中电影《逍遥骑士》受到战后垮掉一代的代表人物，杰克·凯鲁亚克的名作《在路上》的影响。以公路片的形式讲述了两个嬉皮士的漫游经历，影片有着明显的纪实风格，从中可以窥见上世纪六七十年代，美国光怪陆离的社会图景，以及青年一代的梦想迷惑和反抗。</p><blockquote><p>嬉皮士和朋克相关的内容，<strong>甚至</strong>可以看看<a href="https://www.youtube.com/watch?v=ZzMUOoQ1QCQ&t=672s" target="_blank" rel="noopener">窺探未來：全面瞭解賽博朋克Cyberpunk【就知道玩遊戲31】</a></p></blockquote><h2 id="新好莱坞的青年导演群"><a href="#新好莱坞的青年导演群" class="headerlink" title="新好莱坞的青年导演群"></a>新好莱坞的青年导演群</h2><p>新好莱坞对世界电影发展的最大贡献，就是出现了一批至今仍然活跃在影坛，颇具实力与影响力的导演。这些导演在 20 世纪六七十年代，刚刚迈出大学校门后不久，就有了独立拍摄电影的机会，并在当时形成了影响力极大的青年导演群。</p><p>这个青年导演群的主要成员有：弗朗西斯·科波拉、马丁·斯科塞斯、乔治·卢卡斯、史蒂芬·斯皮尔伯格等。</p><h3 id="弗朗西斯·科波拉"><a href="#弗朗西斯·科波拉" class="headerlink" title="弗朗西斯·科波拉"></a>弗朗西斯·科波拉</h3><p>新好莱坞青年导演群的领军人物，非弗朗西斯·科波拉莫属。</p><p>“教父” 系列电影，是传统类型片中的 “黑帮片” 与导演个人风格完美结合的典范之作。</p><p>《<strong>教父</strong>》根据马里奥·普佐的小说改编，以美国黑手党柯里昂家族三代人的生活为主线，突破了传统黑帮片以犯罪故事为主的叙事陈规，而是深入人物内心深处，反映他们置身多重人生角色矛盾旋涡中的艰难抉择。影片不仅有着严谨的叙事结构和鲜明的人物形象，而且具有深厚的历史感和悲剧感。</p><p>此后，科波拉创作的《对话》、《现代启示录》等影片，都愈发远离了经典好莱坞的类型片原则，而更为突出和强调个性化色彩。</p><h3 id="马丁·斯科塞斯"><a href="#马丁·斯科塞斯" class="headerlink" title="马丁·斯科塞斯"></a>马丁·斯科塞斯</h3><p>新好莱坞青年导演群的重要人物之一，马丁·斯科塞斯在 1973 年拍摄的《穷街陋巷》是他电影生涯中的第一部重要作品，影片通过对意大利移民后裔在曼哈顿下东区艰难生活的细致描绘，体现出明显的导演个人风格，而这种个人风格在他 1976 年拍摄的另一部电影片《<strong>出租车司机</strong>》中得到了进一步的延续与发展。关键在于影片《出租车司机》还以强烈的悲剧气息，展示了越战后美国社会的迷茫，并将斯科塞斯推向了大师级电影导演的行列。</p><p>此后，马丁·斯科塞斯还导演了《<strong>愤怒的公牛</strong>》、《基督最后的诱惑》、《纽约黑帮》、《无间道风云》等影片。</p><h3 id="乔治·卢卡斯"><a href="#乔治·卢卡斯" class="headerlink" title="乔治·卢卡斯"></a>乔治·卢卡斯</h3><p>与其他青年导演相比，乔治·卢卡斯有着更为多重的身份。</p><ul><li>作为导演，他拍摄了科幻电影的杰出作品，星球大战系列影片。</li><li>作为制片人，他监制了斯皮尔伯格导演的冒险片经典之作《印第安纳·琼斯》系列三部曲。</li><li>作为老板，他在 1972 年成立的 “卢卡斯电影有限公司”，至今仍然是全世界规模最大的独立电影制片公司。</li></ul><p>客观而言，乔治·卢卡斯对电影类型片的兴趣比较单一，并主要集中在拍摄科幻片上，而他创作的唯一一部非科幻电影《美国风情画》，作为其在新好莱坞时期的代表作品，讲述上世纪 60 年代几位刚步出高中校园的加州少年，即将因为不同的人生选择而各自发展，通过详细描绘他们在小城一夜间的经历，反映出越战前夕美国青年人的思想感情等。其中大量运用了 50 年代的流行摇滚音乐，从而使影片充满了浓厚的怀旧气息 。</p><h3 id="史蒂芬·斯皮尔伯格"><a href="#史蒂芬·斯皮尔伯格" class="headerlink" title="史蒂芬·斯皮尔伯格"></a>史蒂芬·斯皮尔伯格</h3><p>后来成为了世界电影史上最具影响力的导演之一，他在新好莱坞时期拍摄了职业生涯中的第一部成功的作品——1974 年的《大白鲨》。作为一部恐怖片，《大白鲨》展示了斯皮尔伯格对观众心理的卓越把握能力，以及对电影节奏的准确掌控。</p><p>斯皮尔伯格是 “青年导演群” 中最具类型意识、题材选择也是最为广泛的导演。后来拍摄了科幻片《<strong>E.T</strong>》《人工智能》等，还富有开创性的将科幻片与恐怖片融合创作出《侏罗纪公园》以及寻宝冒险片的经典之作——印第安纳·琼斯系列。 </p><p>斯皮尔伯格在上世纪 80 年代之后拍摄的《<strong>辛德勒的名单</strong>》、《<strong>拯救大兵瑞恩</strong>》、《<strong>慕尼黑惨案</strong>》等影片都展示了他对历史对人生思考的深度和广度，体现出其将类型片的商业元素与导演的个人风格结合的高超能力。</p><h2 id="新好莱坞电影的特点"><a href="#新好莱坞电影的特点" class="headerlink" title="新好莱坞电影的特点"></a>新好莱坞电影的特点</h2><p>与其说新好莱坞是对经典好莱坞的革命，是新与旧之间的对抗，不如说是好莱坞是在尊重经典好莱坞基础之上的丰富发展与重组进步。</p><p>客观而言，新好莱坞继承了经典好莱坞的生产方式和类型片的工业传统，同时借鉴并融合了欧洲电影的艺术表现，从而给美国电影带来了深远的变化，并呈现出新的特点，主要体现在 “类型意识的突破” “作者风格的确立” 和 “镜语体系的革新” 三个方面。  </p><h3 id="1-类型意识的突破"><a href="#1-类型意识的突破" class="headerlink" title="1. 类型意识的突破"></a>1. 类型意识的突破</h3><p>将电影类型片带入了一个新的时代，经典好莱坞时期的电影类型片是狭义的，每种类型自成体系结构闭合，且类型之间也少有交叉。</p><p>20 世纪六七十年代，美国社会充满了激烈的矛盾冲突与文化碰撞，经典好莱坞类型片那种稳定、闭合的结构便开始与观众的观影期待之间产生距离。于是，新好莱坞不再以单一的类型模式进行创作，而是将各种类型作为电影元素进行使用，从而促成了 “类型融合” “超类型” “反类型” 等的出现。</p><h3 id="2-作者风格的确立"><a href="#2-作者风格的确立" class="headerlink" title="2. 作者风格的确立"></a>2. 作者风格的确立</h3><p>“法国新浪潮电影运动” 提出的 “电影作者” 观点在新好莱坞时期被引入美国，主要用于反抗标准化的电影制作；同时法国《电影手册》杂志还评选出了在好莱坞商业体制内创作，但并不随波逐流，具有鲜明导演个人风格的 “电影作者”。</p><p>如<strong>奥逊·威尔斯、希区柯克、霍华德·霍克斯、约翰·福特</strong>等。记住这几个导演，都是<strong>顶级</strong>导演，如果看过《电影艺术：形式与风格》的话，里面会经常提到。</p><h3 id="3-镜语体系的革新"><a href="#3-镜语体系的革新" class="headerlink" title="3. 镜语体系的革新"></a>3. 镜语体系的革新</h3><p>一方面，新好莱坞电影抛弃了经典好莱坞搭镜拍摄的习惯，采用实景拍摄，从而增加了影片的真实性；</p><p>另一方面，新好莱坞电影打破了经典好莱坞电影线性叙事的闭合结构，对故事情节进行一种非戏剧化的处理。</p><p>此外，在人物设置上，新好莱坞电影偏好以充满反抗意识、但寻找不到出路的成长中的青年人为主角，着力刻画他们复杂的内心世界和面对现实时的迷惘与无奈，注重对人物个性的展现。</p><p>好莱坞的扩张极大促进了美国电影工业的发展，并确立了其在世界影坛的霸主地位。</p><p>据相关统计，从上世纪 90 年代开始，好莱坞每年约有一半的电影票房都来自海外市场，而相比之下，外国电影在美国市场份额却不足 10%，其实各国对好莱坞称霸都充满了焦虑，一些国家的电影人还行动起来抵制好莱坞。如在 1995 年 12 月 28 日，即世界电影诞生 100 周年的纪念日，法国影星阿兰德龙就在巴黎协和广场进行了一次反抗好莱坞的行为艺术，将一盒好莱坞电影的拷贝当众销毁，从而发出法国作为世界电影诞生地的一声怒吼。1998 年韩国国民导演林泽权也和许多韩国电影人一起，开展了声势浩大的光头运动，抗议美国在韩国自由放映电影，并以胜利告终。</p><p>虽然这些运动体现出各国电影人对本民族电影的热情与坚守，但是到目前为止，好莱坞的霸主地位始终没有动摇。</p><p>置身当前的时代语境，好莱坞电影工业呈现出 “电影创作兼收并蓄” “数字技术主导世界” “电影工业发展全球化” 的特点。</p><h3 id="电影创作兼收并蓄"><a href="#电影创作兼收并蓄" class="headerlink" title="电影创作兼收并蓄"></a>电影创作兼收并蓄</h3><p>好莱坞自建立之初就十分重视吸收利用其它国家的电影资源，如直接聘用国外知名导演到好莱坞拍摄电影。德国导演刘别谦， 英国导演希区柯克都是在好莱坞实现的事业巅峰。同时还对其它国家的优秀电影作品进行改编再创作。如重拍了日本电影《谈谈情跳跳舞》《午夜凶铃》香港电影《无间道》（有内鬼，终止交易！！）等。好莱坞还选取其它国家的典型时代事件，或是民族色彩强烈的神话传说，作为基本素材进行电影创作。如拍摄了《埃及艳后》《特洛伊》《花木兰》《指环王》等。关于指环王的详细解析，可以看青蛙刀圣的<a href="https://www.youtube.com/channel/UCWx-9tUBYtpVVchhNVDchSw" target="_blank" rel="noopener">解说视频</a>。</p><p>此外，好莱坞还吸收其它国家最具民族特色的文化元素，将其与各种类型片融合，创作出具有多元文化背景的电影作品。如将中国功夫融入好莱坞动作片的《杀死比尔》《功夫熊猫》等。<strong>还有今年的《Raya and the Last Dragon》中文名《寻龙传说》，公式化的情节、定型化的人物、图解式的视觉形象。这就是类型片，上面说过了。说实话，这个电影对东南亚文化理解只是浮于表面的，只是各个文化的堆砌，大杂烩，我是不会买账的，浪费我在腾讯视频上买这电影的钱</strong>。如果你希望从这电影中感悟什么，获得什么，你将会浪费 108 分钟。</p><p>全球化时代好莱坞电影工业的第二个特点是 “数字技术主导世界”。从 2005 年以来，约 80% 以上的好莱坞电影都是通过数字技术制作画面，同时几乎所有的电影声音也都是由数字处理的。尤其是《侏罗纪公园》中逼真的恐龙，《终结者》中的液态机器人，还有《泰坦尼克号》中规模巨大的灾难场景等，可以说好莱坞的数字技术的发展令其它国家望尘莫及。  </p><p>全球化能够带给电影更多的投资和跨国产权，从而有效分担电影拍摄日益攀升的成本与相应的投资风险。除了充分吸纳各国的资金，与主要经济大国进行电影生产的合作，好莱坞各大电影公司还纷纷在其它国家建立子公司。</p><p>2003 年中国电影产业发展的初期，美国华纳电影公司就以参股 49% 的方式与上海永乐电影城合作。</p><p>2004 年华纳再次与广州金逸合作，投资建设具有世界一流水准的多厅影院。</p><p>总体来说，如今的美国好莱坞继承着经典好莱坞确立的类型片传统，发扬着新好莱坞对电影观念和工业体制不断改革的优势，同时利用最先进的数字技术，并牢牢把握着全球化的时代特点，继续占据着世界影坛的霸主地位。</p><h1 id="新生态与新格局：中国电影产业"><a href="#新生态与新格局：中国电影产业" class="headerlink" title="新生态与新格局：中国电影产业"></a>新生态与新格局：中国电影产业</h1><h2 id="前奏：中国电影开始全面改革"><a href="#前奏：中国电影开始全面改革" class="headerlink" title="前奏：中国电影开始全面改革"></a>前奏：中国电影开始全面改革</h2><p>1993 年中国电影拉开了全面改革的大幕，随后在港片合作片中分账制度被引入内地，于是从 1994 年起，我国开始了以分账大片的形式，引进世界各地的优秀影片。进入新世纪以后，以 2001 年我国加入世界贸易组织为契机，中国电影改革十年之后的 2003 年，真正开始了产业化发展，并在当下呈现出新生态与新格局，成为社会文化生活的重要组成部分。</p><h3 id="一-改革之前的中国电影产业"><a href="#一-改革之前的中国电影产业" class="headerlink" title="一 改革之前的中国电影产业"></a>一 改革之前的中国电影产业</h3><p>上世纪 80 年代我国改革开放之初的电影产业，是在新中国学习苏联电影的基础上发展而来的。</p><p>特点：</p><p>“生产 ” 与 “发行、放映” 的政企合一。</p><p>生产：电影生产以指令性的计划指标进行；</p><p>发行、放映：发行放映实行从中央到地方的垂直管理体制。</p><p><strong>中央</strong>——“中国电影发行放映公司”</p><p><strong>地方</strong>——“电影发行放映公司”</p><p>这种模式在计划经济年代保证了电影的经济效益，也保证了电影能够在全国放映，但是中影公司作为唯一拥有独立电影发行权的公司，全国所有制片厂生产的电影，都要交给中影公司统购统销，这种行政性和非市场化的电影产业机制，经过计划经济年代的辉煌之后，其弊端随着改革开放的深入而逐渐显现。</p><p><strong>弊端</strong>：</p><ul><li>由于制片机构没有经营自主权，影片就不能直接面向市场，这样就对形成统一开放、竞争有序的电影市场形成了阻碍。</li><li>由于发行环节过多，各电影厂的收入早已不能维持生产，于是地方电影公司要求 “自主经营、独立核算” 的呼声日益高涨。 </li></ul><h3 id="二-改革的开始"><a href="#二-改革的开始" class="headerlink" title="二 改革的开始"></a>二 改革的开始</h3><p>1993 年 1 月 5 日，时国家广电电影局颁布了《关于当前深化电影行业机制改革的若干意见》，旨在改变之前计划经济下电影的统购统销，调整制片、发行、放映经济效益分配不合理的状况。</p><p>然而，新的问题出现了，尽管中影公司的垄断经营被打破了，但是各个省级电影发行放映公司，却依然在自己的行政区域内独家经营，垄断发行。这样意味着，过去制片厂只需要面对中影这一家垄断经营者，而现在则要面对全国 32 家地方垄断经营者。</p><p>1994 年 8 月 1 日电影局再次下发文件：《关于进一步深化电影行业机制改革的通知》，明确指出拥有电影发行权的机构，可以直接向除 11 个老少边穷省区之外的 21 个省区各级发行单位，直接进行电影发行。</p><p>这些文件的出台，使电影的经营自主权在政策方面得到了认可。</p><h3 id="三-1994-年引进-“十部大片”"><a href="#三-1994-年引进-“十部大片”" class="headerlink" title="三 1994 年引进 “十部大片”"></a>三 1994 年引进 “十部大片”</h3><p>1994 年的 “全国电影发行放映工作会议” 提出：每年要引进十部 “基本反映世界优秀文明成果和基本表现当代电影艺术、技术成就的影片”，即开始了引进电影 “大片” 的时代。</p><p>当你就有一批好莱坞和香港大片，以分账的形式进入内地影院。其中有哈利森·福特主演的《亡命天涯》，作为引进的首部分账大片，以 2500 万的票房成绩创造了内地第一个票房奇迹。</p><p>1995 年，引进十部大片的工作有条不紊的进行着，虽然当年只引进了八部影片，但部部都是经典。</p><ol><li><p>《红番区》</p><ol><li>类型：港美合作的喜剧动作片</li><li>导演：唐季礼导演</li><li>主演：成龙、梅艳芳</li><li>荣誉：荣获了香港电影金像奖</li></ol><p>也是成龙打入美国主流电影市场的里程碑。1995 年 1 月 31 日在内地上映后，很快就以 3500 万的成绩，刷新了内地的电影票房记录。</p><p>《红番区》给内地观众带来了 “贺岁片” 的概念，甚至改变了一直以来春节期间电影院放假关门的状况。</p></li><li><p>《真实的谎言》</p><ol><li><p>导演：詹姆斯·卡梅隆</p></li><li><p>主演：阿诺·施瓦辛格</p><p>影片从隐藏身份的 FBI 特工与妻子琐碎的家庭矛盾入手，在不断的误会和意外下展开正邪的对抗 。作为施瓦辛格的硬汉动作片的巅峰之作，该片场面宏大，气度非凡，且不乏喜剧元素。</p></li></ol></li><li><p>《狮子王》</p><ol><li><p>类型：动画电影</p></li><li><p>荣誉：奥斯卡 “最佳配乐</p><p>​            奥斯卡 “最佳原创歌曲” </p><p>影片的脱胎于哈姆雷特，除了波澜壮阔的情节和成功的人物形象塑造，还有获得奥斯卡最佳配乐、最佳原创歌曲等多首经典电影歌曲。</p></li></ol></li><li><p>《阿甘正传》</p><ol><li><p>主演：汤姆·汉克斯</p></li><li><p>特点：电脑特效的运用</p></li><li><p>荣誉：奥斯卡 “最佳影片奖”</p><p>影片讲述了一个智商只有 75 的低能儿不断奔跑的故事，将真伪历史杂糅于一体，其中对电脑特效的运用堪称经典，这部电影还打败了《肖生克的救赎》获得当年奥斯卡最佳影片奖。</p></li></ol></li><li><p>《廊桥遗梦》</p><ol><li>导演、主演：伊斯特伍德</li></ol><p>这部改编自同名爱情小说的电影，讲述了一段艳而不淫、哀而不伤、既宣泄了激情又照顾了道德的浪漫邂逅。</p></li><li><p>《勇敢者的游戏》</p><ol><li><p>类型：奇幻家庭喜剧</p></li><li><p>主演：罗宾·威廉斯</p></li><li><p>特点：电脑特效</p><p>影片对电脑特效的运用深受《侏罗纪公园》的影响，同时阖家欢乐的定位也非常讨巧。</p></li></ol></li><li><p>《纽约大劫案》</p><ol><li><p>主演：布鲁斯·威利斯</p><p>警察形象被评为 “电影史上最棒的警察”。</p></li></ol></li><li><p>《玩具总动员》</p><p> 是为皮克斯动画打下江山的首功之臣，这也是全世界第一部完全使用电脑技术的动画电影。</p><p> 玩 3 也是我认为这个系列电影的 “最终章”，玩 4 只是给了一些 “惊喜”。</p></li></ol><p>十部大片的引进在活跃中国电影市场的同时，也促使中影公司和各级发行放映公司的改革，并在实行现代企业制度、扩大经营规模、实现院线制等方面都进行了有益的探索。于是中国电影市场终于在 90 年代中期开始复兴，并且也吸引了境内外的大量资金，从而为中国电影的全面产业化发展奠定了必要的基础。</p><h2 id="开启：中国电影的全面产业化"><a href="#开启：中国电影的全面产业化" class="headerlink" title="开启：中国电影的全面产业化"></a>开启：中国电影的全面产业化</h2><h3 id="引进-“大片”"><a href="#引进-“大片”" class="headerlink" title="引进 “大片”"></a>引进 “大片”</h3><p>加入 WTO 后，我国引进电影大片的数量由 10 部增加到 20 部。同时为了限制美国电影的市场占有率，还在 2004 年明确规定引进的这 20 部电影中，必须有 6 部是非美国生产的影片。</p><p>2012 年，引进大片的数量由 20 部增加至 34 部，其票房分成比例也由 13% 调调整到 25%。</p><p>最新的引进进口大片的 “配额制度” 谈判，也从 2017 年就已经展开。</p><h3 id="中国电影-“大片”"><a href="#中国电影-“大片”" class="headerlink" title="中国电影 “大片”"></a>中国电影 “大片”</h3><p>2002 年张艺谋导演的影片《英雄》上映，标志着中国大片时代的到来，伴随而来的还有内地电影市场近十年低靡的终结。</p><p>影片《英雄》讲述战国末期三大刺客欲杀秦王的故事，其从筹备策划到拍摄制作，再到宣传发行都采用了不同于以往的市场化模式，最后《英雄》也以内地票房 2.5 亿元的成绩，创造了国产电影的票房神话。</p><p>随后，张艺谋还拍摄了《十面埋伏》《满城尽带黄金甲》《金陵十三钗》等电影大片，也都票房成绩斐然。2004 年的《十面埋伏》，以《英雄》所开创的 “大明星、大投资、大宣传、高回报“ 模式，让中国电影大片走向了品牌化的时代，从而掀开了中国电影产业发展的新篇章。</p><p>同时，这部电影还与当年王家卫的《2046》冯小刚的《天下无贼》周星驰的《功夫》一起，引发了新世纪中国电影市场的一次高潮。</p><h3 id="中国-“电影院线”"><a href="#中国-“电影院线”" class="headerlink" title="中国 “电影院线”"></a>中国 “电影院线”</h3><p>中国电影在 2002 年开启大片时代的同时，也开始了电影的院线制改革。</p><p>概念：</p><p>电影院线简称 “院线”，是指以影院为依托，以资本和供片为纽带，由一个电影发行主体和若干影院组成的电影发行，放映的经营机制。</p><p>特点：<br>对旗下影院实现统一排片、统一经营、统一管理。</p><p>2002 年我国有 35 条院线正式挂牌营业，这 35 条院线共有影院 1019 座，银幕 1834 块，而在十年后的 2012 年，中国电影院线的银幕数量就已经达到了 13118 块，从 2012 年至今更是发展迅猛，银幕数量也呈爆发式增长。2017 年的银幕总数已经达到了 50776 块，稳居世界第一。</p><p>从 2004 年《关于加快电影产业发展的若干意见》提出 “深化院线制改革” 之后，这种 “统一品牌、统一供片、统一经营、统一管理” 的院线制，就成为了中国电影发行放映的主要方式。而改革后的电影院线，也彻底摆脱了事业单位的属性，成为身份明晰的市场主体。 </p><p>目前我国形成了以十大院线为核心，各省级院线为补充的发展格局。同时全国大多影院都在十大院线的旗下，这十大院线包括：</p><ol><li>万达</li><li>上影联和</li><li>中影星美</li><li>大地</li><li>中影南方新干线</li><li>广州金逸珠江</li><li>浙江时代</li><li>背景新影联</li><li>浙江横店</li><li>中影数字</li></ol><p>与 2002 年院线制改革同时进行的，还有影院的建设与改造，主要是多厅化和数字化。</p><p>我国第一家五星级影院：“北京华星影城” 也在 2002 年 7 月 12 日盛大开业。</p><p>随后上海永乐影城、广州中华广场电影城、深圳新南国影城等多家五星级影城，也纷纷在各大城市出现。</p><h2 id="发展：2003-2013-年的中国电影产业"><a href="#发展：2003-2013-年的中国电影产业" class="headerlink" title="发展：2003-2013 年的中国电影产业"></a>发展：2003-2013 年的中国电影产业</h2><p>在此时期，中国电影产业发展呈现出了一些新的特点 </p><h3 id="一-电影市场规模不断扩大，电影投资多元化"><a href="#一-电影市场规模不断扩大，电影投资多元化" class="headerlink" title="一 电影市场规模不断扩大，电影投资多元化"></a>一 电影市场规模不断扩大，电影投资多元化</h3><p>从 2003 年中国电影开始产业化发展以来，电影市场一直就保持着较大幅度的增长。</p><p>以 2008 年为例，在当年总额 40 多亿的票房成绩中，国产电影就贡献了 25 亿多元，超过总数的 60%。</p><p>《长江七号》《画皮》《功夫之王》《大灌篮》《赤壁》《非诚勿扰》《梅兰芳》等 8 部影片的票房总额就接近 20 亿。</p><p>其中吴宇森导演的《赤壁》，国内票房收入：3亿多元，全球票房收入： 7 亿元人民币</p><p>同时 2008 年上映的国产电影中，有约一半以上都由民营资本参与了投资，关键是之前根本不会考虑对电影行业贷款的银行，也从 2008 年开始将注意力投向中国电影产业。如《画皮》《非诚勿扰》等影片，就是以 “版权抵押” 的方式向银行贷款，从而拓宽了我国电影的融资渠道。</p><h3 id="二-电影产量和票房持续增长"><a href="#二-电影产量和票房持续增长" class="headerlink" title="二 电影产量和票房持续增长"></a>二 电影产量和票房持续增长</h3><p>自中国电影开始全面产业化发展以来，产量和票房的持续增长已经成为了一种常态化的状态。</p><h3 id="三-中小成本电影异军突起"><a href="#三-中小成本电影异军突起" class="headerlink" title="三 中小成本电影异军突起"></a>三 中小成本电影异军突起</h3><p>中国电影进入产业化时代以来，许多中小成本电影也另辟蹊径，以关注社会现实问题的题材优势异军突起。许多影片还取得了出人意料的票房成绩。</p><p>2011 年改编自鲍鲸鲸同名人气小说的 《失恋 33 天》就以 1400 万的投资获得了 3.5 亿元的票房收入，成为中国电影产业发展过程中，中小成本电影异军突起的典型案例。这部影片以亲切不失幽默的方式，讲述了女主角从遭遇失恋到走出心理阴霾的 33 天，作为我国内地首部为光棍节量身打造的治愈系爱情电影，在 2011 年 11 月 8 日上映后 4 天后，票房就突破了亿元大关。 </p><h3 id="四-单片票房-过亿的电影频繁出现"><a href="#四-单片票房-过亿的电影频繁出现" class="headerlink" title="四 单片票房 过亿的电影频繁出现"></a>四 单片票房 过亿的电影频繁出现</h3><p>2010 年中国电影的全年票房首次突破百亿元大关。随后，亿元电影俱乐部的会员不断增加，其中不仅有商业大片，还有很多中小成本的电影也开始拥有过亿的票房。</p><p>如 2012 年的贺岁片《人在囧途之泰囧》，总投资不足 8000 万，票房收入 12.6 亿元。</p><p>2013 年票房排行前十的电影《致我们终将逝去的青春》《北京遇上西雅图》《中国合伙人》（陈可辛导演）等，单片投资都没有过亿，但都轻而易举的获得了过亿的票房收入。</p><h3 id="五-3D-和-IMAX-电影也在快速发展"><a href="#五-3D-和-IMAX-电影也在快速发展" class="headerlink" title="五 3D 和 IMAX 电影也在快速发展"></a>五 3D 和 IMAX 电影也在快速发展</h3><p>2010 年 1 月 21 日，国务院办公厅颁布 “关于促进电影产业繁荣发展的指导意见”，明确指出中国电影产业在 2010 年的发展重点：是大力繁荣创作生产、积极培育新型企业、加强数字影院和电影院线的建设。于是，3D 和 IMAX 就成为了我国数字影院发展的核心。</p><p>2009 年詹姆斯·卡梅隆执导的《阿凡达》作为第一部在我国上映的数字票房赶超胶片票房的影片，不仅展示了 3D 带给了中国电影产业的变化，而且反映出中国电影市场的巨大容量与需求。</p><p>2012 年，“巨幕数字放映系统” 在我国正式开始运营，从而打破了美国电影 IMAX 格式的垄断。此后，我国 3D 数字和 IMAX 巨幕放映设备的普及率不断提高，国产 3D 和 IMAX 电影的制作水平也在不断攀升。仅在 2012 年，就有 12 部国产 3D 电影上映，同时还有《十二生肖》《一九二四》等影片尝试以 IMAX 格式与观众见面。 </p><p>可以说得益于中国电影的全面发展，中国电影产业呈现出蓬勃向上的态势。</p><h2 id="成熟：2013-年至今的中国电影产业"><a href="#成熟：2013-年至今的中国电影产业" class="headerlink" title="成熟：2013 年至今的中国电影产业"></a>成熟：2013 年至今的中国电影产业</h2><p>2013 年至今的中国电影产业不断发展成熟，并在制片发行放映等环节，呈现出更具时代性的特点。</p><p>首先要强调的是，中国电影产业的发展正是得益于国家相关政策的保障，上世纪 90 年代中国电影开始市场化改革之初，正是依赖当时的政策才能够有条不紊的展开。</p><p>在如今产业化发展的新阶段，以 2016 年 11月 7 日颁布的《中华人民共和国电影产业促进法》为代表，这些政策的出台都对我国电影产业的健康发展、电影市场化的规范与完善等起到了基础性的制度保障。</p><p>中国电影产业整体都深受互联网的冲击，电影制片业在这样的背景下，逐渐形成了传统电影公司、互联网电影公司，以及与互联网公司合作的众多中小型电影公司并立的格局。</p><p>”传统电影公司“ 主要以 “中影” “华谊” “光线“ ”博纳” “万达” 等为代表。</p><p>“互联网电影公司” 主要以 “阿里” “腾讯” “爱奇艺” 等为代表。这些公司都是近年活跃在中国电影制片业中的主力。</p><p>互联网不仅深刻的影响着电影制片，而且在相当程度上颠覆了传统的电影发行，长期以来，我国电影发行都只是依靠推广宣传扩大营销的覆盖范围。但这种方式的弊端，大城市进行宣传相对容易，在数量庞大的中小城市则相对比较困难。</p><p>“互联网+” 电影：充分利用互联网无处不在覆盖范围与影响力，在中小城市实现比较充分的营销渗透。甚至近年的中国电影中还出现了一种被称为自来水的现象。</p><p>“自来水”，意为 “自发而来的水军”，最早出现于 2015 年的电影 《西游记之大圣归来》。</p><p>当初，影片上映时，有数万名网友自发形成了自来水，为这部国产电影摇旗呐喊，给影片带来了高口碑和高票房。该票最高单日票房为 4000 万，即打破了国产动画电影的单日票房记录，最终总票房也高达 9.56 亿元，是我国票房最高的动画电影（在当时是，《哪吒》改变了这个，是 50亿）。</p><p>近年中国电影的放映情况来说，呈现出观看电影成为常态，电影放映高峰频繁出现的特点。</p><p>一方面，看电影已经成为国人的一种日常行为与消费习惯。</p><p>另一方面，目前中国电影放映的高峰期不仅有传统的 “贺岁档”，全绝大部分时间的放映都比较稳定，同时春节、国庆等假期在家庭观影的推动下，也已经成为电影消费的集中爆发期。</p><p>暑假期间还由于大量学生的观影群体，使得每年七八月份亦成为电影放映的高峰。</p><p> 2018 年 “暑期档” 我国电影总票房就高达 173.8 亿元，超越 2017 年同期，票房超过了 10 亿。</p><p>其中《一出好戏》《巨齿鲨》《侏罗纪世界2》等口碑较好的影片，票房都超过了 10 亿。</p><p>而《<strong>我不是药神</strong>》和《<strong>西虹市首富</strong>》两部影片的票房，则分别高达 30.98 亿和 25.19 亿。</p><p>总体来说，中国电影产业在近年的发展中，以 “武侠片” “喜剧片” “爱情片” 等传统优势类型片为主，同时兼顾更为多元的类型电影创作，旨在促进中国电影的全面健康发展。</p><p>尤其是长期以来受编剧水平和技术能力限制，一直都是进口片的主场的魔幻、奇幻、科幻的 “三幻” 类型影片，从 2014 年开始整体爆发，其中以 “三体” 为代表的中国科幻电影的横空出世，标志着中国电影产业发展的新高度。</p><h1 id="最后我的补充"><a href="#最后我的补充" class="headerlink" title="最后我的补充"></a>最后我的补充</h1><h2 id="从这些课中，推荐值得看的电影"><a href="#从这些课中，推荐值得看的电影" class="headerlink" title="从这些课中，推荐值得看的电影"></a>从这些课中，推荐值得看的电影</h2><ul><li>《红气球》</li><li>《我不是潘金莲》</li><li>《大话西游》</li><li>《布达佩斯大饭店》</li><li>《阿甘正传》</li><li>《亲爱的》</li><li>《罗生门》</li><li>《重庆森林》</li><li>《敦刻尔克》</li><li>《罗拉快跑》</li><li>《雨中曲》</li><li>《名扬四海》</li><li>《音乐之声》</li><li>《被解救的姜戈》</li><li>《天堂之门》</li><li>《盗马贼》</li><li>《可可西里》</li><li>《无人区》</li><li>《罗马假日》</li><li>《驴得水》</li><li>《甲方乙方》</li><li>《不见不散》</li><li>《没完没了》</li><li>《私人订制》</li><li>《发条橙》。。。。</li><li>《毕业生》</li><li>《寂静之声》</li><li>《醉拳》</li><li>《警察故事》</li><li>《蛇形刁手》</li><li>《喜剧之王》</li><li>《食神》</li><li>《少林足球》</li><li>《疯狂的石头》</li><li>《疯狂的赛车》</li><li>《唐人街探案1》</li><li>《杀死比尔》</li><li>《精武门》</li><li>《龙争虎斗》</li><li>《猛龙过江》</li><li>《十面埋伏》</li><li>《龙门客栈》</li><li>《这个杀手不太冷》</li><li>《公民凯恩》</li><li>《阿飞正传》</li><li>《东邪西毒》</li><li>《重庆森林》</li><li>《堕落天使》</li><li>《春光乍泄》</li><li>《花样年华》</li><li>《王牌特工·特工学院》</li><li>《持摄影机的人》</li><li>《辛德勒的名单》</li><li>《偷自行车的人》</li><li>《广岛之恋》</li><li>《默片解说员》</li><li>《你的名字》</li><li>《彼岸花》</li><li>《秋刀鱼之味》</li><li>《那年夏天，宁静的海》</li><li>《菊次郎的夏天》</li><li>《似水流年》</li><li>《恋恋风尘》</li><li>《拯救大兵瑞恩》</li><li>《慕尼黑惨案》</li><li>《E.T》</li><li>《泰坦尼克号》</li><li>《红番区》</li><li>《玩具总动员》系列</li><li>《非诚勿扰》</li><li>《人在囧途之泰囧》</li><li>《中国合伙人》</li><li>《阿凡达》</li><li>《我不是药神》</li><li>《西虹市首富》</li></ul><p>当然，这些只是课程的一部分，更多的自己去搜，自己动手。</p><h2 id="电影批评入门资源"><a href="#电影批评入门资源" class="headerlink" title="电影批评入门资源"></a>电影批评入门资源</h2><p>《电影艺术：形式与风格》——必看</p><p>《认识电影》</p><p>《电影批评》——戴锦华（北京大学教授，博士生导师，Bilibili 也有很多她的课，微信读书上也有她的书，我买的是纸质版的）</p><p>《电影语言的语法》</p><p><a href="https://www.bilibili.com/video/BV1nK411K72S" target="_blank" rel="noopener">周传基讲电影6套视频合集视频</a></p><p><a href="https://www.bilibili.com/video/BV1jv4y1Z76k?from=search&seid=6562124160217285283" target="_blank" rel="noopener">《让子弹飞》拉片</a>——拉片的是位导演，也可以看看他的其它作品</p><hr/><p><strong>会持续更新的</strong></p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>明确一个基本事实，电影≠故事片。进行电影批评，需要你大量的阅片，以及相应书籍的观看，以及导演的部分背景，才能更好的进行电影批评/鉴赏。</p><p>例如《<strong>你好，李焕英</strong>》是贾玲自导自演的一部电影，其中冯巩是贾玲的师傅，客串了一下，活跃下气氛（我想死你们了）。其中 1980年的《庐山恋》是“<a href="https://zh.wikipedia.org/wiki/文革" target="_blank" rel="noopener">文革</a>”后中国首部爱情为主题的电影，并且出现了当时<strong>罕见的吻戏</strong>，符合当时的剧情设定。你现在去庐山，那里应该还有在放，我去过庐山两次了。该片其实很大程度上和《<strong>夏洛特烦恼</strong>》类似，整体采用的高调光（往上搜高调光），喜剧片常用，没有做大的改变，整体内容和这个电影差不太多。也是贾玲作为导演的第一部作品，沿用已有成熟的框架，是最好也是最稳妥的选择。<a href="https://www.youtube.com/watch?v=uq00P0c_t4o" target="_blank" rel="noopener">影片事件其实可以再丰富些，让部分事件紧凑些。影片做得朴实无华，但真挚真诚</a>。</p><p>没看过这两部电影的，可以在不忙的时候<strong>偶尔看看</strong>。</p><p>国内的一些资源足够了，Youtube 上也是有更多资源的，等你自己搜。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="film" scheme="https://young1lin.github.io/tags/film/"/>
    
  </entry>
  
  <entry>
    <title>Youtube 看不了评论</title>
    <link href="https://young1lin.github.io/2021/05/17/YoutubeComments/"/>
    <id>https://young1lin.github.io/2021/05/17/YoutubeComments/</id>
    <published>2021-05-16T16:00:00.000Z</published>
    <updated>2021-06-13T16:15:36.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Youtube 看不了评论，一直在转圈圈。</p><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><p>清除 Youtube 所有 Cookie，退出谷歌浏览器，再进。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>如果还是不行，看看是不是无痕模式下可以看评论，如果可以，把所有插件关了，再重启浏览器。油猴的插件部分有问题。</p><h1 id="终极"><a href="#终极" class="headerlink" title="终极"></a>终极</h1><p>搜索 <code>重置设置</code>，重设浏览器，彻底退出谷歌浏览器，再重新登录 Youtube，评论即可看到了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="other" scheme="https://young1lin.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>云顶之弈如何从零到最强王者</title>
    <link href="https://young1lin.github.io/2020/12/18/TFT/"/>
    <id>https://young1lin.github.io/2020/12/18/TFT/</id>
    <published>2020-12-17T16:00:00.000Z</published>
    <updated>2022-09-05T14:40:31.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我玩了比较久的云顶之弈，也<strong>“间接开发”过阵容</strong>，就是 S3 最火热的 6 暗星羊刀水银泽拉斯。最快两天从水晶之痕没有段位到超凡大师（后面排到人比较慢，不愿玩，而且段位提升只是把数的堆积）。我也是美服以及艾欧尼亚两个赛季超凡大师，最高到一区前 200 名左右吧，3 月 26 日左右（具体几号真忘了）早上8 点斗鱼、卷子的第一把，和南波儿的两个小弟的7点多到8点那一把的录播视频为证。</p><p>只要你时间够，上个王者不成问题。后面比较喜欢玩 PBE（测试服），提前感受版本，厄加特的大招开始是<strong>没有写明</strong>无视复活甲的，也是我向官方报告的 “bug”，后面官方改了技能说明，之前的英文介绍里面没有 GA（Guardian Angel）。其他的大家都知道的 bug，我也不愿向官方反馈。</p><p>第三个，仅需两天（一天16个小时左右），50 多把即可从零上超凡大师，多的 8 把左右是打的维护赛。</p><p>玩游戏也是要学习的，也是要动脑子的，只有不断进步，不断精进，才能更好去玩游戏。其他的下棋类的游戏，我也玩过，其实 TFT 大多都是抄 Dota 自走棋的，做得越来越像了，只不过简化了而已。</p><div class="tabs" id="content-1"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-1-1">美服</button></li><li class="tab"><button data-href="#content-1-2">国服一区</button></li><li class="tab"><button data-href="#content-1-3">国服十四区</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-1-1"><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/YzTqi82tJWLOU6S.png" alt="s2 NorthAmerica.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-2"><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/iH3DsZJdWEwvkNh.png" alt="国服一区.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-3"><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/kQhUvrixLZ3CjKe.png" alt="国服14区.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>这里主要讲些基础按键，以及鼠标操作“抢”英雄，抢装备。</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>D 牌，换下一轮牌。D 一次需要 2 金币，具体几费英雄概率，看右下角</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>升级，在左下角有对应的当前经验以及升级所需经验。一次升级需要 4 金币，一级对应着可以上一人口，8 级代表至少可以上 8 人口。3-2 和 4-1 是一些快节奏的上人口搜排阵容时间。例如法师，3-2 升 6，D 牌，4-1 升7 D牌，靠质量和血量赢，这就意味着 2 阶段不能乱升级，最大化保留经济。</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>鼠标光标对准某个英雄后，再按 E 可以卖出该英雄。</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>按住，可以选择秀表情。</p><h3 id="1、3"><a href="#1、3" class="headerlink" title="1、3"></a>1、3</h3><p>查看对手动态。1 表示前驱召唤师，即右下角小地图你的前驱召唤师，继续按，继续是前驱召唤师的前驱召唤师，以此类推，3 则相反。后面有高级教程展示如果使用按键，来达到逆转游戏战果的玩法。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>可以打开 ESC 查看对应按键。</p><h2 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h2><h3 id="移动预测"><a href="#移动预测" class="headerlink" title="移动预测"></a>移动预测</h3><p>对于老手，可以不开，没必要。在 Esc 按键【控制】那里，打开移动预测。配合按键移动，你可以设置 B 键来和鼠标右键配合一起使用，再加上移动预测，开局 1-1 没人抢得过你。</p><h3 id="点击头像"><a href="#点击头像" class="headerlink" title="点击头像"></a>点击头像</h3><p>点击对应头像可以查看其他召唤师的具体阵容摆放。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>左键点击场上英雄，按 3 或 1 切换视角，即可实时躲掉对方灵风、射线等功能装备影响。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p><strong>不要给单件装备！！！</strong>除非你全部都二星英雄了，并且有思路，替换阵容，在哪个阶段替换该英雄。</p><h2 id="装备（Items）"><a href="#装备（Items）" class="headerlink" title="装备（Items）"></a>装备（Items）</h2><p>为了让游戏更加 “<strong>公平</strong>”。TFT 在每局 1阶段的三回合都会至少保证你有 3 件散件（当然也有可能爆钱 +2件），这 3 件包含了选秀的一件。</p><p>公平，公平，还是他妈的公平。—— 《让子弹飞》</p><h3 id="核心装备"><a href="#核心装备" class="headerlink" title="核心装备"></a>核心装备</h3><p>一个阵容的核心英雄（Champion） <strong>往往有着一至多件核心装备</strong>，才能完美地发挥它的作用。根据核心装备，从 3 阶段确定大致阵容方向，<strong>临时变换阵容，往往会付出惨痛的代价</strong>。</p><p>例如</p><ul><li><p>阿卡丽的蓝 BUFF + 火炮 + 无尽；</p></li><li><p>卡特的科技枪；</p></li><li><p>莫甘娜的鬼书；</p></li><li><p>奥拉夫的火炮 +飓风；</p></li><li><p>霞的巨人杀手 + 正义之手 + 饮血剑。</p></li></ul><h3 id="次选装备"><a href="#次选装备" class="headerlink" title="次选装备"></a>次选装备</h3><p>非核心装备，属于可替换的类型。</p><p>例如 </p><ul><li>卡特的泰坦可以换成反甲；</li><li>奥拉夫的杀人剑可以换成复活甲；</li><li>莫甘娜也可以用上巨人杀手。</li></ul><h3 id="通用装备"><a href="#通用装备" class="headerlink" title="通用装备"></a>通用装备</h3><p>任何英雄都可以装备，并且前中期有着不错的表现。一般这种装备是用来过渡的，并且后期【能用】。</p><p>例如 </p><ul><li>日炎</li><li>离子火花</li><li>巨人杀手</li><li>冰心</li><li>狂徒</li><li>正义之手</li><li>荆刺背心</li><li>泰坦的坚决</li><li>窃贼手套🧤（又名偷偷）</li><li>圣杯</li><li>旗子</li><li>灵风</li><li>静止法衣（卑鄙射线）多为游戏后期出奇制胜使用</li></ul><h4 id="功能型装备"><a href="#功能型装备" class="headerlink" title="功能型装备"></a>功能型装备</h4><p>顾名思义，是为了实现一些功能的装备。例如将地方关键性英雄 “移出” 当前对局 5 秒。其实一句话可以概括，恶心对面的装备。</p><ul><li>灵风</li><li>静止法衣</li><li>伏击之爪</li><li>冰心</li><li>鸟盾</li><li>救赎</li><li>兹若特传送门</li><li>最后的轻语</li><li>离子火花</li></ul><h3 id="前期装备"><a href="#前期装备" class="headerlink" title="前期装备"></a>前期装备</h3><p>这里说的是，纯前期装备。</p><p>有些装备前期很强势，后期伤害不高。例如日炎、灵风（是的，前期合灵风也是可以的，摆得好，可以让地方关键性英雄无法输出，进而赢下当前回合），离子火花。</p><h3 id="装备如何给"><a href="#装备如何给" class="headerlink" title="装备如何给"></a>装备如何给</h3><p>不同赛季，有不同打法。云顶越来越偏快节奏，所以，如果你想在前期连胜，你必须从三个散件中合成一个成装，才有可能打出连胜（当然卡的质量也十分重要）。如果你不确定是玩什么阵容，2 阶段可以暂时不给装备，但是为了稳住血量，你必须在 3 阶段给出至少 1-2 件成装，来确定你的阵容。</p><p>当然，前期的连胜不代表你能吃鸡，或者前四。这种前期合高质量怪，给成装的【保血量打法】，只有在打比赛和赛季初的时候适用。有些时候，经济和运气决定了你的排名。</p><p>如果你想前期连胜，又不想太早确定阵容，那么【通用装备】的合成就是你的不二选择，例如【离子火花】、【日炎】等。3-3 必须确定几个大概的阵容方向，当然，如果你血量很高，经济很好，还可以再推迟几回合确定阵容。</p><p>【<strong>云顶是以装备为核心的游戏</strong>】。质量固然重要，合适的装备，能让质量卡提升不止一倍的战力。当然，有一种情况例外，你的质量很高，运气很好，牌很糊，装备随便给都有分。</p><h2 id="英雄（Champion）"><a href="#英雄（Champion）" class="headerlink" title="英雄（Champion）"></a>英雄（Champion）</h2><h3 id="英雄分类"><a href="#英雄分类" class="headerlink" title="英雄分类"></a>英雄分类</h3><ol><li>输出型 —— 例如神射手所有，大部分法师等。</li><li>坦克型 —— 斗士、重装类英雄，还有安妮等。</li><li>功能型 —— 例如风女、蛇女、盲僧、沙皇等。</li></ol><p><strong>一个良好的阵容，必定有这三种英雄，每种至少一个</strong>。这是必然的，取长补短，每个英雄擅长的位置不同。任何极化的阵容，都将被版本所制裁。并且一个良好的阵容，总是有人很有用，有些英雄表现很一般，这是无法避免的。</p><p>上面的介绍，在这个赛季稍微改了点。</p><p>下面是 4.0 版本推荐阵容，可以看看各自对应的。来自 <a href="https://lol.qq.com/tft/#/index" target="_blank" rel="noopener">https://lol.qq.com/tft/#/index</a></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/TAIoBiKMepV1gEt.png" alt="image.png"></p><h3 id="核心英雄"><a href="#核心英雄" class="headerlink" title="核心英雄"></a>核心英雄</h3><p>每个阵容，都有一些核心英雄。</p><p>例如 6 三国中的卡特，6 天神中的狼人，忍刺中的阿卡丽。他们基本都属于输出型英雄，很少有坦克/功能型英雄能够担任核心英雄。</p><p>核心英雄的三大特征。</p><ol><li>贵（贵就意味着更好的的属性，以及更大范围/高伤害的技能）</li><li>星等高</li><li>输出型英雄</li></ol><p><strong>所有核心英雄，必须满足其中两个及以上条件。</strong></p><h3 id="可替换（打工）英雄"><a href="#可替换（打工）英雄" class="headerlink" title="可替换（打工）英雄"></a>可替换（打工）英雄</h3><p>在一个终极阵容成型之前，一定有装备需要别人去穿戴，不然血量会掉得非常快。每个版本会尽量控制不让出现特别突出的阵容，让每个阵容都有上场的可能。</p><h2 id="阵容（Comps）"><a href="#阵容（Comps）" class="headerlink" title="阵容（Comps）"></a>阵容（Comps）</h2><h3 id="T0-阵容"><a href="#T0-阵容" class="headerlink" title="T0 阵容"></a>T0 阵容</h3><p>每个版本都有些其特定的非常强势的阵容，这是必然的。不然也不会说更新版本了。T0 阵容，根据装备和来的英雄来尽量往着方面来靠。这是上分的一个小技巧。</p><h3 id="烂分阵容"><a href="#烂分阵容" class="headerlink" title="烂分阵容"></a>烂分阵容</h3><p>故名思义，这种阵容比较难吃鸡，但是能靠着前期的质量和血量来🐶个烂分的阵容。例如一代版本一代神，代代版本玩法师，法师永远是你烂分的不二选择。前提是比较多的基础牌和合适的装备。</p><h2 id="利息"><a href="#利息" class="headerlink" title="利息"></a>利息</h2><p>云顶之弈会每回合固定给你发 5 块</p><h3 id="连胜-or-连败？"><a href="#连胜-or-连败？" class="headerlink" title="连胜 or 连败？"></a>连胜 or 连败？</h3><p>能连胜就连胜，连败也可以，不过 5 连败和 4 连败进野怪，前者是 6 块起步，后者是 4 块，还不 2 阶段理财的利息。合理的权衡血量和金币。</p><h3 id="存-50-再-D？"><a href="#存-50-再-D？" class="headerlink" title="存 50 再 D？"></a>存 50 再 D？</h3><p>看情况的，不一定这么绝对。</p><h2 id="每回合情况"><a href="#每回合情况" class="headerlink" title="每回合情况"></a>每回合情况</h2><h3 id="扣血规则"><a href="#扣血规则" class="headerlink" title="扣血规则"></a>扣血规则</h3><h3 id="轮次（即下一轮遇到谁）"><a href="#轮次（即下一轮遇到谁）" class="headerlink" title="轮次（即下一轮遇到谁）"></a>轮次（即下一轮遇到谁）</h3><p>在下面的对位中有介绍，根据不同的赛季，对位规则是会变换的。但总的规则是不会变的，还是为了公平，你不会想 2-1 碰弱的，3-1 碰非常强的，2 阶段和 3 阶段碰到人完全不一样吧？这样会导致一种情况，如果碰到的人全部不一样，眉笔会一直输，直到 3 阶段结束，只剩一丝血。</p><p>还是为了公平，每个阶段碰到的人，位置变换不会太大。只会抽选其中两个回合换人。</p><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><h3 id="为什么相同血量，别人比我先出来？"><a href="#为什么相同血量，别人比我先出来？" class="headerlink" title="为什么相同血量，别人比我先出来？"></a>为什么相同血量，别人比我先出来？</h3><p>这是规则，看你上一回合扣血的多少，决定了你先出来，还是后出来。</p><p><strong>一个简单的判别，就是你的正对面是血量低还是高的，如果是低的，你就先出来</strong>。最新的版本已经改了这个 “Bug” 了，你可以直接看排名来判断自己什么时候 “出圈”。</p><h1 id="高阶"><a href="#高阶" class="headerlink" title="高阶"></a>高阶</h1><h2 id="保持血量还是优先装备？"><a href="#保持血量还是优先装备？" class="headerlink" title="保持血量还是优先装备？"></a>保持血量还是优先装备？</h2><h2 id="对位（轮次）"><a href="#对位（轮次）" class="headerlink" title="对位（轮次）"></a>对位（轮次）</h2><p>云顶对位机制<strong>只有两套</strong>，从 S1 到现在。现在已经变了，需要你自己玩几把摸索，就那个排法。</p><p>第一套</p><p>2-1，2-3，2-6，和 3-1，3-3，3-6 对位是相同的，也就是遇到的玩家是一样的。那么 2-2，2-5 和 3-3，3-5 遇到的玩家是不同的。</p><p>如下图所示。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/OkXo9pfZUWrcNxm.png" alt="云顶对位.png"></p><h2 id="F-还是-D？"><a href="#F-还是-D？" class="headerlink" title="F 还是 D？"></a>F 还是 D？</h2><p>视情况而定，之后详细介绍。</p><h2 id="卡牌"><a href="#卡牌" class="headerlink" title="卡牌"></a>卡牌</h2><p>相同英雄，在卡池里的数量。</p><table><thead><tr><th align="center">英雄费用</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">29</td></tr><tr><td align="center">2</td><td align="center">22</td></tr><tr><td align="center">3</td><td align="center">16</td></tr><tr><td align="center">4</td><td align="center">12</td></tr><tr><td align="center">5</td><td align="center">10</td></tr></tbody></table><p>这里的数量是指本局游戏，所有玩家可见这个英雄的情况。</p><p>也就是说场上“<strong>最多</strong>”</p><ul><li>只可能出现 3 家同样的<strong>三星一费</strong>英雄</li><li>只可能出现 2 家同样的<strong>三星二费</strong>英雄</li><li>只可能出现 1 家同样的<strong>三星三费</strong>英雄</li><li>只可能出现 1 家同样的<strong>三星四费</strong>英雄</li><li>只可能出现 1 家同样的<strong>三星五费</strong>英雄</li></ul><p>当然，这有例外，如果你的<strong>妮蔻之助</strong>非常多，也是可以变出来的。以前是场上没有该英雄了，用了妮蔻也会弹出来，现在更人性化一点，防止“栽种” 卡别人牌，导致英雄一直三星不了。</p><p>一般我是不推荐这种事情的，比较 “缺德”，但是高分局必须这样，尽可能让对手难受，让自己“舒服”。外服并不是和和气气的，也有 Fu@k 别人的，上来一顿问候的，高端局也有的。</p><p>生活就是这样，这很正常。我们在成长的过程中习得的一个责任就是，在别人使我们的生活变得更艰难前，我们不得不使他们的生活更加艰难。</p><p>—— 那不勒斯四部曲第一部《我的天才女友》p21</p><h2 id="实时换位、换装备"><a href="#实时换位、换装备" class="headerlink" title="实时换位、换装备"></a>实时换位、换装备</h2><p>左键选中英雄，按 1，3 切换核心英雄站位，一般该技巧用于后期决战部分。</p><h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><h3 id="国内官方网站"><a href="#国内官方网站" class="headerlink" title="国内官方网站"></a>国内官方网站</h3><p><a href="https://101.qq.com/?ADTAG=cooperation.glzx.web" target="_blank" rel="noopener">https://101.qq.com/?ADTAG=cooperation.glzx.web</a></p><h3 id="国外比较推荐的几个"><a href="#国外比较推荐的几个" class="headerlink" title="国外比较推荐的几个"></a>国外比较推荐的几个</h3><ol><li>最常用</li></ol><p><a href="javascript:void(0);">https://tftactics.gg/tierlist/team-comps</a></p><ol start="2"><li>第二常用的</li></ol><p><a href="javascript:void(0);">https://app.mobalytics.gg/tft/set5/team-comps</a></p><ol start="3"><li>这个也可以搜索自己的外服战绩</li></ol><p><a href="javascript:void(0);">https://lolchess.gg/tft/5.0</a></p><ol start="4"><li>不常用</li></ol><p><a href="javascript:void(0);">https://www.leagueofgraphs.com/tft/comps/master</a></p><h1 id="设计师"><a href="#设计师" class="headerlink" title="设计师"></a>设计师</h1><p>设计师推特—— <a href="https://twitter.com/Mortdog?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor" target="_blank" rel="noopener">Mortdog</a></p><p>如果觉得版本变动很烂，你知道该怎么做。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说白了，上分就是根据版本变动，利用信息差，来实现轻松上分，到了版本更新后的中期，就靠运气+运营+掌握的阵容的数量。</p><p>只有不停的练习，不停的重复这些阵容，你才能融会贯通，任何学习也是如此，重复才是真神，当然重复的过程中也需要思考，需要跳脱当前思维的局限性，从更宏大的视角审视自己走过的路/玩过的对局。一定要边玩，边校正自己。</p><p>只有永远在路上的人，才不会迷茫，走得更远。引申至《拿破仑》</p><p><strong>一开始就知道自己要去往何方的人，往往走不远</strong> ——《拿破仑》</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="TFT" scheme="https://young1lin.github.io/tags/TFT/"/>
    
    <category term="LOL" scheme="https://young1lin.github.io/tags/LOL/"/>
    
  </entry>
  
  <entry>
    <title>技术&quot;内幕&quot;</title>
    <link href="https://young1lin.github.io/2020/12/03/technical-insider/"/>
    <id>https://young1lin.github.io/2020/12/03/technical-insider/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2022-09-05T14:39:51.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有趣，但无用的知识系列。</p><h1 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h1><p>由 <a href="https://en.wikipedia.org/wiki/Ron_Rivest" target="_blank" rel="noopener">Ron Rivest</a>, <a href="https://en.wikipedia.org/wiki/Adi_Shamir" target="_blank" rel="noopener">Adi Shamir</a>, and <a href="https://en.wikipedia.org/wiki/Leonard_Adleman" target="_blank" rel="noopener">Leonard Adleman</a> 三位的姓首字母写的。</p><h1 id="《Cloud-Native-Java》"><a href="#《Cloud-Native-Java》" class="headerlink" title="《Cloud Native Java》"></a>《Cloud Native Java》</h1><p>爪哇岛，岛上盛产咖啡；美国人有多爱喝咖啡，看英国人有多爱喝茶一样，波士顿倾茶事件，彻底惹怒了大英帝国（以前的称呼）。看看《硅谷》这部剧就知道了，咖啡 = 命，没有咖啡机的公司，不去。《Cloud Native Java》Josh Long 写的，书封面有几种意思，</p><ol><li><p>这个鸟是蓝耳翠鸟（Alcedo menintiong）濒危野生动物，希望能唤起大家对动物的保护之心。当然，《高性能 MySQL》也是一样。</p></li><li><p>这个鸟在 Java island（爪哇岛）上生存。</p></li><li><p>鸟在天上飞，飞向云端的意思。迎合了云原生的概念，鸟就寓意为 Java，Cloud  就是云，如鱼得水，如鸟入天空。</p></li></ol><p>具体的可以看他的视频 <a href="https://www.youtube.com/watch?v=Z5q-CXbvM1E&amp;t=307s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Z5q-CXbvM1E&amp;t=307s</a> 他自己介绍的。</p><p>关于爪哇岛的，在印尼还是比较发达的，而且上面有华人，而且不准看中文，我是在《枪炮、病菌与钢铁》中看到的，一本不错的书籍，还有《自私的基因》。</p><h1 id="O’reilly-系列图书"><a href="#O’reilly-系列图书" class="headerlink" title="O’reilly 系列图书"></a>O’reilly 系列图书</h1><p>《高性能 MySQL》</p><p>《设计数据密集型应用》</p><p>《机器学习实战》</p><p>等等，大部分书籍都是以濒危物种作为封面的，主要一方面是呼吁大家珍惜动物，这些动物对世界很重要。</p><p>具体可以看 animals.oreilly.com 网站查看。</p><h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p>Snowflake 没有一片雪花是相同的。</p><h1 id="银弹"><a href="#银弹" class="headerlink" title="银弹"></a>银弹</h1><p>在 20 世纪 80 年代中期，Fred Brooks 发表了著名的论文《没有银弹：软件工程的本质性与附属性工作》。在介绍中，他将软件项目比作狼人。</p><p>“我们熟悉的软件项目都有这样的特点（至少在非技术经理看来是这样的），通常是无辜而直接的，但是它却有可能成为一个错过进度、挥霍预算并且产品有缺陷的怪物。因此，我们听到了迫切需要银弹的呼声，希望能让软件成本像计算机硬件成本那样迅速下降”。</p><p>他认为，由于软件开发的本质，在软件开发中没有银弹。这本身就是一项内在复杂的努力。在 20 世纪 80 年代，大多数软件都运行在单台只有单核处理器的机器上，互联网还处于早期发展阶段，智能手机也还属于遥远的未来，没有人听说过虚拟化或云计算。Brooks 写的主要是技术复杂性，现在我们更加意识到软件开发中所涉及的社会、心理和商业过程的复杂性。</p><p>在古老的传说里。狼人是不死的。想要杀死狼人有几种方法：</p><ol><li>像杀死吸血鬼那样用木桩钉权住狼人的心脏。</li><li>将月光遮住</li><li>用银子做的子弹射穿狼人的心脏或头</li></ol><p>当然现实中是没有狼人的。但现实中确实有银弹这个东西。而其意义也类似于能杀死狼人的最好办法。现实中的狼人可以是一个棘手的项目，或者一件不可能的事。而“银弹”就是指能解决这些事的方法，或者技术手段。</p><p>《没有银弹》主张并断言在未来的十年之内（从1986年文章发表后开始计算），不会有任何单一的软件工程上的突破，能够让程序设计的生产力得到一个数量级的提升。不过，作者认为这个假设现在已不再成立。</p><p>假设软件开发的总工作量为 10，其中，本质性工作占掉 1，附属性工作占掉 9，那么改善附属性工作，将之消除，就可以把软件工作量减轻到 1（因为附属性工作变成 0），此时我们可以说，软件工作开发的轻松程度提升了一个数量级（因为由 10 进步到 1，差 10 倍）。</p><p><a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9" target="_blank" rel="noopener">没有银弹 wiki</a></p><p>古代人认为狼人、吸血鬼怕银器，故有银制十字架，银弹等物件。</p><h1 id="关于淘宝"><a href="#关于淘宝" class="headerlink" title="关于淘宝"></a>关于淘宝</h1><p>淘宝最初是买来的，采用的 LAMP（Linux+Apache+MySQL+PHP）架构</p><p>了解淘宝历史的人都知道淘宝是在2003年5月10日上线的，2003年4月7日到5月10日，这之间只有一个月时间。要是你在这个团队里，你怎么做？不是“抄一个来”，我们的答案是——“买一个来”。</p><p>当时我们是从一个美国人那里买来的一个网站系统，这个系统的名字叫做PHPAuction（其官方网站http∶//<a href="http://www.phpauction" target="_blank" rel="noopener">www.phpauction</a>. net，Auction即是拍卖的意思，这个名字很直白，一眼就可看出这个系统是用什么语言做的、用途是什么），PHPAuction有好几个版本，我们买的是最高版的，功能比较多，而且最重要的是对方提供了源代码。最高的版本比较贵，花了我们差不多2000美元（貌似现在降价了，只要946美元，在他们的网站上有明码标价的信息）。买来之后不是直接就能用的，需要很多本地化的修改，例如，修改一些数据类型，增加后台管理的功能，页面模板改得漂亮一点，页眉和页脚加上自己的站点简介等。其中最有技术含量的是对数据库进行了一个修改，原来是从一个数据库进行所有的读写操作，现在把它拆分成一个主库、两个从库，并且读写分离。</p><p>——<a href="https://weread.qq.com/web/reader/016324b05a617e01617778fk16732dc0161679091c5aeb1" target="_blank" rel="noopener">《淘宝技术这十年》</a></p><h1 id="Oracle、Python"><a href="#Oracle、Python" class="headerlink" title="Oracle、Python"></a>Oracle、Python</h1><p>在古希腊神话中，于雅典的北边，有一个地方，住着一条龙形巨蟒，叫皮同（Python）。这宙斯的儿子阿波罗（Apollo）和 Python 有点个人恩怨，他就来到此地，用弓箭射杀了巨蟒。后来，阿波罗在此地德尔菲建立了他的神社，即【阿波罗神殿】。</p><p>阿波罗还从巨蟒那，抢来一女祭司，这女的就是 Oracle。阿波罗的神谕者：皮提亚（Pythia）。</p><p>Oracle 是个职位名称，神可以通过他们向凡间传达旨意或者话语，就是神谕者。在古希腊神话里，有很多的神谕者（几乎为男性），宙斯有宙斯神谕者，而阿波罗的神谕是最著名的一位，她的出场率非常高，而这个神谕换了一个又一个，每个必须是女的。她坐在神社的一个三角凳上，地面有裂缝，缝里面冒出的是火山熔岩产生的烟，也有说是巨蟒（Python）尸体腐烂后生成的烟，吸了这些烟，神谕会进入一种神志恍惚的状态。这被认为是阿波罗占据神谕，借用她的身体说话的时候。</p><p><img src= "/img/loading.gif" data-src="https://www.worldhistory.org/img/r/p/500x600/186.jpg?v=1628028003" alt=""></p><p>在古希腊历史里，就有各路人，远道而来拜访德尔菲的神谕，咨询大大小小的事情。关于爱情、婚姻、人生，关于战争、未来决策等，说白了大家就是让这个神谕给个【预言、忠告】。神谕有时候会给出直白的预言，有时候就爱讲谜语。听者得自己开窍，破解谜语。经典例子如下：</p><p>吕底亚的一个国王，曾找德尔菲的神谕咨询：我该不该攻打波斯帝国。神谕说：“If you cross the river, a great empire will be destroyed” 如果你跨河（进攻）一个帝国将会被毁灭。这国王就把预言中的帝国理解成波斯帝国，于是就攻打，最后被灭的是他自己的帝国。</p><p>在德尔菲阿波罗神殿的石柱、石块上可以看到很多刻下的话语，这些话语被叫做德尔菲的箴言。其中最著名的是刻在入口处的三句。</p><ol><li>认识你自己（古希腊 γνῶθι σεαυτόν，英语 Know thyself、拉丁语 Temet nosce）</li><li>凡事勿过度（Nothing in excess）</li><li>妄立誓则祸近(Commitment/Certainty brings ruin)</li></ol><p>其中，认识你自己在哲学家苏格拉底出现前，就刻在上面了，而它也是苏格拉底最经典的格言之一。</p><blockquote><p>认识自己的无知，是最大的智慧——苏格拉底</p></blockquote><p>The Delphic Oracle said I was the wisest of all the Greeks. It is because that I alone, of all the Greeks, know that I know nothing.</p><p>德尔菲的神谕者说我是最聪明智慧的希腊人、那是因为全希腊只有一个人知道，我一无所知。</p><p><a href="https://www.youtube.com/watch?v=CY1QDvKiynA&t=702s" target="_blank" rel="noopener">来源</a></p><p>古希腊文学可以说是西方文明的源头，如果你看过《我的天才女友》四部曲，可以看到身为意大利人的爱莲娜，高中需要学希腊文学，分还要求不低。莉拉自学希腊语，还能指点爱莲娜。</p><h1 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h1><p>《黑客帝国》主角，尼奥（Neo） 命名，与密码学中的密码无关。</p><p>为什么 1999 年那么多好电影呢？因为大导演都在憋大招，给 2000 年贺岁，不是以前导演牛逼，是你现在只能看到牛逼的导演的作品了。</p><p>1999 年上映的巨作，包括以下。</p><ol><li>黑客帝国</li><li>星球大战 1: 幽灵的威胁</li><li>搏击俱乐部</li><li>喜剧之王</li><li>关于我母亲的一切（真 · 女性电影，详情看戴锦华老师的 B 站讲解）</li><li>玩具总动员2</li><li>没完没了（还可以的）</li><li>宝莲灯</li></ol><p>当然 1994 年也是，大导演都在也发大招了，因为从“现代电影之父”卢米埃尔兄弟发明电影和电影放映机到1994年刚好是世界电影百岁诞辰，所以这一年所有电影人都卯足了劲为这个诞辰献上大礼。</p><ol><li>肖生克的救赎</li><li>阿甘正传</li><li>这个杀手不太冷</li><li>低俗小说</li><li>狮子王</li><li>活着</li><li>阳光灿烂的日子</li><li>饮食男女</li><li>重庆森林（注意这里是香港，叫重庆森林主要是因为 <a href="https://www.zhihu.com/question/26545005#:~:text=Chunking%E6%98%AF%E9%A6%99%E6%B8%AF%E7%9A%84%E9%87%8D%E5%BA%86,%E4%B8%80%E4%BA%9B%E4%BE%BF%E5%88%A9%E5%BA%97%E5%8F%91%E7%94%9F%E7%9A%84%E3%80%82&text=%E9%87%8D%E6%85%B6%E6%98%AF%E9%87%8D%E6%85%B6%E5%A4%A7%E5%BB%88%EF%BC%8C%E6%A3%AE%E6%9E%97,%E6%88%91%E6%83%B3%E6%98%AF%E9%80%99%E6%A8%A3%E5%90%A7%E3%80%82" target="_blank" rel="noopener"><strong>重慶</strong>是<strong>重慶</strong>大廈，<strong>森林</strong>是指廣東話中經常說的「石屎（混凝土）<strong>森林</strong>」（指城市），意即人們生活在這個人口密度極高的地方，物理上的距離十分近，但每人都活在自己寂寞的世界中</a>。 ）</li></ol><h1 id="C3p0"><a href="#C3p0" class="headerlink" title="C3p0"></a>C3p0</h1><p>C-3PO Star Wars（星球大战）</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/10/14/U1w4XP3abKxODpB.png" alt="C-3PO.png"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="book" scheme="https://young1lin.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>什么是 SSR、V2ray、Trojan、Clash，什么是机场？</title>
    <link href="https://young1lin.github.io/2020/10/30/GFW/"/>
    <id>https://young1lin.github.io/2020/10/30/GFW/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2023-11-23T16:10:34.515Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你可以看 Youtube 视频，我建议你直接看<a href="https://www.youtube.com/watch?v=XKZM_AjCUr0&list=PLqybz7NWybwUgR-S6m78tfd-lV4sBvGFG&index=1" target="_blank" rel="noopener">这个</a>系列，不用看我写的。还有，墙带来的正面效果其实远远大于负面效果，首先如果没有墙的保护，国内的互联网企业，没有一个能成为大企业。大家都有 Gmail 谁用其他邮箱？Google 全家桶完全秒杀国内所有企业，欧洲没有墙，你听过欧洲有哪些互联网巨头吗？不仅是对一些无知的人一些保护，避免受到境外势力例如 大纪元 这种，国内很多人很容易被煽动，成了别人的傀儡。最重要的其实还是保护本土科技企业，留有一定时间追赶 Google 这样的超级大公司。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>简单介绍原理。这里忽略网络传输层，默认是 TCP/IP，也忽略域名污染等等其他内容。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/vYfNCrmi2Gk5QdW.png" alt="科学上网原理简单介绍.png"></p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>如果你了解过 Nginx 肯定会听到无数的 “反向代理”，而 VPN 就是正向代理。两者最大区别，就是一个不知道最终访问的是哪个服务器，一个是知道要访问哪个，但是需要借个道。</p><p>代理代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p><img src= "/img/loading.gif" data-src="https://res.weread.qq.com/wrepub/epub_907764_81" alt="HTTP 代理"></p><h2 id="OSI-七层模型和-SOCKS5"><a href="#OSI-七层模型和-SOCKS5" class="headerlink" title="OSI 七层模型和 SOCKS5"></a>OSI 七层模型和 SOCKS5</h2><p><strong>SOCKS</strong>是一种<a href="https://zh.m.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”SOCKet Secure”的<a href="https://zh.m.wikipedia.org/wiki/缩写" target="_blank" rel="noopener">缩写</a><a href="https://zh.m.wikipedia.org/zh-hans/SOCKS#cite_note-1" target="_blank" rel="noopener">[注 1]</a>。</p><p>当<a href="https://zh.m.wikipedia.org/wiki/防火墙_(网络)" target="_blank" rel="noopener">防火墙</a>后的客户端要访问外部的服务器时，就跟SOCKS<a href="https://zh.m.wikipedia.org/wiki/代理服务器" target="_blank" rel="noopener">代理服务器</a>连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。</p><p>这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持<a href="https://zh.m.wikipedia.org/wiki/用户数据报协议" target="_blank" rel="noopener">UDP</a>、验证，以及<a href="https://zh.m.wikipedia.org/wiki/IPv6" target="_blank" rel="noopener">IPv6</a>。</p><p>根据<a href="https://zh.m.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>，SOCKS是<a href="https://zh.m.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a>的协议，位于<a href="https://zh.m.wikipedia.org/wiki/表示层" target="_blank" rel="noopener">表示层</a>与<a href="https://zh.m.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>之间。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/10/15/QWDC8PHZRobkSr5.png" alt="TCP/IP_Protocol.png"></p><p>Session 就是会话层，在应用层（Application）下面，所以 SOCKS5 能代理 HTTP 请求，而 HTTP 不能代理 SOCKS5 的内容，<strong>从上往下就是依次加各自的协议头部</strong>。通过传输层（Transport）传到另一台机器上，再以此解头部。所以更低层的协议，更加快速，一般的游戏就是到会话层，你如果搞了只在 HTTP 层代理的工具，不能加速的。</p><h1 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h1><p>SSR 又称酸酸乳，小飞机。客户端是下面这个样子的图标，你应该看图就知道为什么叫小飞机了吧。</p><p><strong>下面是 Wikipedia 的解释</strong>。</p><p><strong>Shadowsocks</strong>（简称<strong>SS</strong>）是一种基于<a href="https://zh.wikipedia.org/wiki/SOCKS#SOCK5" target="_blank" rel="noopener">Socks5</a>代理方式的加密传输协议，也可以指实现这个协议的各种开发包。目前包使用<a href="https://zh.wikipedia.org/wiki/Python" target="_blank" rel="noopener">Python</a>、<a href="https://zh.wikipedia.org/wiki/C語言" target="_blank" rel="noopener">C</a>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a>、<a href="https://zh.wikipedia.org/wiki/C♯" target="_blank" rel="noopener">C#</a>、<a href="https://zh.wikipedia.org/wiki/Go语言" target="_blank" rel="noopener">Go语言</a>、<a href="https://zh.wikipedia.org/wiki/Rust" target="_blank" rel="noopener">Rust</a>等编程语言开发，大部分主要实现（<a href="https://zh.wikipedia.org/wiki/IOS" target="_blank" rel="noopener">iOS</a>平台的除外）采用<a href="https://zh.wikipedia.org/wiki/Apache许可证" target="_blank" rel="noopener">Apache许可证</a>、<a href="https://zh.wikipedia.org/wiki/GPL" target="_blank" rel="noopener">GPL</a>、<a href="https://zh.wikipedia.org/wiki/MIT許可證" target="_blank" rel="noopener">MIT许可证</a>等多种<a href="https://zh.wikipedia.org/wiki/自由軟體" target="_blank" rel="noopener">自由软件</a>许可协议<a href="https://zh.wikipedia.org/wiki/開放原始碼" target="_blank" rel="noopener">开放源代码</a>。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/11/27/2M5ex4uScQh3nvD.png" alt="image.png"></p><h2 id="SSR-服务端"><a href="#SSR-服务端" class="headerlink" title="SSR 服务端"></a>SSR 服务端</h2><p>一般是由 Python 写的，启动也比较简单，前人已经帮大家写好很多东西了，按照安装步骤来。只需要简单的配置 + 简单的命令 <code>systemctl shadowsocks start</code>这种就能启动客户端了。检查防火墙端口开放，检查服务器厂商端口开放，一般就能用客户端输入些参数直连了。就是正向代理而已。</p><p><em>这里有个坑，需要修改他的 python 源代码，碰到的时候谷歌/Bing 搜一下就行了。</em></p><h2 id="SSR-客户端"><a href="#SSR-客户端" class="headerlink" title="SSR 客户端"></a>SSR 客户端</h2><p>这个一般是通过白名单的模式，对你访问的非白名单的网站进行代理。比如 bilibili 这种网站，就不会走代理，当然如果你开启了全局代理，所有的请求都会走代理服务器再去你访问的网站，绕一大圈，所以这个慎重开。</p><h1 id="V2ray"><a href="#V2ray" class="headerlink" title="V2ray"></a>V2ray</h1><p>V2Ray 可同时开启多个协议支持，包括<a href="https://zh.m.wikipedia.org/wiki/Socks" target="_blank" rel="noopener">Socks</a>、<a href="https://zh.m.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>、<a href="https://zh.m.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a>、VMess、<a href="https://zh.m.wikipedia.org/w/index.php?title=Trojan_(协议)&action=edit&redlink=1" target="_blank" rel="noopener">Trojan</a>和VLESS等。每个协议可单独设置传输载体，比如<a href="https://zh.m.wikipedia.org/wiki/TCP" target="_blank" rel="noopener">TCP</a>、<a href="https://zh.m.wikipedia.org/wiki/MKCP" target="_blank" rel="noopener">mKCP</a>和<a href="https://zh.m.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>等。</p><p>配置比较麻烦不建议自己搭服务器用。</p><h1 id="Trojan"><a href="#Trojan" class="headerlink" title="Trojan"></a>Trojan</h1><p>需要安装 Nginx，伪装成正常网站，需要申请个域名。</p><p>一般是有一键安装的脚本，可以直接装 Nginx 和 Trojan，这个会伪装成一个“旅游”网站什么的，你的香港的服务器或者其他能访问的服务器会变成一个网站，直接浏览器访问的话。客户端有很多，ClashX 比较好。但是还是不建议自己买服务器搭，又贵又慢。</p><h1 id="Clash"><a href="#Clash" class="headerlink" title="Clash"></a><a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">Clash</a></h1><p>使用 Go 写的，全平台的，支持多个协议的代理客户端。某些厂商就是根据这个来定制化开发他们自己的客户端，并且能加密。</p><h1 id="机场"><a href="#机场" class="headerlink" title="机场"></a>机场</h1><p>所谓的机场，其实就是多个服务器部署了酸酸乳服务端。你可以列出该列表，可以通过自定义规则，例如超时多少切换下一个节点，是否开启负载均衡。</p><p>其实就是避免单点，以免一个服务器被封了 IP 之类的，导致不能科学上网了。</p><p>由专门的机构来做这件事，不然你一个个买服务器，太贵了。</p><p>一般给你的，是多次 Base64 编码后的一串字符串。</p><h1 id="软路由"><a href="#软路由" class="headerlink" title="软路由"></a>软路由</h1><h2 id="OpenWrt"><a href="#OpenWrt" class="headerlink" title="OpenWrt"></a>OpenWrt</h2><p>用树莓派/不用的电脑安装 OpenWrt 作为绕过封锁的软路由，设置对应的网关，以及机场地址，一样可以翻出去。这个就是个<em>OpenWrt</em>是适合于嵌入式设备的一个Linux发行版。</p><h1 id="“能”绕过封锁的路由器"><a href="#“能”绕过封锁的路由器" class="headerlink" title="“能”绕过封锁的路由器"></a>“能”绕过封锁的路由器</h1><p>其实还是用到了机场。梅林路由器。</p><h1 id="永远不会被屏蔽的教学-FQ-地方"><a href="#永远不会被屏蔽的教学-FQ-地方" class="headerlink" title="永远不会被屏蔽的教学 FQ 地方"></a>永远不会被屏蔽的教学 FQ 地方</h1><p>Github，如果访问不了，可以访问它的镜像网站，有很多镜像网站。</p><p>如果国内把 Github 封了（事实上以前封过一段时间），那真的不用开发了。Gitee 圈子太小了，国内大多是业务开发，基础设施，框架很少。用爱发电这种事，大家都坚持不久的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="GFW" scheme="https://young1lin.github.io/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>求皮尔逊相关系数，UDAF 开发</title>
    <link href="https://young1lin.github.io/2020/10/30/UDAF/"/>
    <id>https://young1lin.github.io/2020/10/30/UDAF/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2021-10-04T13:53:03.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="皮尔逊相关系数简介"><a href="#皮尔逊相关系数简介" class="headerlink" title="皮尔逊相关系数简介"></a>皮尔逊相关系数简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>皮尔逊相关系数（Pearson correlation coefficient）也称皮尔逊积矩相关系数（Pearson product-moment correlation coefficient），是一种线性相关系数。皮尔森相关系数是用来反映两个变量线性相关程度的统计量。</p><p>其中相关系数用 r 表示，n为样本量，分别为两个变量的观测值和均值。r 描述的是两个变量间线性相关强弱的程度。r 的绝对值越大、表明相关性越强。可以简单理解相关系数r为分别对x和y基于自身总体标准化后计算空间向量的余弦夹角。</p><p>这里的 1/n-1 可以约掉，所以是更下面的图。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="原公式"><a href="#原公式" class="headerlink" title="原公式"></a>原公式</h3><p><img src= "/img/loading.gif" data-src="https://res.weread.qq.com/wrepub/epub_31630789_56" alt="公式.png"></p><h3 id="分子分母相约后的公式"><a href="#分子分母相约后的公式" class="headerlink" title="分子分母相约后的公式"></a>分子分母相约后的公式</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/08/25/Pmb179d2kzf36gc.png" alt="公式2.png"></p><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><h2 id="TDH"><a href="#TDH" class="headerlink" title="TDH"></a>TDH</h2><p>475 版本，<strong>不是</strong> 5 以上容器的版本，<strong>也不是</strong> 6 版本的 Kubernetes 上。如果报错，可以去具体 Spark SQL 的日志里面去看什么错误。</p><h1 id="Hive-UDAF-执行流程"><a href="#Hive-UDAF-执行流程" class="headerlink" title="Hive UDAF 执行流程"></a>Hive UDAF 执行流程</h1><p>Model 和 Evaluator 的关系。<a href="https://blog.csdn.net/kent7306/article/details/50110067" target="_blank" rel="noopener">来源于</a></p><p><strong>Mode 各个阶段对应的 Evaluator 方法调用。</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/lERJeIhGvcqOKdy.png" alt="Model 和 Evaluator 的关系.png"></p><p><strong>Evaluator 各个阶段下处理 MapReduce 的流程</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/03/pXsAmzCyUbZR2rG.png" alt="Evaluator 各个阶段下处理 MapReduce 的流程.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="编写-UDAF-函数"><a href="#编写-UDAF-函数" class="headerlink" title="编写 UDAF 函数"></a>编写 UDAF 函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.young1lin.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.Description;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.parse.SemanticException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.AbstractGenericUDAFResolver;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDAFParameterInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.io.DoubleWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StandardListObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.DoubleObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory.javaDoubleObjectInspector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> young1lin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/30 2:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Description</span>(name = <span class="string">"regression"</span>, value = <span class="string">"_FUNC_(double x,avg(x),double y,avg(y)) - computes the simple linear regression"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearRegressionUDAF</span> <span class="keyword">extends</span> <span class="title">AbstractGenericUDAFResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericUDAFEvaluator <span class="title">getEvaluator</span><span class="params">(GenericUDAFParameterInfo info)</span> <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">        ObjectInspector[] inputOIs = info.getParameterObjectInspectors();</span><br><span class="line">        <span class="comment">// 参数个数校验</span></span><br><span class="line">        <span class="keyword">if</span> (inputOIs.length != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentLengthException(<span class="string">"except 4 params,but "</span> + inputOIs.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断参数是否是 double 类型</span></span><br><span class="line">        <span class="keyword">for</span> (ObjectInspector tmp : inputOIs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp.getCategory() != ObjectInspector.Category.PRIMITIVE</span><br><span class="line">                    || ((PrimitiveObjectInspector) tmp).getPrimitiveCategory() != PrimitiveObjectInspector.PrimitiveCategory.DOUBLE) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(<span class="string">"only support double"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinearRegressionUDAFEvaluator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    二选一，就是最开始的函数入参校验的，我比较喜欢用上面那个</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public GenericUDAFEvaluator getEvaluator(TypeInfo[] info) throws SemanticException &#123;</span></span><br><span class="line"><span class="comment">//        return super.getEvaluator(info);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearRegressionUDAFEvaluator</span> <span class="keyword">extends</span> <span class="title">GenericUDAFEvaluator</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 仅用于 init 方法中返回类型声明</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> StandardListObjectInspector javaDoubleListInspector = ObjectInspectorFactory.getStandardListObjectInspector(javaDoubleObjectInspector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> DoubleObjectInspector doubleObjectInspector = PrimitiveObjectInspectorFactory.writableDoubleObjectInspector;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> DoubleObjectInspector[] originalDataOIs = <span class="keyword">new</span> DoubleObjectInspector[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个函数一定要重写，如果是自定义 UDAF 函数，Mode 的几个状态一定要了解的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> m          状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> parameters 入参</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 当前阶段该接受什么类型的 Inspector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">init</span><span class="params">(Mode m, ObjectInspector[] parameters)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.init(m, parameters);</span><br><span class="line">            ObjectInspector result;</span><br><span class="line">            <span class="keyword">if</span> (Mode.PARTIAL1.equals(m)) &#123;</span><br><span class="line">                processOriginalDataObjectInspector(parameters);</span><br><span class="line">                result = javaDoubleListInspector;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Mode.PARTIAL2.equals(m)) &#123;</span><br><span class="line">                result = javaDoubleListInspector;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Mode.FINAL.equals(m)) &#123;</span><br><span class="line">                result = doubleObjectInspector;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// COMPLETE 阶段</span></span><br><span class="line">                result = doubleObjectInspector;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOriginalDataObjectInspector</span><span class="params">(ObjectInspector[] parameters)</span> </span>&#123;</span><br><span class="line">            originalDataOIs[<span class="number">0</span>] = (DoubleObjectInspector) parameters[<span class="number">0</span>];</span><br><span class="line">            originalDataOIs[<span class="number">1</span>] = (DoubleObjectInspector) parameters[<span class="number">1</span>];</span><br><span class="line">            originalDataOIs[<span class="number">2</span>] = (DoubleObjectInspector) parameters[<span class="number">2</span>];</span><br><span class="line">            originalDataOIs[<span class="number">3</span>] = (DoubleObjectInspector) parameters[<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从这往下方法，依次在不同阶段执行</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> AggregationBuffer 这个被标记弃用， 打算用  &#123;<span class="doctag">@link</span> AbstractAggregationBuffer&#125;这个代替，</span></span><br><span class="line"><span class="comment">         * 因为内存的一些原因，未来会隐藏这个废弃的接口</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@deprecated</span> use &#123;<span class="doctag">@link</span> AbstractAggregationBuffer&#125; instead</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AggregationBuffer <span class="title">getNewAggregationBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LinearRegressionAggregationBuffer buffer = <span class="keyword">new</span> LinearRegressionAggregationBuffer();</span><br><span class="line">            buffer.reset();</span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(AggregationBuffer agg)</span> </span>&#123;</span><br><span class="line">            LinearRegressionAggregationBuffer buffer = (LinearRegressionAggregationBuffer) agg;</span><br><span class="line">            buffer.reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(AggregationBuffer agg, Object[] inputs)</span> </span>&#123;</span><br><span class="line">            LinearRegressionAggregationBuffer buffer = (LinearRegressionAggregationBuffer) agg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> x = PrimitiveObjectInspectorUtils.getDouble(inputs[<span class="number">0</span>], originalDataOIs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">double</span> xBar = PrimitiveObjectInspectorUtils.getDouble(inputs[<span class="number">1</span>], originalDataOIs[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">double</span> y = PrimitiveObjectInspectorUtils.getDouble(inputs[<span class="number">2</span>], originalDataOIs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">double</span> yBar = PrimitiveObjectInspectorUtils.getDouble(inputs[<span class="number">3</span>], originalDataOIs[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            buffer.xBarSubReMultiplyYBarSubReSum += buffer.reminderMultiply(x, xBar, y, yBar);</span><br><span class="line">            buffer.xBarSubReSquareSum += buffer.reminderSquare(x, xBar);</span><br><span class="line">            buffer.yBarSubReSquareSum += buffer.reminderSquare(y, yBar);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">terminatePartial</span><span class="params">(AggregationBuffer agg)</span> </span>&#123;</span><br><span class="line">            LinearRegressionAggregationBuffer buffer = (LinearRegressionAggregationBuffer) agg;</span><br><span class="line">            ArrayList&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">            list.add(buffer.xBarSubReMultiplyYBarSubReSum);</span><br><span class="line">            list.add(buffer.xBarSubReSquareSum);</span><br><span class="line">            list.add(buffer.yBarSubReSquareSum);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 合并操作</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> agg init 获得的 agg 对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> param 上一步返回的对象的包装对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(AggregationBuffer agg, Object param)</span> </span>&#123;</span><br><span class="line">            LinearRegressionAggregationBuffer buffer = (LinearRegressionAggregationBuffer) agg;</span><br><span class="line">            <span class="comment">// terminatePartial 返回的是 List&lt;Double&gt;，所以这里可以直接强转为 List，double 在 Hive 执行过程中会自动转为 DoubleWritable 类型</span></span><br><span class="line">            List&lt;DoubleWritable&gt; list = (List&lt;DoubleWritable&gt;)param;</span><br><span class="line">            buffer.xBarSubReMultiplyYBarSubReSum += list.get(<span class="number">0</span>).get();</span><br><span class="line">            buffer.xBarSubReSquareSum += list.get(<span class="number">1</span>).get();</span><br><span class="line">            buffer.yBarSubReSquareSum += list.get(<span class="number">2</span>).get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">terminate</span><span class="params">(AggregationBuffer agg)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            LinearRegressionAggregationBuffer buffer = (LinearRegressionAggregationBuffer) agg;</span><br><span class="line">            <span class="comment">// 就是图中所示的公式</span></span><br><span class="line">            <span class="keyword">double</span> value = buffer.xBarSubReMultiplyYBarSubReSum / Math.sqrt(buffer.xBarSubReSquareSum * buffer.yBarSubReSquareSum);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DoubleWritable(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearRegressionAggregationBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractAggregationBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * x bar 指的是 x 的平均值</span></span><br><span class="line"><span class="comment">             * sun((x - xBar)*(y - yBar))</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">double</span> xBarSubReMultiplyYBarSubReSum;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sum((x - xBar)^2)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">double</span> xBarSubReSquareSum;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sum((y - yBar)^2)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">double</span> yBarSubReSquareSum;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">reminderMultiply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> xBar, <span class="keyword">double</span> y, <span class="keyword">double</span> yBar)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (x - xBar) * (y - yBar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 求两个数，一个是当前值，一个是平均值，他们相减得到的平方值</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> vBar avg(v)</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> (v - vBar) * (v - vBar)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">reminderSquare</span><span class="params">(<span class="keyword">double</span> v, <span class="keyword">double</span> vBar)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (v - vBar) * (v - vBar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                xBarSubReMultiplyYBarSubReSum = <span class="number">0</span>;</span><br><span class="line">                xBarSubReSquareSum = <span class="number">0</span>;</span><br><span class="line">                yBarSubReSquareSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的类打成 jar 包。可以用 maven 打包（非 shade 方式），名称在 &lt;build&gt; 标签里写 <code>&lt;finalName&gt;这里是你的 jar 的最终名称&lt;/finalName</code>名称可以自定义，也可以我取的名字 custom_function_tools.jar。也可以用<code>Build -&gt; Build Artifacts</code>.</p><h2 id="上传至-HDFS"><a href="#上传至-HDFS" class="headerlink" title="上传至 HDFS"></a>上传至 HDFS</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put custom_function_tools.jar /tmp</span><br></pre></td></tr></table></figure><p>hadoop fs -put custom_function_tools.jar[这里是你打包好的 jar 包] /tmp[这里是你要传到 HDFS 的文件夹路径] 。</p><p>如果没有 tmp 文件夹，则执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /tmp</span><br></pre></td></tr></table></figure><h1 id="测试相关-SQL"><a href="#测试相关-SQL" class="headerlink" title="测试相关 SQL"></a>测试相关 SQL</h1><h2 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h2><p>我这边想用里面的 ORC 表来使用事务，但是没用，至少 TDH 的没用，之前也测过，在 Spark SQL 的日志上看了，有日志，但没有回滚。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> linear(</span><br><span class="line">s <span class="keyword">string</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'描述'</span></span><br><span class="line">    x <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'数值'</span></span><br><span class="line">    y <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'数值'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'测试线性回归方程相关系数表'</span></span><br><span class="line">CLUSTERED <span class="keyword">BY</span>(s)</span><br><span class="line"><span class="keyword">INTO</span> <span class="number">23</span> BUCKETS</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE</span><br><span class="line"><span class="string">'org.apache.hadoop.hive.ql.io.orc.OrcSerde'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES(<span class="string">'serialization.format'</span>=<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> </span><br><span class="line">INPUTFORMAT <span class="string">'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat'</span></span><br><span class="line">OUTPUTFORMAT <span class="string">'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat'</span></span><br><span class="line">TABLEPROPERTIES(</span><br><span class="line"><span class="string">'numFiles'</span>=<span class="string">'23'</span>,</span><br><span class="line">    <span class="string">'transactional'</span>=<span class="string">'true'</span>,</span><br><span class="line">    <span class="string">'COLUMN_STATS_ACCURATE'</span>=<span class="string">'true'</span>,</span><br><span class="line"><span class="string">'totalSize'</span>=<span class="string">'7075'</span>,</span><br><span class="line">    <span class="string">'numRows'</span>=<span class="string">'1'</span>,</span><br><span class="line">    <span class="string">'rawDataSize'</span>=<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> linear <span class="keyword">value</span>(<span class="string">'1'</span>,<span class="number">5</span>,<span class="number">9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> linear <span class="keyword">value</span>(<span class="string">'2'</span>,<span class="number">4</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> linear <span class="keyword">value</span>(<span class="string">'3'</span>,<span class="number">12</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> linear <span class="keyword">value</span>(<span class="string">'4'</span>,<span class="number">59.555</span>,<span class="number">40.2111</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> linear <span class="keyword">value</span>(<span class="string">'5'</span>,<span class="number">6.42</span>,<span class="number">34.14</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> linear <span class="keyword">value</span>(<span class="string">'6'</span>,<span class="number">9</span>,<span class="number">27</span>);</span><br></pre></td></tr></table></figure><h2 id="创建临时函数（二选一，测试时推荐）"><a href="#创建临时函数（二选一，测试时推荐）" class="headerlink" title="创建临时函数（二选一，测试时推荐）"></a>创建临时函数（二选一，测试时推荐）</h2><p>可以创建临时函数方便测试，重启后就没的那种，也可以创建永久函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TEMPORARY</span> <span class="keyword">FUNCTION</span> regression <span class="keyword">as</span> <span class="string">'me.young1lin.hive.LinearRegressionUDAF'</span> <span class="keyword">using</span> JAR <span class="string">'hdfs:///tmp/custom_function_tools.jar'</span></span><br></pre></td></tr></table></figure><p>这里的 <code>hdfs:///tmp/custom_function_tools.jar</code> 是三个 / ，名称是你刚上传的 jar 的名称。</p><p>前两个 <code>/</code> 和 hdfs：表示的是协议，最后一个 <code>/</code> 表示根路径，可以加具体的 IP 地址或者域名，因为这个是在同一个集群里面的，所以我这边不用加。</p><h2 id="创建永久函数（二选一）"><a href="#创建永久函数（二选一）" class="headerlink" title="创建永久函数（二选一）"></a>创建永久函数（二选一）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">PERMANENT</span> <span class="keyword">FUNCTION</span> regression <span class="keyword">as</span> <span class="string">'me.young1lin.hive.LinearRegressionUDAF'</span> <span class="keyword">using</span> JAR <span class="string">'hdfs:///tmp/custom_function_tools.jar'</span></span><br></pre></td></tr></table></figure><h2 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> regression(l.x,xx.xbar,l.y,xx.ybar)<span class="keyword">from</span> linear l,(<span class="keyword">select</span> <span class="keyword">avg</span>(x) <span class="keyword">as</span> xbar,<span class="keyword">avg</span>(y) ybar <span class="keyword">from</span> linear) <span class="keyword">as</span> xx;</span><br></pre></td></tr></table></figure><p>查询返回的以下结果。当然你可以 <strong>group by</strong>  其中一个字段，得出不同的结果，<strong>当 x 或者 y 存在相同的数值时</strong>，就有了不同效果。</p><p><strong>如图所示</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/10/30/tZbhr53SUW6qnDY.png" alt="image.png"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="Hive" scheme="https://young1lin.github.io/tags/Hive/"/>
    
    <category term="UDAF" scheme="https://young1lin.github.io/tags/UDAF/"/>
    
    <category term="Data warehouse" scheme="https://young1lin.github.io/tags/Data-warehouse/"/>
    
    <category term="Data mining" scheme="https://young1lin.github.io/tags/Data-mining/"/>
    
  </entry>
  
  <entry>
    <title>RowKey 设计规约</title>
    <link href="https://young1lin.github.io/2020/09/25/rowkey-design/"/>
    <id>https://young1lin.github.io/2020/09/25/rowkey-design/</id>
    <published>2020-09-24T16:00:00.000Z</published>
    <updated>2021-05-28T14:43:10.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="RowKey-尽量简短"><a href="#RowKey-尽量简短" class="headerlink" title="RowKey 尽量简短"></a>RowKey 尽量简短</h1><p>Data Block 是 HBase 中文件读取的最小单元。Data Block中主要存储用户的KeyValue数据，而KeyValue结构是HBase存储的核心。HBase中所有数据都是以KeyValue结构存储在HBase中。</p><p>KeyValue由4个部分构成，分别为Key Length、Value Length、Key和Value。其中，Key Length和Value Length是两个固定长度的数值，Value是用户写入的实际数据，Key是一个复合结构，由多个部分构成：Rowkey、Column Family、Column Qualif ier、TimeStamp以及KeyType。其中，KeyType有四种类型，分别是Put、Delete、DeleteColumn和DeleteFamily。</p><p>HBase中数据在最底层是以KeyValue的形式存储的，其中Key是一个比较复杂的复合结构。</p><p>这也是HBase系统在表结构设计时经常强调Rowkey、Column Family以及ColumnQualif ier尽可能设置短的根本原因。列族一般情况下设置为 1 个。</p><p>——《HBase 原理与实战》</p><h1 id="等长"><a href="#等长" class="headerlink" title="等长"></a>等长</h1><p>类似桶排序规则。</p><h1 id="ID-在前"><a href="#ID-在前" class="headerlink" title="ID 在前"></a>ID 在前</h1><p>&lt;user_id&gt;&lt;业务字段&gt;</p><h1 id="优先级排序"><a href="#优先级排序" class="headerlink" title="优先级排序"></a>优先级排序</h1><p>高频查询的越靠前</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="HBase" scheme="https://young1lin.github.io/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>仅供本人使用，部分内容是缩写，其他人看不懂的</title>
    <link href="https://young1lin.github.io/2020/09/14/Flashcard/"/>
    <id>https://young1lin.github.io/2020/09/14/Flashcard/</id>
    <published>2020-09-13T16:00:00.000Z</published>
    <updated>2022-03-03T14:48:20.974Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><style>    #head {        width: 100%;        height: 50px;        display: flex;    }    #head-left {        width: 30%;        float: right;    }    #head-center {        width: 40%;        text-align: center;        font-size: 18px    }    #head-right {        width: 30%;        float: left;    }    #body {        width: 100%;        height: 900px;        display: flex;    }    #body h1{        display:none;    }    #content-input {        width: 50%;        height: 900px;        padding:0 0 0 0;        background-color: #fafafa;    }    #leave-message-textarea {        width: 100%;        height:900px;        outline: 0;        border: 1px solid #a0b3d6;        font-size: 14px;        overflow-x: hidden;        overflow-y: auto;        -webkit-user-modify: read-write-plaintext-only;        line-height: 24px;        border-color: rgba(82, 168, 236, 0.8);        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);    }    [contentEditable=true]:empty:not(:focus):before {        content: attr(data-text);    }    #content-output {        width: 50%;        height: 900px;        overflow: auto;        background-color: #fafafa;        padding: 1em;        border: 1px solid #a0b3d6;    }    button {        appearance: button;        -webkit-writing-mode: horizontal-tb !important;        text-rendering: auto;        color: -internal-light-dark(buttontext, rgb(170, 170, 170));        letter-spacing: normal;        word-spacing: normal;        text-transform: none;        text-indent: 0px;        text-shadow: none;        display: inline-block;        text-align: center;        align-items: flex-start;        cursor: default;        background-color: -internal-light-dark(rgb(239, 239, 239), rgb(74, 74, 74));        box-sizing: border-box;        margin: 0em;        font: 400 13.3333px Arial;        padding: 1px 6px;        border-width: 2px;        border-style: outset;        border-color: -internal-light-dark(rgb(118, 118, 118), rgb(195, 195, 195));        border-image: initial;    }    .btn {        margin-left: 10px;        border-radius: 20px;        padding: 12px 23px;        color: #fff;        display: inline-block;        line-height: 1;        white-space: nowrap;        cursor: pointer;        background: #fff;        border: 1px solid #dcdfe6;        text-align: center;        box-sizing: border-box;        outline: none;        margin: 0;        transition: .1s;        font-weight: 500;        font-size: 14px;    }    .btn:hover {        color: #409eff;        border-color: #c6e2ff;        background-color: #ecf5ff;    }    .fleft {        float: left;    }    .fright {        float: right;    }    .bg-blue {        background-color: #409eff;        border-color: #409eff;    }    .bg-gray {        background-color: #909399;        border-color: #909399;    }    .bg-green {        background-color: #67c23a;        border-color: #67c23a;    }    .bg-red {        background-color: #f56c6c;        border-color: #f56c6c;    }</style><script type="text/javascript" async>    // 所有的 cardId    let flashCards = [];    // cardId 和 对应的 内容    let flashCardContentMap = new Map();    // 已经掌握的 cards 的 id    let archiveCards = [];    // 历史记录 cards    let historyCards = [];    // 当执行上一个的操作时，下一个 id 将被缓存起来    let nextCards = [];    // 缓存已经递归调用查找过的内容    let existArchiveCards = [];    // 获取最小值到最大值之前的整数随机数    function GetRandomNum(Min, Max) {        var Range = Max - Min;        var Rand = Math.random();        return (Min + Math.round(Rand * Range));    }    function getRandomCard(){        //let cardId = getRandomCard();        let randomNum = GetRandomNum(0, flashCards.length - 1);        let cardId = flashCards[randomNum];        // 之后实现这个功能        //cardId = getRandomFlashCard(cardId);        return cardId;    }    // function getRandomFlashCard(cardId) {    //     for(let existCard in existArchiveCards){    //         if(existCard === cardId){    //             getRandomFlashCard();    //         }    //     }    //     for(let i=0,len=archiveCards.length;i<len;i++){    //         if(archiveCards[i] === cardId && i+1 != len){    //             existArchiveCards.push(cardId);    //             getRandomFlashCard();    //         }else{    //             existArchiveCards = [];    //             return archiveCards[i];    //         }    //     }    // }    /**     * 根据 cardId 获取 cardContent     * @param carId H2 标题 名称     */    function getRandomFlashCardContent(cardId) {        if (cardId === null || cardId === "") {            return "";        }        return flashCardContentMap.get(cardId);    }    /**     * 输出内容直输出板     * @param content 内容     */    function outputContent(content) {        $("#content-output").html("");        $("#content-output").html(content);    }    /**     * 清空输出内容     */    function clearOutputArea() {        $("#content-output").html("");    }    /**    * 获取下个 card 并且赋值    */    function getNextCard(){        let cardId;        let currentCardId = getCurrentCardId();        // 先把当前 id push 到历史记录里面        if(currentCardId != "" && currentCardId != null && currentCardId != undefined ){            // 如果当前值不为空， push 进去            historyCards.push(currentCardId);        }        let alreadyNextCard = nextCards.pop();        if(alreadyNextCard === null || alreadyNextCard === undefined || alreadyNextCard === ""){            cardId = getRandomCard();        }else{            cardId = alreadyNextCard;        }        // 这里限制一下历史记录cards        historyCards.push(cardId);        pushTitle(cardId);    }    /**    * 获取上一页内容    */    function getPreviousCard(){        // 当前 ID 先弹出来        let currentCardId = historyCards.pop();        let cardId = historyCards.pop();        // 再把当前 id 缓存起来        if(currentCardId != "" && currentCardId != null && currentCardId != undefined && cardId != undefined){            nextCards.push(currentCardId);            pushTitle(cardId);        }else{            alert("到头了");        }    }    /**    * 获取当前 cardId 的值    */    function getCurrentCardId(){        return $("#cardTitle").html();    }    function pushTitle(cardId){        $("#cardTitle").html(cardId);        $("#content-output").html("");    }    /**    * 各个按钮点击事件绑定    */    function btnsOnclickBind(){        // btn-show        $("#btn-show").click(function(event) {            let cardId = $("#cardTitle").html();            let content = getRandomFlashCardContent(cardId);            outputContent(content);        });        // btn-hide        $("#btn-hide").click(function(event) {            $("#content-output").html("");        });        // btn-mastered        $("#btn-mastered").click(function(event) {            //alert("待完善");            console.log("待完善");        });        // 理论上这里应该不能弹出        // btn-previous        $("#btn-previous").click(function(event) {            getPreviousCard();        });        // btn-next        $("#btn-next").click(function(event) {            getNextCard();        });        // TODO 待实现btn-output         // let content = getRandomFlashCardContent(cardId);    }    window.onload = function() {        $.get("/2020/07/29/Interview", function(data) {            let dom = $.parseHTML(data);            var a = $(data).find("h2");            for (let i = 0; i < a.length; i++) {                // 给 Flashcard id 赋值                flashCards.push(a[i].id);            }            $("#hhh").append(dom);            for (let i = 0; i < flashCards.length; i++) {                if (i + 1 != flashCards.length) {                    let content = $("#" + flashCards[i]).nextUntil("#" + flashCards[i + 1]);                    // 如果 h2 标签之间有 h1 标签，那么就是跨区间的，需要重新定位                    // let h1Content = content.find("h1").prevObject;                    //if(content.find("h1")){                    //   let h1Id = content.find("h1").id;                    //   content = $("#"+flashCards[i]).nextUntil("#"+h1Id);                    // }                    flashCardContentMap.set(flashCards[i], content);                }            }            // btn add onclick event ======= start            // 对各个按钮进行 onclick 事件绑定            btnsOnclickBind();            getNextCard();            // btn add onclick event ======= end;            $("#leave-message-textarea").html("");        });    };</script><!-- head start --><div id="head">    <div id="head-left">        <button id="btn-show" class="btn bg-blue fright" type="button">            <span>显示内容</span>        </button>        <button id="btn-hide" class="btn bg-gray fright" type="button">            <span>隐藏内容</span>        </button>    </div>    <div id="head-center">        <span id="cardTitle"></span>    </div>    <div id="head-right">        <button id="btn-previous" class="btn bg-red fleft" type="button">            <span>上一个</span>        </button>        <button id="btn-next" class="btn bg-green fleft" type="button">            <span>下一个</span>        </button>    </div>    <!-- <input id="btn-output" type="button" value="导出未掌握内容"> --></div><!-- head end --><!-- body start --><div id="body">    <div id="content-input">        <div id="leave-message-textarea" contenteditable="true" data-text="自我解答">        </div>    </div>    <div id="content-output" ></div></div><!-- body end --><!-- hidden content --><div id="hhh" style="display: none;"></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="Flashcard" scheme="https://young1lin.github.io/tags/Flashcard/"/>
    
  </entry>
  
  <entry>
    <title>For Interview</title>
    <link href="https://young1lin.github.io/2020/07/29/Interview/"/>
    <id>https://young1lin.github.io/2020/07/29/Interview/</id>
    <published>2020-07-28T16:00:00.000Z</published>
    <updated>2022-09-05T14:34:51.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>仅供本人面试前准备，其他人还是别看了，没意义。有很多我缩写，省去了很多易理解的部分。</p><p>我尽量找别人已经总结过的东西，而不是自己写，无意义，面试的八股文罢了。都是靠努力就能实现的东西。</p><h1 id="常见容器"><a href="#常见容器" class="headerlink" title="常见容器"></a>常见容器</h1><h2 id="ArrayList-详解"><a href="#ArrayList-详解" class="headerlink" title="ArrayList 详解"></a>ArrayList 详解</h2><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&amp;type=notebook#/04F1A0EFF8F241C2A89E2234AAF0A36A" target="_blank" rel="noopener">https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&amp;type=notebook#/04F1A0EFF8F241C2A89E2234AAF0A36A</a></p><ol><li><p>底层<strong>基于数组</strong>实现</p></li><li><p><strong>创建 ArrayList 如果不指定大小</strong>，会先创建一个<strong>大小为 0 的 Object[ ] 数组</strong> ，</p></li></ol><p><strong>第一次添加数据</strong>时，会<strong>扩容</strong>成 ArrayList 的 默认大小 <strong>default_capacity：10**</strong>；**</p><ol start="3"><li><p>创建时如果<strong>指定大小</strong>，直接<strong>创建指定大小的Object[ ]数组</strong></p></li><li><p>add（）</p></li></ol><ul><li>对 <strong>size+1</strong>，去<strong>判断数组是否满了</strong>，如果满了就<strong>调用 grow（）方法扩容</strong>，扩容大小为，<strong>原数组大小 + 原数组大小右移一位</strong>。也就是扩容到原来的<strong>1.5倍</strong>。JDK 1.6 是 1.5 倍 +1 ，JDK 1.7，1.8 是 1.5 倍。</li><li>然后把老数组拷贝到新数组里 </li></ul><p><strong>elementData</strong> = <strong>Arrays.copyOf(elementData, newCapacity);</strong></p><ul><li>最后 <strong>elementData[ size++ ] = e</strong>，对数组赋值，（并且size+1）</li></ul><ol start="5"><li>add（index，e）</li></ol><ul><li>首先<strong>对index做数组越界检查rangeCheck(index)</strong>;  如果越界了，抛数组越界异常</li><li>如果没越界，还是<strong>对 size + 1，判断是否需要扩容</strong>，如果需要扩容，调用<strong>grow</strong>方法</li><li>如果需要扩容，调用<strong>System.arraycopy（1,2,3,4,5）</strong>方法。参数解释<strong>1：原来的数组，2：从哪里开始复制。3：复制的目标数组。4：目标数组的第几位开始复制。5：一共复制几个数</strong>。</li><li>System.arraycopy(elementData, index, elementData, index + 1, size - index);</li><li>假设把数字6插入到第3位，复制过后的数组是，1 2 3 4 5 -&gt; <strong>1 2 3 3 4 5</strong> </li><li>然后再把目标的位置的值修改，变为 <strong>1 2 6 3 4 5</strong> </li><li>最后size++；</li></ul><ol start="6"><li>set（index，e）</li></ol><ul><li>首先解释，set这个方法是替换该位置原来的元素，所以不会使数组变大，不会做扩容判断</li><li>然后对index做数组越界检查，如果越界了，抛数组越界异常</li><li>把e替换到数组的index位置</li><li>返回数组index位置的原始值</li></ul><ol start="7"><li>remove（index）</li></ol><ul><li>首先<strong>对index做数组越界检查rangeCheck(index);</strong>，如果越界了，抛数组越界异常</li><li>然后进行<strong>数组拷贝 System.arraycopy(elementData, index+1, elementData, index,size - index - 1);</strong></li><li>假设把第三位数字删除，<strong>1 2 3 4 5 6     - &gt; 1    2 4 5 6 6</strong>    </li><li><strong>然后 element[size–] = null;</strong></li><li>最后<strong>返回被删除的值</strong></li></ul><ol start="8"><li>get（index）</li></ol><ul><li>首先对index做数组越界检查<strong>rangeCheck(index);</strong>，如果越界了，抛数组越界异常</li><li><strong>return elementData(index);</strong></li></ul><ol start="9"><li><p><strong>总结来说，AraayList的get方法效率非常高，直接返回对应下标值，add方法和remove方法，效率就有点低了，需要考虑数组扩容和数组拷贝的问题**</strong>。**</p></li><li><p><strong>所以ArrayList比较适用于插入操作较少，不是很频繁插入的场景。</strong></p></li></ol><h2 id="HashMap-详解"><a href="#HashMap-详解" class="headerlink" title="HashMap 详解"></a>HashMap 详解</h2><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&amp;type=notebook#/79C59785226E4D679AF124256055760B" target="_blank" rel="noopener">https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&amp;type=notebook#/79C59785226E4D679AF124256055760B</a></p><ul><li>数组加单链表，1.8 后是红黑树</li><li>初始容量 16 1 &lt;&lt; 4  </li><li>加载因子 0.75 <strong>泊松分布</strong></li><li>扩容临界值 = 容量 * 加载因子</li><li>容量必须是 2 的 n 次方，就是tableSizeFor方法</li><li>构造函数完成后也只是创建一个空数组，只有在第一次放数据时才会初始化容量，等到第一次放数据的时候用。threshold就是这个大小，构造函数阶段会算出这数的值。为什么用这个数保存数组大小，我觉得是作者觉得既然构造阶段数组没有初始化，那临界值也没什么意义，就临时当数组初始大小，等待put的时候给数组初始化，然后那时再回归他本身的意义，扩容临界值。</li><li>size是集合当前大小</li><li>构造函数三个，无参 16，一个参初始容量，两个参 初始容量和加载因子。</li><li>hash 算法：让高位和低位做异或运算，让高位也参与 hash 寻址运算，降低 hash 冲突。</li><li>hash 寻址：为什么是 hash 值和数组 length -1 进行与运算？取余效率低，做位运算效率高，所以容量必须是 2 的 n 次方，如果不是，就找最相近的，用 tableSizeFor 方法。</li><li>链表超过 8 个后，变红黑树（数组的容量大于等于 64）转成红黑树后，会变成 TreeNode</li><li>扩容机制：数组 2 倍扩容，rehash，hash &amp; n-1，判断二进制结果中是否多出一个 bit 的1，如果没多，那么就是原来的index，如果多了出来那么就是 index+oldCap，通过这个方式，避免 rehash，用每个 hash 对新数组.length 取模，1.8 后优化了下，如果一个链表的长度超过了 8，会自动将链表转成红黑树，查找的性能是 O(logn)，比 O（n）高。</li><li>红黑树是二叉查找树，左小右大，普通的二叉查找树可能出现瘸子的情况，只有一条腿，不平衡，导致查询性能变成 O(n)，线性查询。红黑树有一大堆的限制条件。例如<br>根节点是黑色的；每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li><li>如果破坏了红黑树的规则和平衡，会自动 rebalance，变色（红&lt;–&gt;黑），左旋，右旋之类的。</li><li>ps:hashcode是int型，4个字节，一个字节8个bit，一共32位</li><li>先定义个变量： key的hashcode右移 16位，其实就是把原来的hashcode值的高16位放到低16位，高16位补0。然后画图讲解:</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/11/9QywqxjT5OMgtRs.png" alt="image.png"></p><ul><li>相当于拿hashcode的低16为和高16位做异或操作（不一样的为1，一样的为0)，让高16位也参与到运算中（正常来说集合的大小是不会特别大的，2的16次幂就6万多了，虽然hashmap允许的最大值是2的30次幂），所以，hash值的后16位90%的情况下都不会参与运算。但是现在高16位和低16位异或后，低16位就同时保留了高低两部分的特征，降低hash冲突。</li><li>为什么说可以降低hash冲突，因为如果两个key，解析的hashcode可能低16为一样的，但是如果这么异或一下，就不一样了<br>代码</li><li>JDK 1.7 的hashMap 在并发情况下导致死循环的问题，头插法，不同线程的 next 赋值导致链表成环。不同线程，如何计算 Hash 的时候，A 线程时间片用完了，挂起，B 线程看见 table[i] 是空的，直接插入，A 线程因为已经执行完了 Hash 计算，直接进行插入，就会覆盖 B 线程插入的值</li><li>JDK 8 用 head 和 tail 来保证链表的顺序和之前一样；JDK 7 rehash 会倒置链表元素）</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>1.7 Segment + 分段数组 + 链表</li><li>Segment 继承自 ReetrantLock</li><li>弱一致性。当创建迭代器后，其他线程删除了该元素时候并不会抛出java.util.ConcurrentModificationException异常，能够保持创建迭代器后的元素被正确的Iterator.next()出来。例如ConcurrentHashMap就是弱一致性迭代器，HashMap就是强一致性迭代器。</li><li>get 无锁，volatile 加在了 Node 上</li><li>sizeCtl -1代表有线程完成了初始化；别的负数代表有线程在扩容；初始化完成后，sizeCtl就持有下一次扩容的size，作用即threshOld</li></ul><h2 id="LinkedList-详解"><a href="#LinkedList-详解" class="headerlink" title="LinkedList 详解"></a>LinkedList 详解</h2><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&type=notebook#/1253A2DE5549471CAD0EE89666BD208D" target="_blank" rel="noopener">自行查看</a></p><ol><li><p>LinkedList 底层是基双向链表实现的</p></li><li><p>LinkedList的每条数据都会被封装成 Node</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;    </span><br><span class="line">    E item;     </span><br><span class="line">    Node&lt;E&gt; next;   </span><br><span class="line">    Node&lt;E&gt; prev;      </span><br><span class="line">    <span class="comment">//构造方法       </span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; </span><br><span class="line">        <span class="keyword">this</span>.item = element;            </span><br><span class="line">        <span class="keyword">this</span>.next = next;           </span><br><span class="line">        <span class="keyword">this</span>.prev = prev;        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayBlockingQueue-详解"><a href="#ArrayBlockingQueue-详解" class="headerlink" title="ArrayBlockingQueue 详解"></a>ArrayBlockingQueue 详解</h2><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下 不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当 队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入 元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐 量。我们可以使用以下代码创建一个公平的阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue-详解"><a href="#LinkedBlockingQueue-详解" class="headerlink" title="LinkedBlockingQueue 详解"></a>LinkedBlockingQueue 详解</h2><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对 元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者 端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费 者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h2 id="ConcurrentHashMap详解"><a href="#ConcurrentHashMap详解" class="headerlink" title="ConcurrentHashMap详解"></a>ConcurrentHashMap详解</h2><p>1.7分段数组+单向链表</p><p>1.8其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p><a href="https://www.jianshu.com/p/aa017a3ddc40" target="_blank" rel="noopener">https://www.jianshu.com/p/aa017a3ddc40</a></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>从字节码层面上看，枚举仅仅是一个继承于 java.lang.Enum 的类、自动生成了 values 和 valueOf 方法的普通 Java 类而已。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>// 不想自己画，原图片在 <a href="https://www.cnblogs.com/wuzhenzhao/p/12346515.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuzhenzhao/p/12346515.html</a></p><p><img src= "/img/loading.gif" data-src="https://img2020.cnblogs.com/i-beta/1383365/202003/1383365-20200310164642520-698073513.png" alt="JVM 运行时数据区"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里面（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释工作时就是通过改变这个计数器的值来选去下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基础功能都需要以来这个计数器来完成。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>Java虚拟机栈中还有着局部变量表部分，局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、doublle）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p><p>其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需要的内存空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈）如果扩展是无法申请到足够的内存，就会抛出OOME异常。OutOfMemoryError 后文就简称为 OOME 了。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OOME 异常。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点Java虚拟机规范的描述是：所有的对象实例以及数组都要在堆上分配，JIT，逃逸分析，栈上创建对象。</p><p>分代回收，新生代（from+to+Eden，1:1:8）+老年代。从内存分配的角度来看，线程共享Java堆中可能划分出多个线程私有的分配缓冲区。</p><p>逻辑上连续内存空间。</p><h3 id="方法区（Meta-Space）"><a href="#方法区（Meta-Space）" class="headerlink" title="方法区（Meta Space）"></a>方法区（Meta Space）</h3><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器后的代码等数据。又名非堆（Non-Heap），1.7 用永久代（Permanent Generation）实现方法区，1.8 更名为 Meta Space。1.7 及以前的版本的项目容易报 Permanent Generation OOM，1.6 默认 82M，1.7 默认 128M，当类和静态变量一多就容易报错，解决办法是加大这块内存地址。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Pool）是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义中的内存区域。但那是这部分内存也被频繁地使用，而且也可能异常能导致OOME异常出现，</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ul><li><strong>指针碰撞</strong>：假设 Java 堆中内存是绝对规整的，所有内存都放在一遍，空闲的内存放在另一边，中间放一个指针作为分解点的指示器，那所分配内存仅仅是把那个指针向空闲空间那边挪一段与对象大小相等的距离。</li><li><strong>空闲列表</strong>：因为堆内存在物理上是不连续的，而在逻辑上是连续的。当虚拟机在给对象在堆中分配内存时，会出现不是在连续内存空间上分配的情况。为了让对象能够在堆中能分到内存，虚拟机必须维护一个列表，记录上哪些内存块是可以用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><h2 id="什么情况会发生-OOM"><a href="#什么情况会发生-OOM" class="headerlink" title="什么情况会发生 OOM"></a>什么情况会发生 OOM</h2><ul><li>堆溢出</li><li>虚拟机栈和本地方法栈溢出—— 1.请求的栈深度大于虚拟机允许的最大深度，抛出 StackOverflowError。2. 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OOM。</li><li>方法区和运行时常量池溢出——常量池属于方法区的一部分，类太多（包括本身就有的，还有动态生成的类太多）。</li><li>本机直接内存溢出—— -XX：MaxDirectMemorySize 指定，不指定，默认和 Java 堆最大值（ -Xmx 指定） 一样。</li></ul><h2 id="什么时候回收对象"><a href="#什么时候回收对象" class="headerlink" title="什么时候回收对象"></a>什么时候回收对象</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>你引用我，我引用你，你我都是空对象。就会导致这个引用计数回收不了， Python 就是用的引用计数。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中 JNI 应用的对象。</li></ul><h4 id="什么时候对象不可达？"><a href="#什么时候对象不可达？" class="headerlink" title="什么时候对象不可达？"></a>什么时候对象不可达？</h4><p>第一次标记<br>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。</p><p>第二次标记<br>经过第一次标记后的对象，根据 此对象是否有必要执行finalize()方法 进行筛选，随后会由收集器对F-Queue中的对象进行第二次小规模的标记。具体如下：</p><p>经过第一次标记后的对象，根据 此对象是否有必要执行finalize()方法 进行筛选。被判定为确实有必要执行finalize()方法的对象将会被放置在一个名为F-Queue的队列之中。<br>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。<br>稍后会由一条由虚拟机自动建立的、低调度优先级的 Finalizer线程 去执行F-Queue中对象的finalize()方法。<br>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行 第二次小规模的标记。如果对象在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移出 “即将回收” 的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。<br>这种自救的机会只有一次，因为对象的finalize()方法最多只会被系统调用一次。</p><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><h3 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark-Sweep）"></a>标记清除（Mark-Sweep）</h3><p>分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间，容易产生内存碎片。</p><h3 id="复制（copying）"><a href="#复制（copying）" class="headerlink" title="复制（copying）"></a>复制（copying）</h3><p>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。消耗内存多，但是没有内存碎片产生，用于新生代对象创建。</p><h3 id="标记整理-Mark-Compact"><a href="#标记整理-Mark-Compact" class="headerlink" title="标记整理(Mark-Compact)"></a>标记整理(Mark-Compact)</h3><p>标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。</p><p>和指针碰撞不同</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><h3 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h3><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块 Survivor 空间中。</p><h3 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h3><p>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p><ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li><li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代。</li><li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。</li><li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li><li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li><li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被 移到老生代中。</li></ol><h2 id="Java-四中引用类型"><a href="#Java-四中引用类型" class="headerlink" title="Java 四中引用类型"></a>Java 四中引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚 引用的主要作用是跟踪对象被垃圾回收的状态。</p><h2 id="什么是-Safepoint"><a href="#什么是-Safepoint" class="headerlink" title="什么是 Safepoint"></a>什么是 Safepoint</h2><p>Safepoint 可以用在不同地方，比如GC、Deoptimization，在Hotspot VM中，GC safepoint比较常见，需要一个数据结构记录每个线程的调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。</p><p>从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。</p><p><a href="https://www.jianshu.com/p/c79c5e02ebe6" target="_blank" rel="noopener">https://www.jianshu.com/p/c79c5e02ebe6</a></p><h2 id="Minor-GC-和-Full-GC-的触发机制"><a href="#Minor-GC-和-Full-GC-的触发机制" class="headerlink" title="Minor GC 和 Full GC 的触发机制"></a>Minor GC 和 Full GC 的触发机制</h2><h3 id="新生代-GC（Minor-GC）"><a href="#新生代-GC（Minor-GC）" class="headerlink" title="新生代 GC（Minor GC）"></a>新生代 GC（Minor GC）</h3><p>指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p><h3 id="老年代-GC（Major-GC-Full-GC）"><a href="#老年代-GC（Major-GC-Full-GC）" class="headerlink" title="老年代 GC（Major GC/Full GC）"></a>老年代 GC（Major GC/Full GC）</h3><p>指发生在老年代的 GC，出现了 Major GC，经常会伴随着至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</p><p><a href="https://juejin.im/post/5b8d2a5551882542ba1ddcf8" target="_blank" rel="noopener">JVM 系列文章之 Full GC 和 Minor GC</a><br> from区 to区，反复横跳，进入老年代</p><ul><li>young区<ul><li>Eden 80%</li><li>from 10%</li><li>to 10%</li></ul></li><li>old区 </li></ul><p>设置参数，可让创建对象时，直接进入old区。</p><p>如果对象在 Eden 区出生并经过第一次 Minor GC 后仍然存活，并且能够被 Surviror 容纳的话，将被一定到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 中每“熬”过一次 Minor GC，年龄+1，默认到 15 就晋升到老年代。<strong>但并不是永远要求对象年龄必须达到那个参数，如果在 Survivor 空间中相同年龄所有对象的大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</strong></p><p>-XX:MaxTenuringThreshold=15  CMS里面默认是6。</p><h2 id="内存分配以及回收"><a href="#内存分配以及回收" class="headerlink" title="内存分配以及回收"></a>内存分配以及回收</h2><h3 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h3><p>大多数情况下，对象优先在 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><h3 id="大对象为什么直接进入老年代"><a href="#大对象为什么直接进入老年代" class="headerlink" title="大对象为什么直接进入老年代"></a>大对象为什么直接进入老年代</h3><p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，不同垃圾收集器默认值不同，直接在 Eden 区。大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区（<code>from</code>区<code>to</code>区）之间发生大量的内存复制。不同分代，采用不同垃圾回收算法，young 区采用的是复制清除算法，如果是大对象，就得不偿失了。</p><p>注意:<code>PretenureSizeThreshold</code>参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p><p>一个简单的方法，在 Spring Boot项目中写个 循环依赖类（需要特殊处理，在我的 github 上的一个项目中有），然后用 类层次 类去引用，再Debug，就能看见 栈溢出信息，和 from to区的信息。<br>反复横跳，大于 15 次，晋升为老年代对象。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果是，Minor GC 确保安全。看 HandlePromotionFailure 是否允许担保失败。如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 有风险，如果小于或者配置的不允许，那么就改成一次 Full GC。</p><h2 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h2><ol><li><p>-Xms -Xmx 设置成一样 。例如 -Xms2048M -Xmx2048M</p></li><li><p>-XX:USEBAISEDLOCKED=FALSE 关闭偏向锁。JDK 1.6引入新概念，在线程竞争不激烈时引入，偏向锁，轻量级锁。支持锁的升级和降级，但并发比较大的环境下，关掉这个是好的选择。在对象头中标出，00，01，10，11，两位标出是什么状态。</p></li><li><p>年轻代：-XX:+UseParNewGC。</p><p>老年代：-XX:+UseConcMarkSweepGC。</p></li><li><p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis。逃逸分析是让某些朝生夕死的对象，在栈上创建对象，随着栈的消亡而消亡。</p><p><a href="https://www.hollischuang.com/archives/2583" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2583</a></p></li><li><p>频繁触发 Full GC ，如果使用的是 G1，可以加上 -XX:+PrintAdaptiveSizePolicy 参数，查看到底是谁引发的</p></li><li><p>更多见 <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html。比如你用的是" target="_blank" rel="noopener">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html。比如你用的是</a> Azkaban，这种朝生夕死的任务执行的项目，它默认的配置是很简单的，也是很坑的。我的建议是把下面的调整到 5、5。当然，这个我也只是简单测了，改成这样后，就没有之前的 OOM 问题了。更好的比例，需要你一遍遍调。</p><table><thead><tr><th>-XX:NewRatio=n</th><th>Ratio of new/old generation sizes. The default value is 2.</th></tr></thead><tbody><tr><td>-XX:SurvivorRatio=n</td><td>Ratio of eden/survivor space size. The default value is 8.</td></tr></tbody></table></li></ol><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><ul><li>编译</li><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul><p><a href="https://www.cnblogs.com/straybirds/p/8513870.html" target="_blank" rel="noopener">https://www.cnblogs.com/straybirds/p/8513870.html</a></p><p>什么时候加载，虚拟机规范没强制要求，这点虚拟机自己发挥，但是初始化阶段，<strong>虚拟机规范严格规定了有且仅有 5 种情况必须立即对类进行初始化。</strong></p><ol><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时。new 对象，读取或者设置一个类的静态字段（非 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，调用静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。没有初始化，则要。</li><li>当初始化一个类的时候，如果其父类未被初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个需要执行的主类。（main 方法）</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法的句柄所对应的类没有进行过初始化，则需要先出发其初始化。</li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ol><li><p>Bootstrap ClassLoader（C++ 实现，负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的仅按照文件名识别，例如 rt.jar 名字不符合也不会加载。加载到虚拟机的内存中。返回 null 就能用这个加载器加载）</p></li><li><p>Extension ClassLoader（Java 实现负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接用）</p></li><li><p>Application ClassLoader（Java 实现 一般情况下，这个就是默认的类加载器）</p></li></ol><p>自定义 ClassLoader</p><h3 id="破坏双委派模型"><a href="#破坏双委派模型" class="headerlink" title="破坏双委派模型"></a>破坏双委派模型</h3><p>自己覆盖 loadClass 。OSGi 给“高速奔跑的汽车换轮胎”。还有公司要求会这个。。。。</p><h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><ul><li><p>局部变量表</p></li><li><p>动态连接</p></li><li><p>方法返回地址</p></li><li><p>操作数栈</p></li><li><p>方法调用</p></li><li><p>解析</p></li><li><p>分派</p></li><li><p>动态类型语言支持</p></li></ul><p>这个就是方法调用就是压栈，舍弃当前栈帧就是返回上一个方法。Debug 的 drop frame。</p><p>程序源码 -&gt; 语法解析 -&gt; 单词流  -&gt; 语法解析 -&gt; 抽象语法树 </p><p>二选一</p><p>-&gt; 指令流  -&gt; 解释器  -&gt; 解释执行</p><p> -&gt; 优化器  -&gt; 中间代码  -&gt; 生成器  -&gt; 目标代码</p><h2 id="JVM-各种优化"><a href="#JVM-各种优化" class="headerlink" title="JVM 各种优化"></a>JVM 各种优化</h2><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"Foo"</span> + <span class="string">"Bar"</span>;</span><br><span class="line">String b = <span class="string">"FooBar"</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="comment">// 输出为 true，这属于编译时优化。</span></span><br></pre></td></tr></table></figure><ul><li><p>注解处理</p></li><li><p>自动拆装箱</p></li><li><p>锁消除（编译时就把“傻瓜式加锁“代码给去掉，没必要加锁的，就不加）</p></li></ul><h3 id="运行优化"><a href="#运行优化" class="headerlink" title="运行优化"></a>运行优化</h3><ul><li><p>JIT —— Just In Time，当调用频率到一定值时，开启即时编译，跳过 class，直接生成对应汇编，运行汇编文件。很多其他语言也有这个高级 feature。</p></li><li><p>方法内联 —— 我感觉是借鉴 cpp，直接把两段方法合并成一个方法。</p></li><li><p>逃逸分析 —— 栈上创建对象</p></li></ul><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p><a href="https://zhuanlan.zhihu.com/p/29881777" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29881777</a></p><p>无非就是搞了个抽象，具体实现，不同虚拟机不同的来。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="volatile-如何保证内存可见性"><a href="#volatile-如何保证内存可见性" class="headerlink" title="volatile 如何保证内存可见性"></a>volatile 如何保证内存可见性</h2><p>volatile 是 Java 提供的轻量级同步机制</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h3 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h3><p><strong>MESI 协议</strong>是一个基于失效的<a href="https://zh.wikipedia.org/wiki/缓存一致性" target="_blank" rel="noopener">缓存一致性</a>协议，是支持回写（write-back）缓存的最常用协议。也称作<strong>伊利诺伊协议</strong> (Illinois protocol，因为是在<a href="https://zh.wikipedia.org/wiki/伊利诺伊大学厄巴纳-香槟分校" target="_blank" rel="noopener">伊利诺伊大学厄巴纳-香槟分校</a>被发明的<a href="https://zh.wikipedia.org/wiki/MESI协议#cite_note-1" target="_blank" rel="noopener">[1]</a>)。与写通过（write through）缓存相比，回写缓冲能节约大量带宽。总是有“脏”（dirty）状态表示缓存中的数据与主存中不同。MESI协议要求在缓存不命中（miss）且数据块在另一个缓存时，允许缓存到缓存的数据复制。与<a href="https://zh.wikipedia.org/wiki/MSI协议" target="_blank" rel="noopener">MSI协议</a>相比，MESI协议减少了主存的事务数量。这极大改善了性能。<a href="https://zh.wikipedia.org/wiki/MESI协议#cite_note-2" target="_blank" rel="noopener">[2]</a></p><p>JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的一组规则或规范，通过这组规范定义了程序中各个变量（含实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p>JMM关于同步的规定：</p><ol><li>线程解锁前必须把共享变量的值刷新回主存</li><li>线程加锁前，必须读取主存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ol><p>更多<a href="https://blog.csdn.net/t894690230/article/details/50588129" target="_blank" rel="noopener">https://blog.csdn.net/t894690230/article/details/50588129</a></p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><ol><li>程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。</li><li>监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。</li><li>volatile 变量法则：对 volatile 域的写入操作 happens-before 于每个后续对同一 volatile 的读操作。</li><li>传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C。<br>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ol><p><a href="https://juejin.im/post/5ae6d309518825673123fd0e" target="_blank" rel="noopener">https://juejin.im/post/5ae6d309518825673123fd0e</a></p><p><a href="https://en.wikipedia.org/wiki/Happened-before" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Happened-before</a></p><h2 id="Synchronized-C-实现源码解析"><a href="#Synchronized-C-实现源码解析" class="headerlink" title="Synchronized C++ 实现源码解析"></a>Synchronized C++ 实现源码解析</h2><p>自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。<br>自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p><p>因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，操作系统的内核经常使用自旋锁。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 OS(Operating System) 调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。</p><p>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！JDK在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p><p><a href="https://www.jianshu.com/p/c5058b6fe8e5" target="_blank" rel="noopener">synchronized.cpp解析</a></p><p>Jdk1.6 锁的升级与降级，自旋锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁（操作系统内核的 mutex lock）</p><h2 id="ReentrantLock-和-synchronized-之间"><a href="#ReentrantLock-和-synchronized-之间" class="headerlink" title="ReentrantLock 和 synchronized 之间"></a>ReentrantLock 和 synchronized 之间</h2><p>在加锁和内存上提供的语义与内置锁相同，此外它还提供了可定时、可中断、可轮询、公平性，以及实现非块结构的加锁。只要在需要这些高级的功能时，用 ReentrantLock，否则还是应该优先使用 synchronized。<br>synchronized 比 ReetrantLock 还有个优点：在线程转储中能给出在哪些调用帧获得了哪些锁，并能够检测和识别发生死锁的线程。JVM 并不知道哪些线程持有 ReetrantLock，因此在调试使用 ReetrantLock 的线程的问题时，将起不到帮助作用。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/ThreadLocal.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/ThreadLocal.md</a></p><p>Spring MVC 中，RequestHolder 使用 ThreadLocal 进行 HttpServletRequest 进行缓存。还有事务，AopProxyHolder、MyBatis 的 PageHelper 这种，都是根据当前线程的变量来确定的。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md</a></p><p>Doug Lea 设计的，CountDownLatch、ReentrantLock 都继承这个类，是 Java 最低层级的同步机制。</p><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。</p><h3 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>volatile 变量 + 双向队列。</p><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><ol><li>Exclusive（独占）</li></ol><p>只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li></ul><ol start="2"><li>Share（共享）</li></ol><p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p><a href="https://time.geekbang.org/column/article/92524" target="_blank" rel="noopener">https://time.geekbang.org/column/article/92524</a></p><p>Fork/Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的 Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。Fork/Join 计算框架主要包含两部分，一部分是分治任务的线程池 ForkJoinPool，另一部分是分治任务 ForkJoinTask。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。</p><p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。</p><p>Fork/Join 并行计算的核心组件是 ForkJoinPool。ForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。</p><p>如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“任务窃取”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂</p><p>Fork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的 MapReduce，所以你可以把 Fork/Join 看作单机版的 MapReduce。</p><p>Fork/Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数；如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I/O 密集型的并行流计算，那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能。所以建议用不同的 ForkJoinPool 执行不同类型的计算任务。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p> 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。线程 A 有🔒 1，我还想获取🔒 2，但是另一个线程 B 持有🔒 2，两个线程都不释放锁，等着对方释放锁，就会导致死锁。一般死锁了，只能重启。</p><h3 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h3><ol><li><p>互斥，共享资源 X 和 Y 只能被一个线程占用；</p></li><li><p>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</p></li><li><p>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</p></li><li><p>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</p></li></ol><p>破坏其中一个，就可以成功避免死锁的发生。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>全称是 Compare And Swap，即“比较并交换。</p><p>CAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C；并且只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的。</p><p><strong>ABA 问题，加版本号。</strong></p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><h3 id="调用-Unsafe-的-compareAndSwap-native-方法"><a href="#调用-Unsafe-的-compareAndSwap-native-方法" class="headerlink" title="调用 Unsafe 的 compareAndSwap native 方法"></a>调用 Unsafe 的 compareAndSwap native 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="native-方法-compareAndSwapInt-在-Linux-下的-JDK-实现如下。"><a href="#native-方法-compareAndSwapInt-在-Linux-下的-JDK-实现如下。" class="headerlink" title="native 方法 compareAndSwapInt 在 Linux 下的 JDK 实现如下。"></a>native 方法 compareAndSwapInt 在 Linux 下的 JDK 实现如下。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><h3 id="Atocmic-cmpxchg-在-x86-处理器架构下（Linux-下）的-JDK-实现"><a href="#Atocmic-cmpxchg-在-x86-处理器架构下（Linux-下）的-JDK-实现" class="headerlink" title="Atocmic::cmpxchg 在 x86 处理器架构下（Linux 下）的 JDK 实现"></a>Atocmic::cmpxchg 在 x86 处理器架构下（Linux 下）的 JDK 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; What I&#39;m a bit uncertain about here is which barriers we need and which are optimal as it seems to be a bit different for different ARM versions, maybe somebody can enlighten me? Also I&#39;m not sure how hotspot checks ARM version to make the appropriate decision.</span><br><span class="line">&gt;</span><br><span class="line">&gt; The proposed x86 implementation is much more straight forward (bsd, linux):</span><br><span class="line">&gt;</span><br><span class="line">&gt; inline jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) &#123;</span><br><span class="line">&gt;   int mp &#x3D; os::is_MP();</span><br><span class="line">&gt;   jbyte result;</span><br><span class="line">&gt;   __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgb %1,(%3)&quot;</span><br><span class="line">&gt;                     : &quot;&#x3D;a&quot; (result)</span><br><span class="line">&gt;                     : &quot;q&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)</span><br><span class="line">&gt;                     : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">&gt;   return result;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt;&gt; The implementation of single byte Atomic::cmpxchg on x86 (and all other</span><br><span class="line">&gt;&gt;&gt; platforms) emulates the single byte cmpxchgb instruction using a loop of</span><br><span class="line">&gt;&gt;&gt; jint-sized load and cmpxchgl and code to dynamically align the destination</span><br><span class="line">&gt;&gt;&gt; address.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; This code is used for GC-code related to remembered sets currently.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; I have the changes on my platform (amd64, bsd) to simply use the native</span><br><span class="line">&gt;&gt;&gt; cmpxchgb instead but could provide a patch fixing this unnecessary</span><br><span class="line">&gt;&gt;&gt; performance glitch for all supported x86 if anybody wants this?</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; I think that sounds good.</span><br><span class="line">&gt;&gt; Would you mind looking at other cpu arches to see if they provide something</span><br><span class="line">&gt;&gt; similar? It&#39;s ok if you can&#39;t build the code for the other arches, I can help</span><br><span class="line">&gt;&gt; you with that.</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; &#x2F;Mikael</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="配置-ThreadPoolExecutor"><a href="#配置-ThreadPoolExecutor" class="headerlink" title="配置 ThreadPoolExecutor"></a>配置 ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment"> *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize —— 线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程。在 ThreadPoolExecutor 初期，线程并不会立即启动，而是等到有任务提交时才会启动，除非调用 prestartAllThreads。</p></li><li><p>maximumPoolSize —— 线程池最大值。 the maximum number of threads to allow in the pool。</p></li><li><p>keepAliveTime —— 当线程数超过核心线程数时，这是多余的空闲线程将在终止之前等待新任务的最长时间。  when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</p></li><li><p>unit  —— 上面的时间单位the time unit for the {@code keepAliveTime} argument</p></li><li><p>workQueue —— 任务队列，这个是提交的任务队列，如果提交的任务大于最大线程数了，会优先放到这个任务队列中。 the queue to use for holding tasks before they are executed.  This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method.</p></li><li><p>threadFactory —— 利用 ThreadFactory#newThread 来创建 Thread，这里可以对 Thread 进行命名。the factory to use when the executor creates a new thread.</p></li><li><p>handler —— 执行不了了，wokerqueue 都塞不下了，就执行拒绝策略。可以自定义，用来重试任务，默认是直接丢掉。JDK 提供了 4 种。the handler to use when execution is blocked because the thread bounds and queue capacities are reached</p></li></ul><p>ThreadPoolExecutor 允许提供一个 Blocking Queue 来保存等待执行的任务。</p><ol><li>无界队列。LinkedBlockingQueue 默认的构造器就是无界的。<code>public LinkedBlockingQueue() { this(Integer.MAX_VALUE);}</code><ol start="2"><li>有界队列。ArrayBlockingQueue、有界的 LinkedBlockingQueue、PriorityBlockingQueue。</li></ol></li><li>同步移交。Synchronous Handoff。</li></ol><p>无界队列将不会执行拒绝策略，当然如果你的线程数大于了 Integer.MAX_VALUE 还是会执行的，前提是你到达这么多。一般情况就 OOM 了。所以《阿里巴巴 Java 开发规范》中不使用 Executors 创建线城池。</p><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ol><li><p>AbortPolicy：中止策略是默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException 调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p></li><li><p>DiscardPolicy：当新提交的任务无法保存到队列中等待执行时，抛弃策略会悄悄抛弃该任务。</p></li><li><p>CallerRunsPolicy：调用者运行（Caller-Runs）策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛弃异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行该任务。</p></li><li><p>DiscardOldestPolicy：抛弃最旧的（Discard-Oldest）策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，那么”抛弃最旧的“策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。</p></li></ol><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>对于非常大的或者无界的线程池，可以通过使用 SynchronousQueue 来避免任务排队，以及直接将任务从生产者移交给工作者线程。SynchronousQueque 不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入 SynchronousQueue 中，必须有另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么 ThreadPoolExecutor 将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。</p><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>许多情况下都需要使用定制的线程工厂方法。</p><p>例如，为线程池中的线程制定一个 UncaughtExceptionHandler，或者实例化一个定制的 Thread 类用于执行调试信息的记录。线程优先级（其实执行的时候优先级只是个参考），或者守护状态（也不建议），<strong>最常用的其实就是取个名字</strong>。</p><p>Pivatol 团队就封装了个 NamedThreadFactory，简单的封装，简单的应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.micrometer.core.instrument.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger sequence = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamedThreadFactory</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        <span class="keyword">int</span> seq = <span class="keyword">this</span>.sequence.getAndIncrement();</span><br><span class="line">        thread.setName(<span class="keyword">this</span>.prefix + (seq &gt; <span class="number">1</span> ? <span class="string">"-"</span> + seq : <span class="string">""</span>));</span><br><span class="line">        <span class="keyword">if</span> (!thread.isDaemon()) &#123;</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 相关的监控解决方案从 SpringBoot 2.0开始全面更改为Micrometer，不过要知道 Micrometer 与 Spring 属于同门，都是Pivotal旗下的产品。</p><h3 id="扩展-ThreadPoolexecutor"><a href="#扩展-ThreadPoolexecutor" class="headerlink" title="扩展 ThreadPoolexecutor"></a>扩展 ThreadPoolexecutor</h3><ul><li><p>beforeExecute</p></li><li><p>afterExecutor</p></li><li><p>terminated</p></li></ul><p>添加日志、计时、监视或统计信息收集的功能。无论任务是从 run 中正常返回，还是抛出一个异常而返回，afterExecute 都会被调用。如果是一个 Error 就不会。如果 beforeExecute 抛出一个 RuntimeException，那么任务将不被执行，并且 afterExecute 也不会被调用。</p><p>在线程池完成关闭操作时调用 terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后。terminated 可以用来释放Executor 在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志或者收集 finalize 统计信息等操作。</p><h1 id="Servlet-容器"><a href="#Servlet-容器" class="headerlink" title="Servlet 容器"></a>Servlet 容器</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h2 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h2><h2 id="Websphere-Application-Server"><a href="#Websphere-Application-Server" class="headerlink" title="Websphere Application Server"></a>Websphere Application Server</h2><p>IBM </p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="Nginx-服务器"><a href="#Nginx-服务器" class="headerlink" title="Nginx 服务器"></a>Nginx 服务器</h2><h2 id="Nginx-集群搭建"><a href="#Nginx-集群搭建" class="headerlink" title="Nginx 集群搭建"></a>Nginx 集群搭建</h2><p>引入虚拟 IP，keepalived</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL-执行过程"><a href="#MySQL-执行过程" class="headerlink" title="MySQL 执行过程"></a>MySQL 执行过程</h2><h2 id="那些索引"><a href="#那些索引" class="headerlink" title="那些索引"></a>那些索引</h2><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-Bean-的加载过程"><a href="#Spring-Bean-的加载过程" class="headerlink" title="Spring Bean 的加载过程"></a>Spring Bean 的加载过程</h2><h3 id="Spring-Bean-元信息配置阶段"><a href="#Spring-Bean-元信息配置阶段" class="headerlink" title="Spring Bean 元信息配置阶段"></a>Spring Bean 元信息配置阶段</h3><ul><li><p>基于 XML、Properties 配置</p><p>XMLBeanDefinitionReader#loadBeanDefinitions(String resourceUrl);</p><p>BeanDefinitionReader 的实现类 AbstractBeanDefinitionReader，而 AbstractBeanDefinitionReader 有三个实现类。分别对应 XML、Properties、Groovy 文件读取方式。现在都不推荐用这几个。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanDefinitionStoreException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">  <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">BeanNameGenerator <span class="title">getBeanNameGenerator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource var1)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... var1)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... var1)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span>, <span class="title">EnvironmentCapable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> ClassLoader beanClassLoader;</span><br><span class="line">  <span class="keyword">private</span> Environment environment;</span><br><span class="line">  <span class="keyword">private</span> BeanNameGenerator beanNameGenerator = <span class="keyword">new</span> DefaultBeanNameGenerator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> ResourceLoader) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resourceLoader = (ResourceLoader)<span class="keyword">this</span>.registry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">      <span class="keyword">this</span>.environment = ((EnvironmentCapable)<span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Resource[] var3 = resources;</span><br><span class="line">    <span class="keyword">int</span> var4 = resources.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">      Resource resource = var3[var5];</span><br><span class="line">      count += <span class="keyword">this</span>.loadBeanDefinitions((Resource)resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBeanDefinitions(location, (Set)<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//按照其他的模块的性情，这里应该是 doLoadBeanDefinitions ，其他重载方法就是转换下内容。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">this</span>.getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot load bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> count;</span><br><span class="line">      <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);</span><br><span class="line">          count = <span class="keyword">this</span>.loadBeanDefinitions(resources);</span><br><span class="line">          <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Collections.addAll(actualResources, resources);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        count = <span class="keyword">this</span>.loadBeanDefinitions((Resource)resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">          actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    String[] var3 = locations;</span><br><span class="line">    <span class="keyword">int</span> var4 = locations.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">      String location = var3[var5];</span><br><span class="line">      count += <span class="keyword">this</span>.loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p><ul><li><p>基于 注解 配置</p><p>就是配置 @Compment、 @Bean 等注解来实现，@Service 和 @Repository 里面有加 @Compment 只是为了让代码分层更清晰而已。</p></li><li><p>基于 Spring API 配置  </p><p>DefaultListableBeanFactory 实现了 BeanRegistry 接口，其中 registerBeanDefinition 方法就是在配置。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>一般是这个 GenericBeanDefinition 类，不管你是什么类，在我这，都叫 BeanDefinition ，而且在后面会有个 Merge 过程，将所有 BeanDefinition 再次转换成 <code>RootBeanDefinition</code> 然后命名为 mbd 进行各种操作。</p><h3 id="Spring-Bean-元信息解析阶段"><a href="#Spring-Bean-元信息解析阶段" class="headerlink" title="Spring Bean 元信息解析阶段"></a>Spring Bean 元信息解析阶段</h3><ul><li><p>面向资源 BeanDefinition 解析（里面有各种 Load 方法）</p><ul><li>BeanDefinitionReader<ul><li>XML 解析器 - BeanDefinitionParser</li></ul></li></ul></li><li><p>面向注解 BeanDefinition 解析</p><ul><li>AnnotatedBeanDefinitionReader<ul><li>资源<ul><li>类对象 - java.lang.Class</li></ul></li><li>底层<ul><li>条件评估 - ConditionEvaluator</li><li>Bean 范围解析 - ScopeMetadataResolver</li><li>BeanDefinition 解析 - 内部 API 实现</li><li>BeanDefinition 处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations</li><li>BeanDefinition 注册 - BeanDefinitionRegisty</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类没有子类，也不继承 Resource ,就是纯粹的解析注解的 BeanDefitionReader</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedBeanDefinitionReader</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个的实现有 DefaultListableBeanFactory,AnnotationConfigServletWebApplicationContext等等</span></span><br><span class="line">  <span class="comment">// 这也是个策略模式，通过构造器注入，使用不同 BeanDefinitionRegistry 来注册。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line">  <span class="comment">// 这里一般是 AnnotationBeanNameGenerator 以类名首字母小写生成 beanName</span></span><br><span class="line">  <span class="keyword">private</span> BeanNameGenerator beanNameGenerator;</span><br><span class="line">  <span class="comment">// 解析元信息相关的数据，这是个接口，里面就一个方法，方法返回值是ScopeMetadata ，而ScopeMetadata包括 proxy 的一些信息 public enum ScopProxyMode &#123;DEFAULT,NO,INTERFACE,TAGET_CLASS&#125;</span></span><br><span class="line">  <span class="keyword">private</span> ScopeMetadataResolver scopeMetadataResolver;</span><br><span class="line">  <span class="comment">// 这是做评估的 具体在它的 shouldSkip 方法是不是该跳过当前 Bean 注册与否 </span></span><br><span class="line">  <span class="keyword">private</span> ConditionEvaluator conditionEvaluator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">    <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, (ResourceLoader)<span class="keyword">null</span>);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    Class[] var2 = annotatedClasses;</span><br><span class="line">    <span class="keyword">int</span> var3 = annotatedClasses.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">      Class&lt;?&gt; annotatedClass = var2[var4];</span><br><span class="line">      <span class="keyword">this</span>.registerBean(annotatedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.doRegisterBean(annotatedClass, (Supplier)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (Class[])<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.doRegisterBean(annotatedClass, instanceSupplier, (String)<span class="keyword">null</span>, (Class[])<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; annotatedClass, String name, @Nullable Supplier&lt;T&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.doRegisterBean(annotatedClass, instanceSupplier, name, (Class[])<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.doRegisterBean(annotatedClass, (Supplier)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, qualifiers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.doRegisterBean(annotatedClass, (Supplier)<span class="keyword">null</span>, name, qualifiers);</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name, @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">      abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">      ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">      abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">      <span class="comment">// 这里命名了，就用你命名的，没命名就生成</span></span><br><span class="line">      String beanName = name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry);</span><br><span class="line">      AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">      <span class="keyword">int</span> var10;</span><br><span class="line">      <span class="keyword">int</span> var11;</span><br><span class="line">      <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class[] var9 = qualifiers;</span><br><span class="line">        var10 = qualifiers.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">          Class&lt;? extends Annotation&gt; qualifier = var9[var11];</span><br><span class="line">          <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">            abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">            abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BeanDefinitionCustomizer[] var13 = definitionCustomizers;</span><br><span class="line">      var10 = definitionCustomizers.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">        BeanDefinitionCustomizer customizer = var13[var11];</span><br><span class="line">        customizer.customize(abd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">      definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里你都用 Java API 方式配置了，一定有 BeanDefition 配置了。</p><h3 id="Spring-Bean-注册阶段"><a href="#Spring-Bean-注册阶段" class="headerlink" title="Spring Bean 注册阶段"></a>Spring Bean 注册阶段</h3><p>DefaultListableBeanFactory 实现了 BeanDefinitionRegistry 。它还有其他的实现类，关于 XML 、注解、Groovy、Reactive（响应式的，Josh Long 在 19年推特上有置顶 《Reactive Spring》）、还有其他的 GenericApplicationContext。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断参数是否合法</span></span><br><span class="line">  Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">  Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">  <span class="comment">// 这里进行一个转换</span></span><br><span class="line">  <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((AbstractBeanDefinition)beanDefinition).validate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var9) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, <span class="string">"Validation of bean definition failed"</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里判断是否存在响应的 BeanDefinition </span></span><br><span class="line">  <span class="comment">//beanDefinitionMap     </span></span><br><span class="line">  <span class="comment">//private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap(256);</span></span><br><span class="line"></span><br><span class="line">  BeanDefinition existingDefinition = (BeanDefinition)<span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Spring Boot 2.1 后有个开关，来看是否能够有相同 BeanDefition 存在，默认为 否</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 Role 默认是 0，在造器中设置为 0</span></span><br><span class="line">    <span class="comment">// 当前bean 定义的角色，初始化为 ROLE_APPLICATION ， 提示这是一个应用bean</span></span><br><span class="line">    <span class="comment">// 另外还有基础设施bean（仅供框架内部工作使用），和 支持bean</span></span><br><span class="line">    <span class="comment">// int ROLE_APPLICATION = 0;</span></span><br><span class="line">    <span class="comment">// int ROLE_SUPPORT = 1;</span></span><br><span class="line">    <span class="comment">// int ROLE_INFRASTRUCTURE = 2;</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName + <span class="string">"' with a framework-generated bean definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是同一个 BeanDefinition 那自己覆盖自己，没问题，</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName + <span class="string">"' with a different definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName + <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终还是放进去了</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里表明是不是 BeanFacotory 开始加载了。通常是 false </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasBeanCreationStarted()) &#123;</span><br><span class="line">      <span class="comment">// 细化 锁 粒度，针对当前 BeanDefinitionMap 进行一系列非原子操作</span></span><br><span class="line">      <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">        updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        updatedDefinitions.add(beanName);</span><br><span class="line">        <span class="comment">// 这里 BeanDefinitionNames 是一个 ArrayList，是线程不安全的，这里的目的是为了记住 BeanDefinition 的加载顺序。让这里保证 FIFO First In First Out 先进先出</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">          Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">          updatedSingletons.remove(beanName);</span><br><span class="line">          <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">      <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || <span class="keyword">this</span>.containsSingleton(beanName)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resetBeanDefinition(beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-BeanDefinition-合并阶段"><a href="#Spring-BeanDefinition-合并阶段" class="headerlink" title="Spring BeanDefinition 合并阶段"></a>Spring BeanDefinition 合并阶段</h3><ul><li>BeanDefinition 合并<ul><li>父子 BeanDefinition 合并</li><li>当前 BeanFactory 查找</li><li>层次性 BeanFactory 查找</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这个方法实际定义在 ConfigurableBeanFactory 中</span></span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">    <span class="comment">//这里通过递归的方式去查找父类</span></span><br><span class="line">    <span class="keyword">return</span> (BeanDefinition)(!<span class="keyword">this</span>.containsBeanDefinition(beanName) &amp;&amp; <span class="keyword">this</span>.getParentBeanFactory() <span class="keyword">instanceof</span> ConfigurableBeanFactory ? ((ConfigurableBeanFactory)<span class="keyword">this</span>.getParentBeanFactory()).getMergedBeanDefinition(beanName) : <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的 BeanDefinition 是从 GenericBeanDefinition 转换成 RootBeanDefinition。子的 BeanDeifinition 去合并（merge）父的 BeanDefinition 相关配置。</p><h3 id="Spring-Bean-Class-加载阶段"><a href="#Spring-Bean-Class-加载阶段" class="headerlink" title="Spring Bean Class 加载阶段"></a>Spring Bean Class 加载阶段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 AbstractBeanFactory 中，执行依赖查找的时候，doGetBean 会执行    </span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">  Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">  Object bean;</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName + <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="keyword">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">    <span class="comment">// 一般是为空</span></span><br><span class="line">    <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      String nameToLookup = <span class="keyword">this</span>.originalBeanName(name);</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里进行合并，将所有 BeanDefinition 转换为 RootBeanDefinition 进行操作。</span></span><br><span class="line">      RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      <span class="comment">//这里进行检查合并的 BeanDefinition</span></span><br><span class="line">      <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">      <span class="comment">// 这里是检查依赖</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      String[] var11;</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        var11 = dependsOn;</span><br><span class="line">        <span class="keyword">int</span> var12 = dependsOn.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var13 = <span class="number">0</span>; var13 &lt; var12; ++var13) &#123;</span><br><span class="line">          String dep = var11[var13];</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.getBean(dep);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException var24) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, var24);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 没有指定 Scope 默认是 Singleton ，会进这里</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="comment">//  这里的 getSingleton 方法在下面</span></span><br><span class="line">        <span class="comment">// spring-2</span></span><br><span class="line">        sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是 Lambda 表达式内容，这里的 createBean 在下面。这个 CreateBean是子类来实现的，具体在下面⬇️ </span></span><br><span class="line">            <span class="comment">// spring-1 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">        var11 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Object prototypeInstance;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">          prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bean = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String scopeName = mbd.getScope();</span><br><span class="line">        Scope scope = (Scope)<span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">        <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">            Object var4;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              var4 = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var4;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = <span class="keyword">this</span>.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException var23) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, var23);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException var26) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> var26;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeMismatchException var25) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> + ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, var25);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得 SingletonBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">  <span class="comment">// 这里是一个 ConcurentHashMap</span></span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 在 ObjectFactory 中找到这个 Bean 就直接返回了，下面是为 null 才会才会操作</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName, <span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line">      <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> recordSuppressedExceptions = <span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有找到会在这里进行 getObject，这里是没有实现的，具体的在上面的 Lambda 表达式中有。往上翻⬆️</span></span><br><span class="line">        <span class="comment">// 上面采用匿名类实现 SingletonFactory </span></span><br><span class="line">        <span class="comment">// spring-2</span></span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        newSingleton = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException var16) &#123;</span><br><span class="line">        singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> var16;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeanCreationException var17) &#123;</span><br><span class="line">        BeanCreationException ex = var17;</span><br><span class="line">        <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">          Iterator var8 = <span class="keyword">this</span>.suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">            Exception suppressedException = (Exception)var8.next();</span><br><span class="line">            ex.addRelatedCause(suppressedException);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">          <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个是 AbstractBeanFactory 的子类进行实现的。具体的类名称，叫AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// spring-1 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">  <span class="comment">// 这里的 resolveBeanClass </span></span><br><span class="line">  Class&lt;?&gt; resolvedClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mbdToUse.prepareMethodOverrides();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Validation of method overrides failed"</span>, var9);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object beanInstance;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    beanInstance = <span class="keyword">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">    <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, var10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 doCreateBean 在下面实例化 Bean 中有讲解 ⬇️</span></span><br><span class="line">    <span class="comment">// spring-3</span></span><br><span class="line">    beanInstance = <span class="keyword">this</span>.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;</span><br><span class="line">    <span class="keyword">throw</span> var7;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, var8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里就是在 RootBeanDefinition 进行 getBeanClass 操作</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveBeanClass(RootBeanDefinition mbd, String beanName, Class&lt;?&gt;... typesToMatch) <span class="keyword">throws</span> CannotLoadBeanClassException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前是否有 BeanClass</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里判断 Java 安全方面内容有没有激活，如果激活了，就不等于空，那就以安全的方式来resolveBeanClass</span></span><br><span class="line">      <span class="keyword">return</span> System.getSecurityManager() != <span class="keyword">null</span> ? (Class)AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//这里来 resovleBeanClass 具体内容看下面⬇️第六步</span></span><br><span class="line">        <span class="comment">// spring-4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">      &#125;, <span class="keyword">this</span>.getAccessControlContext()) : <span class="keyword">this</span>.doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (PrivilegedActionException var6) &#123;</span><br><span class="line">    ClassNotFoundException ex = (ClassNotFoundException)var6.getException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException var7) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), var7);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (LinkageError var8) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), var8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里来 doResovleBeanClass</span></span><br><span class="line"><span class="comment">// spring-4</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; doResolveBeanClass(RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">// 这里有两个 ClassLoader，一个是当前 BeanFactory 的 ClassLoader ，默认是 AppClassloader</span></span><br><span class="line">  ClassLoader beanClassLoader = <span class="keyword">this</span>.getBeanClassLoader();</span><br><span class="line">  <span class="comment">// 这是一个 dynamicClassLoader</span></span><br><span class="line">  ClassLoader dynamicLoader = beanClassLoader;</span><br><span class="line">  <span class="keyword">boolean</span> freshResolve = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 一般这里都不会激活 start</span></span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(typesToMatch)) &#123;</span><br><span class="line">    ClassLoader tempClassLoader = <span class="keyword">this</span>.getTempClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (tempClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      dynamicLoader = tempClassLoader;</span><br><span class="line">      freshResolve = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (tempClassLoader <span class="keyword">instanceof</span> DecoratingClassLoader) &#123;</span><br><span class="line">        DecoratingClassLoader dcl = (DecoratingClassLoader)tempClassLoader;</span><br><span class="line">        Class[] var8 = typesToMatch;</span><br><span class="line">        <span class="keyword">int</span> var9 = typesToMatch.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">          Class&lt;?&gt; typeToMatch = var8[var10];</span><br><span class="line">          dcl.excludeClass(typeToMatch.getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一般这里都不会激活 end</span></span><br><span class="line">  <span class="comment">//这里获取 BeanClassName</span></span><br><span class="line">  String className = mbd.getBeanClassName();</span><br><span class="line">  <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里评估一下 BeanClass，有时候 BeanClass 的名称和这个名称是不一样的</span></span><br><span class="line">    Object evaluated = <span class="keyword">this</span>.evaluateBeanDefinitionString(className, mbd);</span><br><span class="line">    <span class="keyword">if</span> (!className.equals(evaluated)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (evaluated <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Class)evaluated;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(evaluated <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid class name expression result: "</span> + evaluated);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      className = (String)evaluated;</span><br><span class="line">      freshResolve = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里一般也是 false，不会走这里</span></span><br><span class="line">    <span class="keyword">if</span> (freshResolve) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dynamicLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> dynamicLoader.loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var12) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Could not load class ["</span> + className + <span class="string">"] from "</span> + dynamicLoader + <span class="string">": "</span> + var12);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 和这里一样</span></span><br><span class="line">      <span class="keyword">return</span> ClassUtils.forName(className, dynamicLoader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里才是关键</span></span><br><span class="line">  <span class="keyword">return</span> mbd.resolveBeanClass(beanClassLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是 AbstractBeanDefinition 中的方法，这里利用反射来加载 Bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; resolveBeanClass(<span class="meta">@Nullable</span> ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  String className = <span class="keyword">this</span>.getBeanClassName();</span><br><span class="line">  <span class="keyword">if</span> (className == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Class&lt;?&gt; resolvedClass = ClassUtils.forName(className, classLoader);</span><br><span class="line">    <span class="keyword">this</span>.beanClass = resolvedClass;</span><br><span class="line">    <span class="keyword">return</span> resolvedClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 BeanDefinition 变成 Class 的操作已经结束。一般情况下，就是利用 加载 BeanFactory  的ClassLoader来加载，只是多了个 Java 安全的校验加载。</p><h3 id="Spring-Bean-实例化前阶段"><a href="#Spring-Bean-实例化前阶段" class="headerlink" title="Spring Bean 实例化前阶段"></a>Spring Bean 实例化前阶段</h3><p>主要是下面这个接口，在Spring 5前面有个Adpter类，就是和 WebMvcConfigurerAdapter 一样，为了适配之后的类。继承这个接口，实现 postProcessBeforeInstantiation 方法，就可以对 Bean 实例化前进行操作。<em>增强事务功能就是对这个方法进行了改造。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以返回一个代理对象，为 null 就是不做改变，具体在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果上面返回对象不为空，那么马上就会执行这一步操作，为空，则在 population 中执行。属性填充后执行</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// 这里创建 Bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">  <span class="comment">// 这个就是上面的 BeanDefinition 转换为 Class 的调用</span></span><br><span class="line">  Class&lt;?&gt; resolvedClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    mbdToUse.prepareMethodOverrides();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Validation of method overrides failed"</span>, var9);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object beanInstance;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里进行 Bean 的前置处理，具体方法实现内容    如下⬇️</span></span><br><span class="line">    <span class="comment">// 对应上面的 postProcessBeforeInstantiation 方法，如果返回了对象，则直接跳过下面的 doCreateBean 方法。</span></span><br><span class="line">    <span class="comment">// spring-5</span></span><br><span class="line">    beanInstance = <span class="keyword">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">    <span class="comment">// 就是这里对 Bean 进行了判断，如果实例化前就把这个 Bean 给返回了，那就不用执行下面的操作le</span></span><br><span class="line">    <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, var10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    beanInstance = <span class="keyword">this</span>.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;</span><br><span class="line">    <span class="keyword">throw</span> var7;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, var8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// spring-5</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  Object bean = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">//目标类型  </span></span><br><span class="line">      Class&lt;?&gt; targetType = <span class="keyword">this</span>.determineTargetType(beanName, mbd);</span><br><span class="line">      <span class="comment">// 这里就是判断，执行前置操作 applyBeanPostProcessorsBeforeInstantiation 这里面的内容其实就是 获得 BeanPostProcessor 然后遍历出 InstantiationAwareBeanPostProcessor 执行 postProcessBeforeInstantiation 方法。这里可以来个狸猫换太子，用代理对象替换 Bean</span></span><br><span class="line">      <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">        <span class="comment">// 如果这里的 Bean 不为空，马上执行 后置操作 postProcessAfterInitialization#postProcessAfterInitialization()</span></span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mbd.beforeInstantiationResolved = bean != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// spring-3</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = (BeanWrapper)<span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span>(mbd.postProcessingLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 合并 BeanDefinition 前置操作</span></span><br><span class="line">        <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Post-processing of merged bean definition failed"</span>, var17);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里检查循环依赖</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里执行 属性填充 功能，具体代码在下面</span></span><br><span class="line">    <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="comment">// 这里是初始化 Bean ，初始化 Bean 才执行 postProcessBeforeInstantiation 这个操作，具体的在下面 ⬇️</span></span><br><span class="line">    <span class="comment">// spring-6</span></span><br><span class="line">    exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var18 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (BeanCreationException)var18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, var18);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    Object earlySingletonReference = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; <span class="keyword">this</span>.hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = <span class="keyword">this</span>.getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);</span><br><span class="line">        String[] var12 = dependentBeans;</span><br><span class="line">        <span class="keyword">int</span> var13 = dependentBeans.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">          String dependentBean = var12[var14];</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + <span class="string">"] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var16) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, var16);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老版本的 Spring 中，是有个 else&#123;return;&#125;的，不过是多此一举，下面的 esle 包裹到了方法结束</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      Iterator var5 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        BeanPostProcessor bp = (BeanPostProcessor)var5.next();</span><br><span class="line">        <span class="comment">// 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法</span></span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">          <span class="comment">// 返回值为是否继续填充 Bean</span></span><br><span class="line">          <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">            continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation)&#123;return;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (continueWithPropertyPopulation) &#123;</span><br><span class="line">      PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">1</span> || mbd.getResolvedAutowireMode() == <span class="number">2</span>) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues((PropertyValues)pvs);</span><br><span class="line">        <span class="comment">//这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//根据名称自动注入</span></span><br><span class="line">          <span class="keyword">this</span>.autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="comment">//根据类型自动注入</span></span><br><span class="line">          <span class="keyword">this</span>.autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> hasInstAwareBpps = <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">      <span class="keyword">boolean</span> needsDepCheck = mbd.getDependencyCheck() != <span class="number">0</span>;</span><br><span class="line">      PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">          pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var9 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">          BeanPostProcessor bp = (BeanPostProcessor)var9.next();</span><br><span class="line">          <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">            PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">              <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">          filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// spring-6</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法在下面，就是执行各种 Aware 接口 ⬇️</span></span><br><span class="line">    <span class="comment">// spring-7</span></span><br><span class="line">    <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>, beanName, <span class="string">"Invocation of init method failed"</span>, var6);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// spring-7</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">      ((BeanNameAware)bean).setBeanName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">      ClassLoader bcl = <span class="keyword">this</span>.getBeanClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">      ((BeanFactoryAware)bean).setBeanFactory(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-实例化阶段"><a href="#Spring-Bean-实例化阶段" class="headerlink" title="Spring Bean 实例化阶段"></a>Spring Bean 实例化阶段</h3><ul><li>传统实例化方式<ul><li>实例化策略 - InstantiationStrategy</li><li>构造器依赖注入（这里的一个方法有几百行代码，去验证，加载，如果参数比较多，不建议构造器注入）</li></ul></li></ul><p>实例化就是上面的 doCreateBean 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">       <span class="comment">// 这里引入一个 Wrapper 一个 Bean 实例的包装，可以做很多事</span></span><br><span class="line">       BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">         <span class="comment">//    private final ConcurrentMap&lt;String, BeanWrapper&gt; factoryBeanInstanceCache;</span></span><br><span class="line">     </span><br><span class="line">         instanceWrapper = (BeanWrapper)<span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果 这个 wrapper 为空，就去创建，一般会进这里</span></span><br><span class="line">       <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 这个 createBeanInstance 方法在下面 ⬇️</span></span><br><span class="line">         <span class="comment">// spring-8</span></span><br><span class="line">         instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">       Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">       <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">         mbd.resolvedTargetType = beanType;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">synchronized</span>(mbd.postProcessingLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 合并 BeanDefinition 前置操作</span></span><br><span class="line">             <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Post-processing of merged bean definition failed"</span>, var17);</span><br><span class="line">           &#125;</span><br><span class="line">     </span><br><span class="line">           mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 这里检查循环依赖</span></span><br><span class="line">       <span class="keyword">boolean</span> earlySingletonExposure = mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">       <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">           <span class="keyword">this</span>.logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         <span class="keyword">this</span>.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       Object exposedObject = bean;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 这里执行 属性填充 功能，具体代码在下面</span></span><br><span class="line">         <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">         <span class="comment">// 这里是初始化 Bean ，初始化 Bean 才执行 postProcessBeforeInstantiation 这个操作，具体的在下面 ⬇️</span></span><br><span class="line">         <span class="comment">// spring-6</span></span><br><span class="line">         exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var18 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123;</span><br><span class="line">           <span class="keyword">throw</span> (BeanCreationException)var18;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, var18);</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">         Object earlySingletonReference = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">         <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">             exposedObject = earlySingletonReference;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; <span class="keyword">this</span>.hasDependentBean(beanName)) &#123;</span><br><span class="line">             String[] dependentBeans = <span class="keyword">this</span>.getDependentBeans(beanName);</span><br><span class="line">             Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);</span><br><span class="line">             String[] var12 = dependentBeans;</span><br><span class="line">             <span class="keyword">int</span> var13 = dependentBeans.length;</span><br><span class="line">     </span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">               String dependentBean = var12[var14];</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                 actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     </span><br><span class="line">             <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + <span class="string">"] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">         <span class="keyword">return</span> exposedObject;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var16) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, var16);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//AbstractAutowireCapableBeanFactory</span></span><br><span class="line">     <span class="comment">// spring-8</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 这里的 resovleBeanClass 就是上面提到的 BeanClass 加载，</span></span><br><span class="line">       Class&lt;?&gt; beanClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 这是一个函数式接口，在 Spring5 之前不支持这个，一般用 @Compment 来声明的，是为 null</span></span><br><span class="line">         Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">         <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 这个也一般不会执行，根据 BeanFactoryName 去获取 BeanWrapper</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 更多的是执行这个,resoled 判断对象是否被处理过</span></span><br><span class="line">           <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span>(mbd.constructorArgumentLock) &#123;</span><br><span class="line">               <span class="comment">// spring-11</span></span><br><span class="line">               <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 resolved = <span class="keyword">true</span>;</span><br><span class="line">                 autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     <span class="comment">//一般这里是不满足的</span></span><br><span class="line">           <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">             <span class="keyword">return</span> autowireNecessary ? <span class="keyword">this</span>.autowireConstructor(beanName, mbd, (Constructor[])<span class="keyword">null</span>, (Object[])<span class="keyword">null</span>) : <span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 一般这里不满足，直接跳过</span></span><br><span class="line">             <span class="comment">// spring-10</span></span><br><span class="line">             Constructor&lt;?&gt;[] ctors = <span class="keyword">this</span>.determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">             <span class="keyword">if</span> (ctors == <span class="keyword">null</span> &amp;&amp; mbd.getResolvedAutowireMode() != <span class="number">3</span> &amp;&amp; !mbd.hasConstructorArgumentValues() &amp;&amp; ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">               <span class="comment">//这里通常来说是null</span></span><br><span class="line">               ctors = mbd.getPreferredConstructors();</span><br><span class="line">               <span class="comment">// 这个 instantiaeaBean 调用无参构造器 方法如下</span></span><br><span class="line">               <span class="comment">// 之前的代码是 if(ctors!=null)&#123;return autowireConstructor(beanName, mbd, ctors, (Object[])null)&#125;</span></span><br><span class="line">               <span class="keyword">return</span> ctors != <span class="keyword">null</span> ? <span class="keyword">this</span>.autowireConstructor(beanName, mbd, ctors, (Object[])<span class="keyword">null</span>) : <span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 这边是根据有参构造器 注入</span></span><br><span class="line">               <span class="comment">// 一般情况下的 Bean 走的这个方法，不做特殊处理</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//AbstractAutowireCapableBeanFactory</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Object beanInstance;</span><br><span class="line">                 <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     beanInstance = AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                       <span class="comment">// instantiate(mbd, beanName, this) 这个方法是重点</span></span><br><span class="line">                         <span class="keyword">return</span> thisx.getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">                     &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//这里就是 通过传统的方式，InstantiationStrategy 默认是CglibSubclassingInstantiationStrategy 这里//  就清楚了，默认采用 Cglib 方法代理生成 Bean。在无参构造器方法中有写。然后这个 instantiate 方法是// SimpleInstantiationStrategy 类的，具体方法如下⬇️</span></span><br><span class="line">                   <span class="comment">// spring-9</span></span><br><span class="line">                     beanInstance = <span class="keyword">this</span>.getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">     </span><br><span class="line">                 BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">                 <span class="keyword">this</span>.initBeanWrapper(bw);</span><br><span class="line">                 <span class="keyword">return</span> bw;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, var6);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">//AbstractAutowireCapableBeanFactory</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br><span class="line">             <span class="keyword">this</span>.parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line">             <span class="keyword">this</span>.allowCircularReferences = <span class="keyword">true</span>;</span><br><span class="line">             <span class="keyword">this</span>.allowRawInjectionDespiteWrapping = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">this</span>.ignoredDependencyTypes = <span class="keyword">new</span> HashSet();</span><br><span class="line">             <span class="keyword">this</span>.ignoredDependencyInterfaces = <span class="keyword">new</span> HashSet();</span><br><span class="line">             <span class="keyword">this</span>.currentlyCreatedBean = <span class="keyword">new</span> NamedThreadLocal(<span class="string">"Currently created bean"</span>);</span><br><span class="line">             <span class="keyword">this</span>.factoryBeanInstanceCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">             <span class="keyword">this</span>.factoryMethodCandidateCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">             <span class="keyword">this</span>.filteredPropertyDescriptorsCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">             <span class="keyword">this</span>.ignoreDependencyInterface(BeanNameAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">             <span class="keyword">this</span>.ignoreDependencyInterface(BeanFactoryAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">             <span class="keyword">this</span>.ignoreDependencyInterface(BeanClassLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//SimpleInstantiationStrategy</span></span><br><span class="line">     <span class="comment">// spring-9</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Object</span> <span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这里判断是否方法覆盖</span></span><br><span class="line">             <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">                 Constructor constructorToUse;</span><br><span class="line">                 <span class="keyword">synchronized</span>(bd.constructorArgumentLock) &#123;</span><br><span class="line">                   <span class="comment">// 这里看是否已经处理掉 构造器或者工厂方法</span></span><br><span class="line">                     constructorToUse = (Constructor)bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">                     <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//然后进这个方法</span></span><br><span class="line">                         Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                       <span class="comment">// 这里判断，是否是个接口，是接口直接报错，抛出异常。当然 JPA/MyBatis plus 类似处理注解 AutowiredAnnotationBeanPostProcessor </span></span><br><span class="line">                       <span class="comment">// implements BeanPostProcessor, BeanFactoryAware 实现这两个接口，然后做 Bean 前置处理，将接口语义转换成实体类，或者用JDK/Cglib做提升，生成代理类</span></span><br><span class="line">                         <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">     </span><br><span class="line">                         <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">// 这里又要和安全相关的，因为这里要调用反射</span></span><br><span class="line">                             <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 clazz.getClass();</span><br><span class="line">                                 constructorToUse = (Constructor)AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                                     <span class="keyword">return</span> clazz.getDeclaredConstructor();</span><br><span class="line">                                 &#125;);</span><br><span class="line">                             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 这里得到默认的无参构造器</span></span><br><span class="line">                                 constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">                             &#125;</span><br><span class="line">     <span class="comment">//  resolvedConstructorOrFactoryMethod 这个就不为空了，对应前面的</span></span><br><span class="line">                           <span class="comment">// spring-11</span></span><br><span class="line">                             bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, var9);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">     <span class="comment">//这里面就是 利用反射创建，newInstance，默认的无参构造器</span></span><br><span class="line">               <span class="comment">// 这个阶段，还没有完成属性的 创建和初始化。</span></span><br><span class="line">                 <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">this</span>.instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">// spring-10</span></span><br><span class="line">     <span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">             <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">                 Iterator var3 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line">     </span><br><span class="line">                 <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                     BeanPostProcessor bp = (BeanPostProcessor)var3.next();</span><br><span class="line">                     <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                         SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">                       <span class="comment">// 实现一种拦截机制，来取调用哪种构造器</span></span><br><span class="line">                         Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">                         <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             <span class="keyword">return</span> ctors;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器注入，是按照类型注入。也可以通过 @Qualifier指定</p><h3 id="Spring-Bean-实例化后阶段"><a href="#Spring-Bean-实例化后阶段" class="headerlink" title="Spring Bean 实例化后阶段"></a>Spring Bean 实例化后阶段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</span></span><br><span class="line"><span class="comment">//判断当前 Bean 是不是要属性填入，如果是，则返回 true，如果不是返回 false。也就是这里可以做一个拦截。具体代码如下</span></span><br><span class="line"><span class="comment">//属性填充阶段后，再去操作，populateBean 方法</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// 该方法是 对 Bean 进行属性填充。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老版本的 Spring 中，是有个 else&#123;return;&#125;的，不过是多此一举，下面的 esle 包裹到了方法结束</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      Iterator var5 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        BeanPostProcessor bp = (BeanPostProcessor)var5.next();</span><br><span class="line">        <span class="comment">// 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法</span></span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">          <span class="comment">// 返回值为是否继续填充 Bean，如果为 false，则取反，执行 if 里面的操作。就会跳过后面的属性填充。</span></span><br><span class="line">          <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">            <span class="comment">// 这里为 false ，下面的 if 方法不会执行。</span></span><br><span class="line">            continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation)&#123;return;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (continueWithPropertyPopulation) &#123;</span><br><span class="line">      PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">1</span> || mbd.getResolvedAutowireMode() == <span class="number">2</span>) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues((PropertyValues)pvs);</span><br><span class="line">        <span class="comment">//这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//根据名称自动注入</span></span><br><span class="line">          <span class="keyword">this</span>.autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="comment">//根据类型自动注入</span></span><br><span class="line">          <span class="keyword">this</span>.autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> hasInstAwareBpps = <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">      <span class="keyword">boolean</span> needsDepCheck = mbd.getDependencyCheck() != <span class="number">0</span>;</span><br><span class="line">      PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">          pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var9 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">          BeanPostProcessor bp = (BeanPostProcessor)var9.next();</span><br><span class="line">          <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">            PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">              <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">          filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 其实在 AbstractAutowiredCapableBeanFactory 中，如果在 doCreateBean 执行之前，就已经返回了 Bean 实例，那么 </span></span><br><span class="line"><span class="comment">// doCreateBean 是不会执行的，为保证 postProcessAfterInstantiation 在 Bean 实例化后一定执行，下面的代码就展示了如何实现的</span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// spring-12</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  Object bean = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      Class&lt;?&gt; targetType = <span class="keyword">this</span>.determineTargetType(beanName, mbd);</span><br><span class="line">      <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这个方法</span></span><br><span class="line">        bean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mbd.beforeInstantiationResolved = bean != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// 创建 Bean</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">        Class&lt;?&gt; resolvedClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">            mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mbdToUse.prepareMethodOverrides();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Validation of method overrides failed"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// spring-12</span></span><br><span class="line">          <span class="comment">// 这里是解析实例化前，如果有 Bean 实例，就直接返回，跳过下面的 doCreateBean 方法。</span></span><br><span class="line">            beanInstance = <span class="keyword">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">            <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> beanInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            beanInstance = <span class="keyword">this</span>.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var7;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, var8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">  Iterator var3 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">    BeanPostProcessor bp = (BeanPostProcessor)var3.next();</span><br><span class="line">    <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">      Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  Object result = existingBean;</span><br><span class="line"></span><br><span class="line">  Object current;</span><br><span class="line">  <span class="keyword">for</span>(Iterator var4 = <span class="keyword">this</span>.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123;</span><br><span class="line">    BeanPostProcessor processor = (BeanPostProcessor)var4.next();</span><br><span class="line">    current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是为保证 postProcessAfterInitialization 方法<code>一定</code>执行，其实有两处互斥的地方调用了该方法。</p><h3 id="Spring-Bean-属性赋值前阶段"><a href="#Spring-Bean-属性赋值前阶段" class="headerlink" title="Spring Bean 属性赋值前阶段"></a>Spring Bean 属性赋值前阶段</h3><p>populateBean 就是属性赋值阶段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老版本的 Spring 中，是有个 else&#123;return;&#125;的，不过是多此一举，下面的 esle 包裹到了方法结束</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      Iterator var5 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        BeanPostProcessor bp = (BeanPostProcessor)var5.next();</span><br><span class="line">        <span class="comment">// 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法</span></span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">          <span class="comment">// 返回值为是否继续填充 Bean</span></span><br><span class="line">          <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">            continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation)&#123;return;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (continueWithPropertyPopulation) &#123;</span><br><span class="line">      PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">1</span> || mbd.getResolvedAutowireMode() == <span class="number">2</span>) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues((PropertyValues)pvs);</span><br><span class="line">        <span class="comment">//这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//根据名称自动注入</span></span><br><span class="line">          <span class="keyword">this</span>.autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="comment">//根据类型自动注入</span></span><br><span class="line">          <span class="keyword">this</span>.autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> hasInstAwareBpps = <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">      <span class="keyword">boolean</span> needsDepCheck = mbd.getDependencyCheck() != <span class="number">0</span>;</span><br><span class="line">      PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">          pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var9 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">          BeanPostProcessor bp = (BeanPostProcessor)var9.next();</span><br><span class="line">          <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">            <span class="comment">// 在赋值前阶段，会执行下面的 postProcessProperties 方法</span></span><br><span class="line">            PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="comment">//如果这里为空，则执行下面的方法</span></span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">              <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">          filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-Aware-接口回调阶段"><a href="#Spring-Bean-Aware-接口回调阶段" class="headerlink" title="Spring Bean Aware 接口回调阶段"></a>Spring Bean Aware 接口回调阶段</h3><p>按顺序执行</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li><li>EnvironmentAware //这个和接下来是 applicationContext 执行的</li><li>EmbeddedValueResolverAware</li><li>ResourceLoaderAware</li><li>ApplicationEventPublisherAware</li><li>MessageSourceAware</li><li>ApplicationContextAware</li></ul><p>在执行 populateBean 方法之后，执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware)bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ClassLoader bcl = <span class="keyword">this</span>.getBeanClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware)bean).setBeanFactory(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object wrappedBean = bean;</span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>, beanName, <span class="string">"Invocation of init method failed"</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrappedBean;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            instanceWrapper = (BeanWrapper)<span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">        <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            mbd.resolvedTargetType = beanType;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mbd.postProcessingLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Post-processing of merged bean definition failed"</span>, var17);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> earlySingletonExposure = mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 这里属性填入</span></span><br><span class="line">            <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">          <span class="comment">//这里执行 各种 aware</span></span><br><span class="line">            exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var18 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (BeanCreationException)var18;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, var18);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            Object earlySingletonReference = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                    exposedObject = earlySingletonReference;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; <span class="keyword">this</span>.hasDependentBean(beanName)) &#123;</span><br><span class="line">                    String[] dependentBeans = <span class="keyword">this</span>.getDependentBeans(beanName);</span><br><span class="line">                    Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);</span><br><span class="line">                    String[] var12 = dependentBeans;</span><br><span class="line">                    <span class="keyword">int</span> var13 = dependentBeans.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">                        String dependentBean = var12[var14];</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                            actualDependentBeans.add(dependentBean);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + <span class="string">"] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">            <span class="keyword">return</span> exposedObject;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var16) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, var16);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 后面几个 Aware</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">                ((EnvironmentAware)bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">                ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware)bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">                ((MessageSourceAware)bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware)bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ApplicationContextAwareProcessor implements BeanPostProcessor </span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware || bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware || bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">            acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.invokeAwareInterfaces(bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.invokeAwareInterfaces(bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractApplicationContext</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        beanFactory.setBeanClassLoader(<span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, <span class="keyword">this</span>.getEnvironment()));</span><br><span class="line">   <span class="comment">//这一步</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">        beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(<span class="string">"loadTimeWeaver"</span>)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">"environment"</span>)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(<span class="string">"environment"</span>, <span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">"systemProperties"</span>)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(<span class="string">"systemProperties"</span>, <span class="keyword">this</span>.getEnvironment().getSystemProperties());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">"systemEnvironment"</span>)) &#123;</span><br><span class="line">            beanFactory.registerSingleton(<span class="string">"systemEnvironment"</span>, <span class="keyword">this</span>.getEnvironment().getSystemEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-初始化前阶段"><a href="#Spring-Bean-初始化前阶段" class="headerlink" title="Spring Bean 初始化前阶段"></a>Spring Bean 初始化前阶段</h3><p>BeanPostProcessor#postProcessBeforeInitialization</p><h3 id="Spring-Bean-初始化阶段"><a href="#Spring-Bean-初始化阶段" class="headerlink" title="Spring Bean 初始化阶段"></a>Spring Bean 初始化阶段</h3><p>依次往下执行</p><p>注解 @Postconstructor</p><p>接口 InitializingBean </p><p>元信息配置 @Bean（init-method=”init”)</p><h3 id="Spring-Bean-初始化后阶段"><a href="#Spring-Bean-初始化后阶段" class="headerlink" title="Spring Bean 初始化后阶段"></a>Spring Bean 初始化后阶段</h3><p>BeanPostProcessor#postProcessAfterInitialization</p><h3 id="Spring-Bean-初始化完成阶段"><a href="#Spring-Bean-初始化完成阶段" class="headerlink" title="Spring Bean 初始化完成阶段"></a>Spring Bean 初始化完成阶段</h3><p>SmartInitializingSingleton#afterSingletonsInstantiated</p><p>适合 ApplicationContext 中回调</p><h3 id="Spring-Bean-销毁前阶段"><a href="#Spring-Bean-销毁前阶段" class="headerlink" title="Spring Bean 销毁前阶段"></a>Spring Bean 销毁前阶段</h3><p>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</p><h3 id="Spring-Bean-销毁阶段"><a href="#Spring-Bean-销毁阶段" class="headerlink" title="Spring Bean 销毁阶段"></a>Spring Bean 销毁阶段</h3><p>执行次序依次往下执行</p><ul><li>@PreDestroy 标注方法</li><li>实现 DisposableBean 接口的 destroy() 方法</li><li>自定义销毁方法 (destroy-mehod)</li></ul><h3 id="Spring-Bean-垃圾收集"><a href="#Spring-Bean-垃圾收集" class="headerlink" title="Spring Bean 垃圾收集"></a>Spring Bean 垃圾收集</h3><ul><li>Bean 垃圾回收（GC）<ul><li>关闭 Spring 容器（应用上下文）</li><li>执行 GC</li><li>Spring Bean 覆盖的 finalize() 方法被回调</li></ul></li></ul><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><p>来源于 <a href="https://juejin.cn/post/6844903608224333838#heading-9" target="_blank" rel="noopener">https://juejin.cn/post/6844903608224333838#heading-9</a></p><p>人家是专门做面试方向的，可以关注公众号，支持一下 Java Guide，只是讲了最基本的 Java 面试题，还不错。</p><h3 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/5/20/1637b08b98619455?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="事务的特性"></p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="Spring事务管理接口："><a href="#Spring事务管理接口：" class="headerlink" title="Spring事务管理接口："></a>Spring事务管理接口：</h3><ul><li><strong>PlatformTransactionManager：</strong> （平台）事务管理器</li><li><strong>TransactionDefinition：</strong> 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li><li><strong>TransactionStatus：</strong> 事务运行状态</li></ul><p><strong>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</strong></p><h4 id="PlatformTransactionManager接口介绍"><a href="#PlatformTransactionManager接口介绍" class="headerlink" title="PlatformTransactionManager接口介绍"></a>PlatformTransactionManager接口介绍</h4><p><strong>Spring并不直接管理事务，而是提供了多种事务管理器</strong> ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： <strong>org.springframework.transaction.PlatformTransactionManager</strong> ，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><h4 id="PlatformTransactionManager接口"><a href="#PlatformTransactionManager接口" class="headerlink" title="PlatformTransactionManager接口"></a>PlatformTransactionManager接口</h4><p>PlatformTransactionManager接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>...</span>&#123;  </span><br><span class="line">    <span class="comment">// Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// Perform a rollback of the given transaction（对执行的事务进行回滚）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Spring中PlatformTransactionManager根据不同持久层框架所对应的接口实现类,几个比较常见的如下图所示</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/5/20/1637b21877cf626d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="PlatformTransactionManager根据不同持久层框架所对应的接口实现"></p><h4 id="TransactionDefinition接口介绍"><a href="#TransactionDefinition接口介绍" class="headerlink" title="TransactionDefinition接口介绍"></a>TransactionDefinition接口介绍</h4><p>事务管理器接口 <strong>PlatformTransactionManager</strong> 通过 <strong>getTransaction(TransactionDefinition definition)</strong> 方法来得到一个事务，这个方法里面的参数是 <strong>TransactionDefinition类</strong> ，这个类就定义了一些基本的事务属性。</p><p><strong>那么什么是事务属性呢？</strong></p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/5/20/1637b43a47916b2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="事务属性"></p><h4 id="TransactionDefinition接口中的方法如下："><a href="#TransactionDefinition接口中的方法如下：" class="headerlink" title="TransactionDefinition接口中的方法如下："></a>TransactionDefinition接口中的方法如下：</h4><p>TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。</p><p>我下面只是列出了TransactionDefinition接口中的方法而没有给出接口中定义的常量，该接口中的常量信息会在后面依次介绍到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="comment">//返回事务的名字</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">// 返回是否优化为只读事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务隔离级别："><a href="#事务隔离级别：" class="headerlink" title="事务隔离级别："></a>事务隔离级别：</h3><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致一下的问题。</p><ul><li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p></li><li><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p></li><li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p></li><li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></li></ul><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为     1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导        致A再读自己的工资时工资变为  2000；这就是不可重复读。</p><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>     允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>     对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>     最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h4 id="事务传播行为（为了解决业务层方法之间互相调用的事务问题）："><a href="#事务传播行为（为了解决业务层方法之间互相调用的事务问题）：" class="headerlink" title="事务传播行为（为了解决业务层方法之间互相调用的事务问题）："></a>事务传播行为（为了解决业务层方法之间互相调用的事务问题）：</h4><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 <strong>PROPAGATION_NESTED</strong> 是 Spring 所特有的。以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</p><h4 id="事务超时属性-一个事务允许执行的最长时间"><a href="#事务超时属性-一个事务允许执行的最长时间" class="headerlink" title="事务超时属性(一个事务允许执行的最长时间)"></a>事务超时属性(一个事务允许执行的最长时间)</h4><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p><h4 id="事务只读属性（对事物资源是否执行只读操作）"><a href="#事务只读属性（对事物资源是否执行只读操作）" class="headerlink" title="事务只读属性（对事物资源是否执行只读操作）"></a>事务只读属性（对事物资源是否执行只读操作）</h4><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p><h4 id="回滚规则（定义事务回滚规则）"><a href="#回滚规则（定义事务回滚规则）" class="headerlink" title="回滚规则（定义事务回滚规则）"></a>回滚规则（定义事务回滚规则）</h4><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><h2 id="TransactionStatus接口介绍"><a href="#TransactionStatus接口介绍" class="headerlink" title="TransactionStatus接口介绍"></a>TransactionStatus接口介绍</h2><p>TransactionStatus 接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息.</p><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。</p><p><strong>TransactionStatus接口接口内容如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h2><p><strong>首先，这只能作用于方法层级上面，字段层级不行</strong>。<strong>Spring AOP 离开了 IoC 容器，就没有所谓的 AOP</strong>，具体的是在 Bean 实例化前，实现了 SmartInstantiationAwareBeanPostProcessor 的 AbstractAdvisorAutoProxyCreator 3个实现类来搞的。AnnotationAwareAspectJAutoProxyCreator、DefaultAdvisorAutoProxyCreator、InfrastructureAdvisorAutoProxyCreator。</p><p>Java 的 Proxy 或者 CGLIB（ASM）动态代理，实现 AOP，做方法前后等增强。各种 Advisor 增强。</p><p>前者是必须有接口，用实现同一个接口的生成类替换原来的类。后者是生成其子类，来增强原有类，所以 final 方法会被代理失效。</p><p><a href="https://juejin.im/post/5bf4fc84f265da611b57f906" target="_blank" rel="noopener">https://juejin.im/post/5bf4fc84f265da611b57f906</a></p><h2 id="JDK动态代理和cglib的实现的区别"><a href="#JDK动态代理和cglib的实现的区别" class="headerlink" title="JDK动态代理和cglib的实现的区别"></a>JDK动态代理和cglib的实现的区别</h2><p>一个是接口，一个做它的子类，对原有类型进行提升</p><h3 id="JDK动态代理实现"><a href="#JDK动态代理实现" class="headerlink" title="JDK动态代理实现"></a>JDK动态代理实现</h3><p>Proxy.newInstance</p><h3 id="CGLIB-实现动态代理"><a href="#CGLIB-实现动态代理" class="headerlink" title="CGLIB 实现动态代理"></a>CGLIB 实现动态代理</h3><p>本质上是实现一个子类，去提升该类的方法。所以不要将类或方法设置成 final 类型的，类设置了会报错，作为不了他的子类，方法设置成 final，只能 invoke 不能增强该方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLIBDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(CGLIBDemo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">            System.err.println(<span class="string">"Before invoke "</span> + method);</span><br><span class="line">            Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">            System.err.println(<span class="string">"After invoke"</span> + method);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CGLIBDemo cglibDemo = (CGLIBDemo) enhancer.create();</span><br><span class="line">        cglibDemo.test();</span><br><span class="line">        System.out.println(cglibDemo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm test method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Javassist-动态生成字节码"><a href="#Javassist-动态生成字节码" class="headerlink" title="Javassist 动态生成字节码"></a>Javassist 动态生成字节码</h2><p>其实还是基于 ASM 来做的。</p><p>Ljava.lang.String</p><p>这种，直接生成 class 文件，织入 [Ljava.lang.String 这种代码，来在虚拟机内部动态生成 class 文件。</p><h2 id="Spring-是如何解决循环依赖的"><a href="#Spring-是如何解决循环依赖的" class="headerlink" title="Spring 是如何解决循环依赖的"></a>Spring 是如何解决循环依赖的</h2><p>首先 prototype 不让循环依赖</p><p>其次是构造器注入依赖，必须提供无参构造器，让 bean 能够实例化，如果没有，那也会报错。</p><p>最终，Spring 会先实例化对象，将对象放入 earlySingletonObjects 中，如果循环依赖开始，优先查找 earlySingletonObjects。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">  <span class="comment">// 上面三个 map 解决循环依赖。如果是非单例模式，构造器注入，循环依赖无解，直接抛出异常。在 AbstractBeanFactory 中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; inCreationCheckExclusions = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>));</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Exception&gt; suppressedExceptions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> singletonsCurrentlyInDestruction = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; disposableBeans = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">64</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSingletonBeanRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有面试题</p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104391081" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/104391081</a></p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC-具体请求执行过程"><a href="#Spring-MVC-具体请求执行过程" class="headerlink" title="Spring MVC 具体请求执行过程"></a>Spring MVC 具体请求执行过程</h2><p>handlerMapping -&gt; handler -&gt; </p><p>其实看 DispatherServlet#doService 方法就行了。所谓的图，不懂的人，还是看不懂的，看源代码就知道了。</p><p>前置知识是 MethodHandler</p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><ul><li>Spring Cloud Netflix </li><li>Spring Cloud Alibaba</li><li>Spring Cloud Azure</li><li>Spring Cloud Amazon</li><li>Spring Cloud HUAWEI</li></ul><p>其实 Spring Cloud Alibaba 开源，是为了更好的卖自家的云产品，例如 RocketMQ，大厂没有什么真正开源，就是为了钱罢了，用爱发电这种事，大家都比较难做。</p><h2 id="Eureka-Nacos"><a href="#Eureka-Nacos" class="headerlink" title="Eureka/Nacos"></a>Eureka/Nacos</h2><p>Spring Cloud 服务注册、服务发现几个抽象。</p><p>DiscoveryClient、ServiceInstance</p><p>租约机制。</p><p>Eureka 实现了 AP。任何 Server 都是主 Server，Server 与 Server 之间同步需要时间，可能会出现不一致的情况。Consistency</p><p>Nacos 实现了两种 AP，CP 模式，需要哪种可以指定。</p><h2 id="Feign-Dubbo"><a href="#Feign-Dubbo" class="headerlink" title="Feign/Dubbo"></a>Feign/Dubbo</h2><p>前者使用 HTTP 协议，更为通用，适合不是那么注重性能的场景或者需要跨语言的场景。</p><p>虽然 Dubbo 协议也支持，但不是支持所有语言。</p><h2 id="Hystrix-Sentinel（哨兵）"><a href="#Hystrix-Sentinel（哨兵）" class="headerlink" title="Hystrix/Sentinel（哨兵）"></a>Hystrix/Sentinel（哨兵）</h2><p>Sentinel 除了熔断限流，还有分布式应用监控的功能</p><h2 id="Gateway-Zuul"><a href="#Gateway-Zuul" class="headerlink" title="Gateway/Zuul"></a>Gateway/Zuul</h2><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>我选择 Confluent Kafka</p><h2 id="分布式服务配置中心"><a href="#分布式服务配置中心" class="headerlink" title="分布式服务配置中心"></a>分布式服务配置中心</h2><h3 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h3><p>挺好用，隔离机制，以及发布信息等做的挺好，就是要配置 MySQL，启动三个不同的 jar，内部实现是 Eureka + http long polling 长连接。</p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis缓存机制"><a href="#MyBatis缓存机制" class="headerlink" title="MyBatis缓存机制"></a>MyBatis缓存机制</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>基于 PerpetualCache 的 HashMap 本地缓存， 其存储作用域为 Session， 当 Session flush 或 close 之后， 该 Session 中的所有 Cache 就 将清空， 默认打开一级缓存。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>与一级缓存其机制相同， 默认也是采用 PerpetualCache， HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)， 并且可自定义存储源， 如 Ehcache。 默认不打开二级缓存， 要开启二级缓存， 使用二级缓存属性类需要实 现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ， 对于缓存数据更新机制， 当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后， 默认该作用域下所有 select 中的缓存将被 clear 。</p><p>就是跨 SqlSession 的缓存，生产上不建议开启。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单工厂模式又叫静态方法模式。</p><p>补充：根据输入参数，或调用不同静态方法创建不同类型实例。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>注意事项</p><ol><li>对于初始化耗时的类来说，饿汉式单例更适合。</li><li>Spring 采用 Hash 散列表来实现单例，自己 new [SpringBean] 还是会创建不同对象。</li></ol><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只有低版本的 Java 才会有指令重排问题，所以这里没加 volatile</span></span><br><span class="line">    <span class="comment">// 我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题，解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//  防止反射创建两次实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">    &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建器模式"><a href="#构建器模式" class="headerlink" title="构建器模式"></a>构建器模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><a href="https://time.geekbang.org/column/article/199674" target="_blank" rel="noopener">https://time.geekbang.org/column/article/199674</a></p><ul><li><p>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</p></li><li><p>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</p></li><li><p>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了</p></li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>另外，MyBatis 也有 SqlSessionFactoryBuilder 来构建 SqlSessionFactory（虽然也可以用 Java Bean 的方式）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AbstractBeanDefinition beanDefinition;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> constructorArgIndex;</span><br><span class="line">    <span class="comment">// 提供静态工厂方法，返回一般 BeanDefinitionBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinitionBuilder <span class="title">genericBeanDefinition</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = <span class="keyword">new</span> BeanDefinitionBuilder(<span class="keyword">new</span> GenericBeanDefinition());</span><br><span class="line">        builder.beanDefinition.setBeanClassName(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他相同类型方法.....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init-method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(@Nullable String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detroy-method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setDestroyMethodName</span><span class="params">(@Nullable String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setDestroyMethodName(methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scope  defualt singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setScope</span><span class="params">(@Nullable String scope)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setScope(scope);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他类型方法....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.validate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionAPI</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericBeanDefinition <span class="title">getGeneriBeanDefinition</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (GenericBeanDefinition)BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(<span class="string">"org.springframework.web.client.RestTemplate"</span>)</span><br><span class="line">            .setScope(<span class="string">"singleton"</span>)</span><br><span class="line">            .getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h2 id="JDK-源码用到了哪些设计模式"><a href="#JDK-源码用到了哪些设计模式" class="headerlink" title="JDK 源码用到了哪些设计模式"></a>JDK 源码用到了哪些设计模式</h2><p><a href="https://blog.csdn.net/baiye_xing/article/details/76427717" target="_blank" rel="noopener">https://blog.csdn.net/baiye_xing/article/details/76427717</a></p><h1 id="MySQL-Oracle"><a href="#MySQL-Oracle" class="headerlink" title="MySQL/Oracle"></a>MySQL/Oracle</h1><h2 id="一条-SQL-的执行过程"><a href="#一条-SQL-的执行过程" class="headerlink" title="一条 SQL 的执行过程"></a>一条 SQL 的执行过程</h2><p>来源于这个大佬的 <a href="https://www.processon.com/view/link/5f27c4e17d9c0835d3a35995" target="_blank" rel="noopener">https://www.processon.com/view/link/5f27c4e17d9c0835d3a35995</a></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/30/V4nRrjPeb86ui1Z.png" alt="image.png"></p><p>词法解析 -&gt; 如果开启了缓存（5.7后默认关闭），如果没有修改内容，则返回结果 -&gt; 词法解析生成树 -&gt; 调用 innodb -&gt; </p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>读未提交 Read Uncommitted</p><p>读已提交 Read Committed</p><p>可重复读 Repeatable Read</p><p>串行化 Serializable</p><p>分别解决了事务执行的不同情况。</p><p>这些是事务型数据库设计的基本概念</p><h2 id="通过-Explain-分析并优化-SQL"><a href="#通过-Explain-分析并优化-SQL" class="headerlink" title="通过 Explain 分析并优化 SQL"></a>通过 Explain 分析并优化 SQL</h2><p>两年前使用 PL/SQL 对慢 SQL 的解释查询计划小优化。其实还有其他的 SQL 优化，没展示出来，项目后期帮其他组员重构优化代码和 SQL。</p><p><a href="https://yq.aliyun.com/articles/687976?spm=a2c4e.11155435.0.0.5f4633120ERia8" target="_blank" rel="noopener">https://yq.aliyun.com/articles/687976?spm=a2c4e.11155435.0.0.5f4633120ERia8</a></p><p>还有 like ‘%xx%’， like ‘xx%’， like ‘%xx’</p><p>我把其他组员的第一个改成了第二个，因为第二个能用到索引。这也是优化 SQL 的一个小技巧。</p><p>具体原因，是因为根据 ASCII 比对的，比对成了就返回。有前缀索引内味了。</p><h2 id="BaiKalDB"><a href="#BaiKalDB" class="headerlink" title="BaiKalDB"></a>BaiKalDB</h2><p>百度开源的，基于 MySQL 以及 RocksDB 实现的分布式数据库。通过 Partition Region 的概念实现，理论上没有存储瓶颈。</p><p>有点像 TiDB，也被人说是 C++ 版本的 TiDB。</p><p>这个 RocksDB 也被用于 Pika 中，是一种高效的且大容量的 NoSQL 数据库。</p><h2 id="OceanBase"><a href="#OceanBase" class="headerlink" title="OceanBase"></a>OceanBase</h2><p>阿里开源的数据库。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Reids-6-个底层数据结构"><a href="#Reids-6-个底层数据结构" class="headerlink" title="Reids 6 个底层数据结构"></a>Reids 6 个底层数据结构</h2><ul><li>简单动态字符串 SDS</li><li>List 双向链表</li><li>ZipList 压缩列表</li><li>SkipList 跳表</li><li>HashMap 哈希表</li><li>整数数组</li></ul><p>Redis 是一个主要由 Salvatore Sanfilippo（Antirez）开发的开源内粗数据结构存储器。因为其丰富的数据类型结构的值，可以被用作缓存、数据库、分布式锁和消息队列等<sup><a href="https://weread.qq.com/web/reader/75732070719551157574079" target="_blank" rel="noopener">1</a></sup></p><p>Redis 包含了 5 种的基本数据类型</p><ol><li><p>String</p></li><li><p>Hash</p></li><li><p>List</p></li><li><p>Set</p></li><li><p>SortedSet</p></li></ol><p>和四个特殊的数据类型</p><ol><li>HyperLogLog</li><li>BitMap</li><li>GEO（地理坐标）</li><li>Steam（流）</li></ol><p>注意，这个 5 种的基本数据类型不代表它的具体实现。它的具体实现是根据值的大小，而不同的。下面有个图<sup><a href="https://static001.geekbang.org/resource/image/82/01/8219f7yy651e566d47cc9f661b399f01.jpg" target="_blank" rel="noopener">2</a></sup>，</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/n8bsoCXH3jMcRBv.png" alt="Redis 数据类型和底层数据结构对应图.png"></p><p>可以看出来，除了它的表面上的对应的实现，还有压缩列表这个数据结构(ZipList)，<strong>在它的值到达一定阈值时</strong>，会自动转换为其表面的实现。</p><p>其实可以这么记，String 就是 Simple Dynamic String，<em>Set 是哈希表和整数数组，List 、SortedList 和 Hash 在一定阈值后变成其对应实现。List -&gt; 双向链表，Hash -&gt; 哈希表，SortedSet -&gt; 跳表.</em></p><p>下面是 Redis 6.0.5 的 redis.conf 的配置及其注释<strong>（可以跳过不看）。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"><span class="comment"># Hash 对应的 ZipList设置 -------------------------------</span></span><br><span class="line"><span class="comment"># Hashes are encoded using a memory efficient data structure when they have a</span></span><br><span class="line"><span class="comment"># small number of entries, and the biggest entry does not exceed a given</span></span><br><span class="line"><span class="comment"># threshold. These thresholds can be configured using the following directives.</span></span><br><span class="line"><span class="meta">hash-max-ziplist-entries</span> <span class="string">512</span></span><br><span class="line"><span class="meta">hash-max-ziplist-value</span> <span class="string">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list 对应的 ZipList 设置 -------------------------------</span></span><br><span class="line"><span class="comment"># Lists are also encoded in a special way to save a lot of space.</span></span><br><span class="line"><span class="comment"># The number of entries allowed per internal list node can be specified</span></span><br><span class="line"><span class="comment"># as a fixed maximum size or a maximum number of elements.</span></span><br><span class="line"><span class="comment"># For a fixed maximum size, use -5 through -1, meaning:</span></span><br><span class="line"><span class="comment"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span></span><br><span class="line"><span class="comment"># -4: max size: 32 Kb  &lt;-- not recommended</span></span><br><span class="line"><span class="comment"># -3: max size: 16 Kb  &lt;-- probably not recommended</span></span><br><span class="line"><span class="comment"># -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># Positive numbers mean store up to _exactly_ that number of elements</span></span><br><span class="line"><span class="comment"># per list node.</span></span><br><span class="line"><span class="comment"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span></span><br><span class="line"><span class="comment"># but if your use case is unique, adjust the settings as necessary.</span></span><br><span class="line"><span class="meta">list-max-ziplist-size</span> <span class="string">-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set 最大值 -------------------------------</span></span><br><span class="line"><span class="comment"># Sets have a special encoding in just one case: when a set is composed</span></span><br><span class="line"><span class="comment"># of just strings that happen to be integers in radix 10 in the range</span></span><br><span class="line"><span class="comment"># of 64 bit signed integers.</span></span><br><span class="line"><span class="comment"># The following configuration setting sets the limit in the size of the</span></span><br><span class="line"><span class="comment"># set in order to use this special memory saving encoding.</span></span><br><span class="line"><span class="meta">set-max-intset-entries</span> <span class="string">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zset 命令也就是 SortedList 最大的 ZipList 值 -------------------------------</span></span><br><span class="line"><span class="comment"># Similarly to hashes and lists, sorted sets are also specially encoded in</span></span><br><span class="line"><span class="comment"># order to save a lot of space. This encoding is only used when the length and</span></span><br><span class="line"><span class="comment"># elements of a sorted set are below the following limits:</span></span><br><span class="line"><span class="meta">zset-max-ziplist-entries</span> <span class="string">128</span></span><br><span class="line"><span class="meta">zset-max-ziplist-value</span> <span class="string">64</span></span><br></pre></td></tr></table></figure><p><strong>下面我讲下对应的数据类型及其数据结构实现</strong></p><h3 id="Redis-全局-Hash-表总览"><a href="#Redis-全局-Hash-表总览" class="headerlink" title="Redis 全局 Hash 表总览"></a>Redis 全局 Hash 表总览</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。</p><p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p>哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。指针你懂我意思吧，就是个内存地址，并不是实际内容。这个其实就是 HashMap，讲这个，就顺便复习下 HashMap 的东西。<em>tips：这里的 *key 其实是 c++ 里面的声明变量的方式。和 Java 里面的 String s 这种类似</em></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/IqZMVBe6nlJrPuC.png" alt="全局哈希表.png"></p><h3 id="HashTable-问题"><a href="#HashTable-问题" class="headerlink" title="HashTable 问题"></a>HashTable 问题</h3><p>这里其实 Java 里面的本来应该常用哈希表（HashTable）的，这里的哈希表和 Java  HashMap 实现是差不多的。后者是双向链表（过一定阈值）转红黑树。</p><h4 id="1-哈希冲突"><a href="#1-哈希冲突" class="headerlink" title="1. 哈希冲突"></a>1. 哈希冲突</h4><p>哈希冲突就是 12%6 = 0，24%6 = 0，或者两个不同的键算出了同样的哈希值。单单靠计算哈希值然后取模的方式，不同的键值肯定会存在一样的取模后的值。所以哈希表里面就会用往下加 。但是这个往下加也有个限度，它会一个个加，加到 10w 个，那就要往下找 10w 次，对本来是 O(1) 查找速度的数据结构肯定接受不了。在 Java 的 HashMap 中，如果单个链表长度过长，则会进行扩容，在其中进行 rehash 。</p><h4 id="2-rehash"><a href="#2-rehash" class="headerlink" title="2. rehash"></a>2. rehash</h4><p>为了解决那么多的节点可能出现在哈希表的一个下标下，那么就需要 rehash 来重新调整哈希表的大小，即数组大小。</p><p><strong>为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步<sup>[3]</sup>：</strong></p><ol><li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li><li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>释放哈希表 1 的空间。</li></ol><p>到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。</p><p>这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了<strong>渐进式 rehash</strong>。</p><p><strong>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。</strong>如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://static001.geekbang.org/resource/image/73/0c/73fb212d0b0928d96a0d7d6ayy76da0c.jpg" alt="渐进式 rehash"></p><h3 id="压缩列表-ZipList-介绍"><a href="#压缩列表-ZipList-介绍" class="headerlink" title="压缩列表 ZipList 介绍"></a>压缩列表 ZipList 介绍</h3><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p><p><strong>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/4vCA6IgxzS29kRP.png" alt="压缩列表 ZipList.png"></p><p><strong>下面不是重点可以跳过</strong></p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">长度</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">zlbytes</td><td align="center">unit32_t</td><td align="center">4字节</td><td align="center">记录整个压缩列表占用的内存字节数；在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。</td></tr><tr><td align="center">zltail</td><td align="center">unit32_t</td><td align="center">4字节</td><td align="center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历压缩列表就可以确定表尾节点的地址。</td></tr><tr><td align="center">zllen</td><td align="center">unit16_t</td><td align="center">2字节</td><td align="center">记录了压缩列表包含的节点数量：当这个属性的值小于 UINT16_MAX（65535）时，这个属性的值就是压缩力表包含节点的数量；等于时，节点的真实数量需要遍历整个压缩列表才能计算得出。（<strong>所以压缩列表节点数不宜过大</strong>）</td></tr><tr><td align="center">entryX</td><td align="center">列表节点</td><td align="center">不确定</td><td align="center">压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td></tr><tr><td align="center">zlend</td><td align="center">unit8_t</td><td align="center">1字节</td><td align="center">特殊值 0xFF （十进制 255），用于标记和压缩列表的末端</td></tr></tbody></table><p>下面是一个压缩列表的样例<sup>[4]</sup></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/n1foXe3tvPsONSW.png" alt="包含 5 个节点的压缩列表 _1_.png"></p><ul><li>列表zlbytes属性的值为0xd2（十进制210），表示压缩列表的总长为210字节。</li><li>列表zltail属性的值为0xb3（十进制179），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量179，就可以计算出表尾节点entry5的地址。</li><li>列表zllen属性的值为0x5（十进制5），表示压缩列表包含五个节点。</li></ul><p><strong>压缩列表节点数不宜过大！！！</strong></p><h3 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表 SkipList"></a>跳表 SkipList</h3><p>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。</p><p>跳跃表（SkipList）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均 O（logN）、最坏 O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以<strong>有不少程序都使用跳跃表来代替平衡树。</strong></p><p>和链表、字典等数据结构被广泛地应用在Redis内部不同，<strong>Redis只在两个地方用到了跳跃表</strong>，一个是实现<strong>有序集合键</strong>，另一个是在<strong>集群节点中用作内部数据结构</strong>，除此之外，跳跃表在Redis里面没有其他用途。</p><p>下面是演示跳表找一个节点。以此类推，三级索引，N 级索引。<strong>当数据量很大时，跳表的查找复杂度就是 O(logN)。</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/AKBT6WLskvbYr2o.png" alt="跳表.png"></p><p><a href="https://time.geekbang.org/column/article/42896" target="_blank" rel="noopener">更为详细的跳表介绍</a>（可以不看）</p><p><em>还有，为什么选择跳表而不是平衡树，看这个<a href="https://www.jianshu.com/p/8ac45fd01548" target="_blank" rel="noopener">解释</a>（<strong>可以跳过不看</strong>）</em></p><h3 id="数据结构的时间复杂度"><a href="#数据结构的时间复杂度" class="headerlink" title="数据结构的时间复杂度"></a>数据结构的时间复杂度</h3><table><thead><tr><th align="center">名称</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">哈希表</td><td align="center">O(1)</td></tr><tr><td align="center">跳表</td><td align="center">O(logN)</td></tr><tr><td align="center">双向链表</td><td align="center">O(N)</td></tr><tr><td align="center">压缩列表</td><td align="center">O(N)</td></tr><tr><td align="center">整数列表</td><td align="center">O(N)</td></tr></tbody></table><h3 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h3><p>不同操作的复杂度集合类型的操作类型很多，有读写单个集合元素的，例如 HGET、HSET，也有操作多个元素的，例如 SADD，还有对整个集合进行遍历操作的，例如 SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。</p><ol><li><strong>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。</strong>例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。<em>集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</em></li><li><strong>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据</strong>，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。</strong>Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。</li><li><strong>统计操作，</strong>是指<strong>集合类型对集合中所有元素个数的记录</strong>，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</li><li><strong>例外情况，</strong>是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头和表尾的偏移量</strong>。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>《Redis 使用手册》</p></blockquote><blockquote><p><a href=""> 极客时间《Redis 核心技术实战》</a></p></blockquote><h2 id="Redis单线程"><a href="#Redis单线程" class="headerlink" title="Redis单线程"></a>Redis单线程</h2><p>所谓的单线程，其实是指 Redis 对读和写键值的时候是单线程操作（这里就会导致某个命令如果执行耗时过长，会导致 Redis 实例卡住），和传统的 Socket 单线程 accept 接收不同。Redis 采用了 select/epoll IO多路复用的方式，将所有到达的 TCP 请求，进行了汇总到事件队列中，然后由 Redis 主线程一条条执行命令。</p><p>所谓单线程，是指网络 IO 和键值对读写是由一个线程来完成的。用于集群数据同步、持久化（save/bgsave）、异步删除都是由其他线程来完成的。</p><h2 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h2><p>默认为关闭，需手动设置开启</p><p>即使开启了多线程，Redis 对读和写键值的时候，还是单线程了，只不过是多线程接受消息。</p><h2 id="Redis-哨兵集群"><a href="#Redis-哨兵集群" class="headerlink" title="Redis 哨兵集群"></a>Redis 哨兵集群</h2><p>一主多从，客观下线</p><p>// TODO 判断过程</p><h2 id="Redis-分片"><a href="#Redis-分片" class="headerlink" title="Redis 分片"></a>Redis 分片</h2><p>16384个哈希槽，CRC16</p><p>Codis</p><p>// TODO 分配哈希槽命令</p><h2 id="Redis-集群同步"><a href="#Redis-集群同步" class="headerlink" title="Redis 集群同步"></a>Redis 集群同步</h2><p>一主多从，RDB 同步</p><p>replica buf，以及对应的 log</p><p>// TODO 同步步骤</p><h3 id="Redis-源码优化"><a href="#Redis-源码优化" class="headerlink" title="Redis 源码优化"></a>Redis 源码优化</h3><p>利用 taskset 将主线程进行绑核操作。</p><p>lscpu 查看 cpu 是不是 numa 架构，来进行 CPU 绑核操作。华为的 OpenGuass 数据库也是利用了这个绑核操作，在数据库启动的时候就会自动绑核做极致优化。</p><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>数据的容器，具体方法，里面有读指针和写指针等。</p><h2 id="InboundChannel"><a href="#InboundChannel" class="headerlink" title="InboundChannel"></a>InboundChannel</h2><p>入站管道。</p><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><h2 id="Netty-Zero-Copy"><a href="#Netty-Zero-Copy" class="headerlink" title="Netty Zero Copy"></a>Netty Zero Copy</h2><p>少了两步骤，调用的操作系统的复制方法。</p><p>少了用户态的参与。</p><p><a href="https://zhuanlan.zhihu.com/p/78869158" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/78869158</a></p><h2 id="Netty-解决粘包"><a href="#Netty-解决粘包" class="headerlink" title="Netty 解决粘包"></a>Netty 解决粘包</h2><p>使用复杂的协议，进行拆包。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>前序：根左右</p><p>中序：左根右</p><p>后序：左右根</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Node left, right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">       LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           TreeNode node = stack.pollLast();</span><br><span class="line">           res.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树最大深度"><a href="#求二叉树最大深度" class="headerlink" title="求二叉树最大深度"></a>求二叉树最大深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">  <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="comment">//pos变量用来标记循环里最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> k = size - <span class="number">1</span>, pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一共要排序size-1次</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//选出该趟排序的最大值往后移动</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//只要有发生了交换，flag就置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//循环里最后一次交换的位置 j赋给pos</span></span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k = pos;</span><br><span class="line">            <span class="comment">//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">演示动态图</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><h2 id="插入排序-insert"><a href="#插入排序-insert" class="headerlink" title="插入排序 insert"></a>插入排序 insert</h2><h2 id="归并排序-merge"><a href="#归并排序-merge" class="headerlink" title="归并排序 merge"></a>归并排序 merge</h2><h2 id="选择排序-select"><a href="#选择排序-select" class="headerlink" title="选择排序 select"></a>选择排序 select</h2><h1 id="LeetCode-刷题"><a href="#LeetCode-刷题" class="headerlink" title="LeetCode 刷题"></a>LeetCode 刷题</h1><h2 id="滑动窗口寻找字符串"><a href="#滑动窗口寻找字符串" class="headerlink" title="滑动窗口寻找字符串"></a>滑动窗口寻找字符串</h2><h1 id="大型分布式网站架构"><a href="#大型分布式网站架构" class="headerlink" title="大型分布式网站架构"></a>大型分布式网站架构</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>单体 -&gt; SOA -&gt; 微服务 -&gt; Serveless</p><p>下一代架构，Serveless</p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><ol><li>轮询（Round Robin）</li><li>随机</li><li>hash 取模</li><li>加权轮询（和轮询一样，只不过根据权重，重复的IP地址根据权重变成多份）</li><li>加权随机</li><li>最小连接数</li><li>动态选择连接数最小服务器</li></ol><h2 id="常见权限设计"><a href="#常见权限设计" class="headerlink" title="常见权限设计"></a>常见权限设计</h2><ul><li>ACL：Access-Control List，访问控制列表。</li><li>RBAC：Role-Based Access Control，基于角色的权限控制。</li><li>ABAC：Attribute-Based Access Control，基于属性的权限控制。</li><li>PBAC：Policy-Based Access Control，基于策略的权限控制。</li></ul><p>ACL示例：MySQL，MongoDB，HBase 都是以 ACL 作为权限控制思想，MySQL 在赋予用户权限时，有个 acl_users 数组进行存储 all_user 信息（不仅在 mysql.user 这个表里加数据）。</p><p>RBAC示例：常见的权限系统，在 人员 1&lt;–&gt;n 角色 1&lt;–&gt;n 权限。</p><h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p>阮一峰大佬的云冲印的例子。</p><p>其实现 Spring Security Oauth2</p><h2 id="如何设计海量数据的存储系统"><a href="#如何设计海量数据的存储系统" class="headerlink" title="如何设计海量数据的存储系统"></a>如何设计海量数据的存储系统</h2><p>参考 TiDB，或者 GFS 升级版 Colossus（套娃）。</p><h2 id="Consistent-Hash-一致性哈希"><a href="#Consistent-Hash-一致性哈希" class="headerlink" title="Consistent Hash 一致性哈希"></a>Consistent Hash 一致性哈希</h2><p>基础：将 Hash 函数的值域空间组织成一个圆环，计算出对应的 key 的 hash 值在环上对应的区间。</p><p>进阶：对每个节点进行计算多个 Hash 值，引入虚拟节点，虚拟节点映射到真实节点。 </p><p><a href="https://www.infoq.cn/article/7cBOXVbB6B5V0BJh6Rfx" target="_blank" rel="noopener">https://www.infoq.cn/article/7cBOXVbB6B5V0BJh6Rfx</a></p><h2 id="缓存的实现原理，设计缓存要注意什么"><a href="#缓存的实现原理，设计缓存要注意什么" class="headerlink" title="缓存的实现原理，设计缓存要注意什么"></a>缓存的实现原理，设计缓存要注意什么</h2><p><a href="https://juejin.im/post/5b849878e51d4538c77a974a" target="_blank" rel="noopener">https://juejin.im/post/5b849878e51d4538c77a974a</a></p><p>进程内缓存Guava cache 、Ecache，也可以使用其提供的同步机制同步多个进程间缓存。</p><p>// TODO《深入分布式缓存》</p><h2 id="操作系统的页式存储"><a href="#操作系统的页式存储" class="headerlink" title="操作系统的页式存储"></a>操作系统的页式存储</h2><p><a href="https://www.tomorrow.wiki/archives/334" target="_blank" rel="noopener">https://www.tomorrow.wiki/archives/334</a></p><p>page cache。最好不要改，redis 利用 page cache 做了优化，改大了影响性能。</p><p>// TODO 详细解释 page cache</p><h2 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h2><ul><li><p>可以将用户的 token 作为键值，使用 登陆 -&gt; UUID -&gt; token -&gt; token为键，用户信息为值 ，将用户信息放入 Memcached/Redis集群之中。</p></li><li><p>对用户 token/id 采用 Hash 取模的方式，将用户 session 强行绑定在固定机器上，就不用跨实例共享 session 了（也叫粘性 Session，缺点很明显，动态扩容，会导致大量 Session 失效）。</p></li></ul><h2 id="HTTP-请求的过程与原理"><a href="#HTTP-请求的过程与原理" class="headerlink" title="HTTP 请求的过程与原理"></a>HTTP 请求的过程与原理</h2><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h2 id="TCP-连接的特点"><a href="#TCP-连接的特点" class="headerlink" title="TCP 连接的特点"></a>TCP 连接的特点</h2><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/18/RqHshOkozmNS1PB.png" alt="TCP.png"></p><h2 id="TCP如何保证安全可靠的"><a href="#TCP如何保证安全可靠的" class="headerlink" title="TCP如何保证安全可靠的"></a>TCP如何保证安全可靠的</h2><p>ACK机制，三次握手，四次挥手 </p><h2 id="UDP-基础知识"><a href="#UDP-基础知识" class="headerlink" title="UDP 基础知识"></a>UDP 基础知识</h2><p>无连接协议即用户数据报协议（UDP），通常在性能至关重要并且能够容忍一定的数据包丢失的情况下。<strong>用户数据报协议</strong>（英语：<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol，缩写：<strong>UDP</strong>；又称<strong>用户数据包协议</strong>）是一个简单的面向<a href="https://zh.wikipedia.org/wiki/数据报" target="_blank" rel="noopener">数据报</a>的<a href="https://zh.wikipedia.org/wiki/通信协议" target="_blank" rel="noopener">通信协议</a>，位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>。该协议由<a href="https://zh.wikipedia.org/w/index.php?title=David_P._Reed&action=edit&redlink=1" target="_blank" rel="noopener">David P. Reed</a>在1980年设计且在<a href="https://tools.ietf.org/html/rfc768" target="_blank" rel="noopener">RFC 768</a>中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。</p><p>在<a href="https://zh.wikipedia.org/wiki/TCP/IP" target="_blank" rel="noopener">TCP/IP</a>模型中，UDP为<a href="https://zh.wikipedia.org/wiki/网络层" target="_blank" rel="noopener">网络层</a>以上和<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>以下提供了一个简单的接口。UDP只提供<a href="https://zh.wikipedia.org/wiki/数据" target="_blank" rel="noopener">数据</a>的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。</p><p>UDP适用于不需要或在<a href="https://zh.wikipedia.org/wiki/计算机程序" target="_blank" rel="noopener">程序</a>中执行<a href="https://zh.wikipedia.org/wiki/错误检测与纠正" target="_blank" rel="noopener">错误检查和纠正</a>的<a href="https://zh.wikipedia.org/wiki/应用程序" target="_blank" rel="noopener">应用</a>，它避免了<a href="https://zh.wikipedia.org/wiki/协议栈" target="_blank" rel="noopener">协议栈</a>中此类处理的<a href="https://zh.wikipedia.org/w/index.php?title=开销&action=edit&redlink=1" target="_blank" rel="noopener">开销</a>。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。</p><h3 id="UDP-的可靠性"><a href="#UDP-的可靠性" class="headerlink" title="UDP 的可靠性"></a>UDP 的可靠性</h3><p>由于UDP缺乏<a href="https://zh.wikipedia.org/wiki/可靠性_(计算机网络)" target="_blank" rel="noopener">可靠性</a>且属于<a href="https://zh.wikipedia.org/wiki/無連接式通訊" target="_blank" rel="noopener">无连接</a>协议，所以应用程序通常必须容许一些<a href="https://zh.wikipedia.org/wiki/丢包" target="_blank" rel="noopener">丢失</a>、错误或重复的<a href="https://zh.wikipedia.org/wiki/数据包" target="_blank" rel="noopener">数据包</a>。某些应用程序（如<a href="https://zh.wikipedia.org/wiki/TFTP" target="_blank" rel="noopener">TFTP</a>）可能会根据需要在应用程序层中添加基本的可靠性机制。<a href="https://zh.wikipedia.org/wiki/用户数据报协议#cite_note-forouzan-1" target="_blank" rel="noopener">[1]</a></p><p>一些应用程序不太需要可靠性机制，甚至可能因为引入可靠性机制而降低性能，所以它们使用UDP这种缺乏可靠性的协议。流媒体，实时多人游戏和IP语音（<a href="https://zh.wikipedia.org/wiki/VoIP" target="_blank" rel="noopener">VoIP</a>）是经常使用UDP的应用程序。 在这些特定应用中，丢包通常不是重大问题。如果应用程序需要高度可靠性，则可以使用诸如<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP</a>之类的协议。</p><p>例如，在VoIP中<a href="https://zh.wikipedia.org/wiki/來回通訊延遲" target="_blank" rel="noopener">延迟</a>和<a href="https://zh.wikipedia.org/wiki/抖动" target="_blank" rel="noopener">抖动</a>是主要问题。如果使用TCP，那么任何数据包丢失或错误都将导致抖动，因为TCP在请求及重传丢失数据时不向应用程序提供后续数据。如果使用UDP，那么应用程序则需要提供必要的握手，例如实时确认已收到的消息。</p><p>由于UDP缺乏<a href="https://zh.wikipedia.org/wiki/拥塞控制" target="_blank" rel="noopener">拥塞控制</a>，所以需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送端无法检测拥塞，所以像使用包队列和丢弃技术的路由器之类的网络基础设备会被用于降低UDP过大流量。<a href="https://zh.wikipedia.org/wiki/数据拥塞控制协议" target="_blank" rel="noopener">数据拥塞控制协议</a>（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中增加主机拥塞控制，来减小这个潜在的问题。</p><h3 id="UDP-应用"><a href="#UDP-应用" class="headerlink" title="UDP 应用"></a>UDP 应用</h3><p>许多关键的互联网应用程序使用UDP<a href="https://zh.wikipedia.org/wiki/用户数据报协议#cite_note-kuroseross-2" target="_blank" rel="noopener">[2]</a>，包括：</p><ul><li><a href="https://zh.wikipedia.org/wiki/域名系统" target="_blank" rel="noopener">域名系统</a>（DNS），其中查询阶段必须快速，并且只包含单个请求，后跟单个回复数据包；</li><li><a href="https://zh.wikipedia.org/wiki/动态主机配置协议" target="_blank" rel="noopener">动态主机配置协议</a>（DHCP），用于动态分配<a href="https://zh.wikipedia.org/wiki/IP地址" target="_blank" rel="noopener">IP地址</a>；</li><li><a href="https://zh.wikipedia.org/wiki/简单网络管理协议" target="_blank" rel="noopener">简单网络管理协议</a>（SNMP）；</li><li><a href="https://zh.wikipedia.org/wiki/路由信息协议" target="_blank" rel="noopener">路由信息协议</a>（RIP）；</li><li><a href="https://zh.wikipedia.org/wiki/網路時間協定" target="_blank" rel="noopener">网络时间协议</a>（NTP）。</li></ul><p><a href="https://zh.wikipedia.org/wiki/串流媒體" target="_blank" rel="noopener">流媒体</a>、<a href="https://zh.wikipedia.org/wiki/線上遊戲" target="_blank" rel="noopener">在线游戏</a>流量通常使用UDP传输。 实时视频流和音频流应用程序旨在处理偶尔丢失、错误的数据包，因此只会发生质量轻微下降，而避免了重传<a href="https://zh.wikipedia.org/wiki/数据包" target="_blank" rel="noopener">数据包</a>带来的高<a href="https://zh.wikipedia.org/wiki/延遲" target="_blank" rel="noopener">延迟</a>。 由于TCP和UDP都在同一网络上运行，因此一些企业发现来自这些实时应用程序的UDP流量影响了使用TCP的应用程序的性能，例如<a href="https://zh.wikipedia.org/wiki/销售" target="_blank" rel="noopener">销售</a>、<a href="https://zh.wikipedia.org/wiki/会计" target="_blank" rel="noopener">会计</a>和<a href="https://zh.wikipedia.org/wiki/数据库系统" target="_blank" rel="noopener">数据库系统</a>。 当TCP检测到数据包丢失时，它将限制其数据速率使用率。由于实时和业务应用程序对企业都很重要，因此一些人认为开发<a href="https://zh.wikipedia.org/wiki/服务质量" target="_blank" rel="noopener">服务质量</a>解决方案至关重要。<a href="https://zh.wikipedia.org/wiki/用户数据报协议#cite_note-3" target="_blank" rel="noopener">[3]</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">详情</a></p><p>TCP 是面向连接的传输，管理了两个端点之间的连接的建立，在连接的生命周期内的有序和可靠的消息传输，以及最后，连接的有序终止。相比之下，在类似于 UDP 这样的无连接协议中，并没有持久化连接的概念，并且每个消息（一个 UDP 数据报）都是一个单独的传输单元。</p><p>UDP 没有 TCP 的纠错机制，其中每个节点都将确认它们所接收到的包，而没有被确认的包会被发送方重新传输。</p><h2 id="UDP-广播"><a href="#UDP-广播" class="headerlink" title="UDP 广播"></a>UDP 广播</h2><p>UDP 提供了向多个接收者发送消息的额外传输模式</p><ul><li><p>单播——发送消息给一个由唯一地址所标识的单一网络目的地。</p></li><li><p>多播——传输到一个预定义的主机组。</p></li><li><p>广播——传输到网络（或者子网）上的所有主机。</p></li></ul><h2 id="服务稳定性"><a href="#服务稳定性" class="headerlink" title="服务稳定性"></a>服务稳定性</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>理清调用链路、流量控制、慢调用降级。</p><h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><p>为避免单个服务实例宕机导致服务雪崩，通常有集群管理或服务熔断机制，可以两个一起用。Dubbo 服务设置里面手动设置阈值。</p><h3 id="服务分级"><a href="#服务分级" class="headerlink" title="服务分级"></a>服务分级</h3><p>对服务实例设置白名单机制，对不同服务进行分级处理，优先处理等级高的服务请求。我觉得可以把调用失败的请求，转到 mq 上，由一群专门用于处理调用失败请求的服务，进行定时执行从 mq 尝试拉取失败请求，进行重试。</p><h3 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h3><p>如果服务消费者 A、B、C 都依赖服务提供者 D，如果前面做了服务分级，则可以在实例负载超过警戒水位线，进行关闭对低优先级的请求。</p><h3 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h3><p>提前做好扩容方案。</p><p>Sentinel 都符合了这些要求（应急预案不含）。本质上都是舍车保帅，保证能用的服务不挂，保证优先级高的服务能用，提前准备应对方案。</p><h2 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h2><h3 id="操作原子性"><a href="#操作原子性" class="headerlink" title="操作原子性"></a>操作原子性</h3><p>volatile，synchronized</p><h3 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h3><p>JUC</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p><strong>强一致性</strong></p><p>要求无论数据的更新操作是在哪个副本上执行，之后所有的读操作都要能够获取到更新的最新数据。</p><p><strong>弱一致性</strong></p><p>系统的某个数据被更新后，后续对该数据的读取操作到的可能是更新前的值，也可能是更新后的值。全部用户完全读取到更新后的数据需要经过一段时间，这段时间称为“不一致性窗口”</p><p><strong>最终一致性</strong></p><p>最终一致性是弱一致性的特殊形式，这种情况下系统保证用户最终能够读取到某个操作对系统的更新，“不一致窗口”的时间依赖于网络的延迟、系统的负载和副本的个数。</p><h3 id="系统的可扩展性"><a href="#系统的可扩展性" class="headerlink" title="系统的可扩展性"></a>系统的可扩展性</h3><p>通过简单加机器，简单的配置就能实现更高吞吐量，那这就是易扩展。</p><h3 id="并发减库存"><a href="#并发减库存" class="headerlink" title="并发减库存"></a>并发减库存</h3><p><a href="https://time.geekbang.org/column/article/40743" target="_blank" rel="noopener">https://time.geekbang.org/column/article/40743</a></p><p>减库存一般有三种</p><ul><li>下单减库存</li><li>付款减库存</li><li>预扣减库存</li></ul><p><strong>下单减库存</strong>可以通过数据库事务控制，但是下了单不一定付款。</p><p><strong>付款减库存</strong>，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了。</p><p><strong>预扣库存</strong>，买家下单后，库存为其保留一定时间（如10分钟），超过这个时间，库存将会自动释放，释放后其他买家可以继续购买（有点锁的味道）。在买家付款前，系统会校验订单的库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（预扣失败），则不允许继续付款，如果预扣成功，则完成付款并实际地去减库存。</p><p>对商品剩余数量的查询，可以使用缓存 Ecache/Guava Cache 进行本地缓存返回。</p><p><strong>应用层做排队。</strong>按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。</p><p><strong>数据库层做排队</strong>。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</p><h2 id="性能优化措施"><a href="#性能优化措施" class="headerlink" title="性能优化措施"></a>性能优化措施</h2><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><ol><li>页面的 HTTP 请求数量（尽量减少请求数量，像QQ音乐网页版就是反例，大量无用的 debug 请求）</li><li>是否使用 CDN 网络（静态资源上 CDN）</li><li>是否使用压缩</li></ol><h3 id="Java-程序优化"><a href="#Java-程序优化" class="headerlink" title="Java 程序优化"></a>Java 程序优化</h3><ol><li>合理使用单例模式。提升对象复用性，减少内存开销</li><li>Future 模式（FutureTask，异步执行任务）</li><li>线程池（避免对象频繁创建、销毁，使用池化思想，在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用）</li><li>选择就绪（使用 NIO）</li><li>减少上下文切换 （2 * cpu核心数 * cpu核数 + 1，IO 密集型这么做，计算密集型 cpu 核心数+1）</li><li>降低锁竞争（1. 合理减少 synchronized 域的范围，2. 减小锁的粒度 3.使用读写锁比使用独占锁提供更高的并发量 ）</li></ol><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>HTTP Header gzip </p><h3 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h3><p>从数据库开始使用缓存（不建议） -&gt; 不建议使用 MyBatis 的二级缓存，进程内缓存 Guava cache，Ecache -&gt; 跨进程缓存 （Redis ，对值结构；要求复杂点的系统不推荐Memcached）-&gt; 静态资源缓存（CDN）</p><h3 id="数据库查询性能优化"><a href="#数据库查询性能优化" class="headerlink" title="数据库查询性能优化"></a>数据库查询性能优化</h3><ol><li>合理使用索引（explain，解释计划查询，对特定业务进行建立索引进行查询优化）<a href="https://yq.aliyun.com/articles/687976?spm=a2c4e.11155435.0.0.5f4633120ERia8" target="_blank" rel="noopener">例子</a> oracle 是 explain plan for</li><li>反范式设计（适当冗余字段，尽量避免多表操作）</li><li>使用查询缓存（不推荐，5.7 之后默认关闭，8.0 不准开，使用起来很多坑）</li><li>使用搜索引擎（Elasticsearch 加速 Like 查询以及很多复杂的查询）</li><li>使用 Key-Value 数据库（HBase， TDH 的 HyperBase，通过设计合理的 RowKey 加速查询）</li></ol><h3 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h3><p>分析 dump 日志，合理设置启动参数，Xms 设置为机器内存的 65% - 70%。</p><h3 id="硬件性能提升"><a href="#硬件性能提升" class="headerlink" title="硬件性能提升"></a>硬件性能提升</h3><p>其实硬件性能提升是所有优化里面，能最简单，最大的优化。生产上都是 Nginx + F5 来提升单体应用。</p><h3 id="Java-应用-CPU-使用率飙升故障排查"><a href="#Java-应用-CPU-使用率飙升故障排查" class="headerlink" title="Java 应用 CPU 使用率飙升故障排查"></a>Java 应用 CPU 使用率飙升故障排查</h3><p>// TODO 把 19 年如何解决 CPU 使用率飙升的命令写出来</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Arthas</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>使用Hadoop 进行数据分析。</p><p>Storm 是 2011 年 Twitter 开源的一个实时的分布式流式处理系统，有点类似于 Hadoop 提供的大数据解决方案，但是它要处理的对象是没有终点的数据流（也叫无界数据流），而非 Hadoop 的 MapReduce 那样的批处理系统。</p><h2 id="日志收集系统-Chukwa"><a href="#日志收集系统-Chukwa" class="headerlink" title="日志收集系统 Chukwa"></a>日志收集系统 Chukwa</h2><h2 id="离线数据分析"><a href="#离线数据分析" class="headerlink" title="离线数据分析"></a>离线数据分析</h2><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>过程往往是从 OLTP 库中，以及日志系统中，提取和清洗（数据清洗可以用 Kafka Stream）所需要的数据到 OLAP 系统（所在的银行当前系统就是这样的）。构建在 hive 平台，然后在 OLAP 系统上进行多维度复杂的数据分析和汇总操作，利用这些数据构建数据报表，进行前端展示。我们做的是每天全量同步。使用的 Sqoop，没用 DataX 。</p><h3 id="离线同步（全量同步）"><a href="#离线同步（全量同步）" class="headerlink" title="离线同步（全量同步）"></a>离线同步（全量同步）</h3><p>使用 sqoop</p><h3 id="实时同步（增量同步）"><a href="#实时同步（增量同步）" class="headerlink" title="实时同步（增量同步）"></a>实时同步（增量同步）</h3><p>使用 MySQL 主从机制，通过伪装成从库进行 binlog  —&gt; Kafka （任意 MQ） —&gt; 其他库</p><p>算是备忘录模式的体现，全量和增量。</p><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="Zookeeper-介绍"><a href="#Zookeeper-介绍" class="headerlink" title="Zookeeper 介绍"></a>Zookeeper 介绍</h2><p><code>Zookeeper</code> 是一个开源的分布式协调服务软件，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步操作。最终，将简单易用的接口和性能高效，功能稳定的系统提供给用户。</p><p>分布式应用程序可以基于 <code>Zookeeper</code> 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><p>Zookeeper 保证了分布式一致性特性：</p><ol><li>顺序一致性</li><li>原子性</li><li>单一视图</li><li>可靠性</li><li>实时性（最终一致性）</li></ol><h2 id="Zookeeper-提供了什么？"><a href="#Zookeeper-提供了什么？" class="headerlink" title="Zookeeper 提供了什么？"></a>Zookeeper 提供了什么？</h2><ol><li>文件系统</li><li>通知机制</li></ol><h2 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a>Zookeeper 文件系统</h2><p><code>Zookeeper</code> 提供了一个多层级的节点命名空间（节点称为 <code>znode</code>）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。<code>Zookeeper</code> 为了保证高吞吐和低延迟，在内存中维护了这个树状目录结构，这种特性使得 <code>Zookeeper</code>不能用于存放大的数据，每个节点的存放数据上限为 1M。</p><h2 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h2><p><code>ZAB</code> 协议是为分布式协调服务 <code>Zookeeper</code>专门设计的一种支持崩溃恢复的原子广播协议。</p><p><code>ZAB</code>协议包括两种基本的模式：崩溃恢复和消息广播。</p><p>当整个<code>Zookeeper</code>集群刚刚启动或者 <code>Leader</code>服务器宕机、重启或者网络故障导致不存在过半的服务器与<code>Leader</code>服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的<code>Leader</code>服务器，然后集群中<code>Follower</code>服务器开始与新的<code>Leader</code>服务器进行数据同步，当集群中超过半数及其与该 <code>Leader</code>服务器完成数据同步之后，退出恢复模式进入消息广播模式，<code>Leader</code>服务器开始接收客户端的事务请求生成事务提案进行事务请求处理。</p><h2 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h2><p><code>PERSISTENT</code>：持久节点，除非手动删除，否则节点一直存在于<code>Zookeeper</code>上</p><p><code>EPHEMERAL</code>：临时节点 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与<code>Zookeeper</code>连接断开不宜一定会话失效），那么这个客户端创建的所有临时节点都会被移除。<a href="#broker-zk"><code>Kafka</code>集群就是基于临时节点</a>。</p><p><code>PERSISTENT_SEQUENTIAL</code>：持久顺序节点 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字</p><p><code>EPHEMERAL_SEQUENTIAL</code>：临时顺序节点 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由副节点维护的自增整型数字。</p><h2 id="ZooKeeper-Wather-机制-–-数据变更通知"><a href="#ZooKeeper-Wather-机制-–-数据变更通知" class="headerlink" title="ZooKeeper Wather 机制 – 数据变更通知"></a>ZooKeeper Wather 机制 – 数据变更通知</h2><p>Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。</p><p><strong>工作机制</strong>：</p><ol><li><p>客户端注册watcher </p></li><li><p>服务端处理watcher </p></li><li><p>客户端回调watcher</p></li></ol><p><strong>Watcher特性总结</strong>：</p><p><strong>一次性</strong></p><p>无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p><p><strong>客户端串行执行</strong></p><p>客户端Watcher回调的过程是一个串行同步的过程。</p><p><strong>轻量</strong></p><ol><li><p>Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</p></li><li><p>客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。</p></li></ol><p>watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。</p><p>注册watcher getData、exists、getChildren</p><p>触发watcher create、delete、setData</p><p>当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="Kafka-各个名词概述"><a href="#Kafka-各个名词概述" class="headerlink" title="Kafka 各个名词概述"></a>Kafka 各个名词概述</h2><p>Topic</p><p>Broker</p><p>Partition</p><p>Producer</p><p>Consumer</p><p>Leader Replica</p><p>Follower Replica</p><p>Rebalance</p><p>Consumer Offset</p><p>Consumer Group</p><p>Cordinator</p><p>Cotroller</p><p>Interceptor</p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>Kafka 处理的主要对象。</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>向主题发布消息的客户端应用程序。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>订阅这些主题消息的客户端应用程序就被称为消费者。</p><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>指的是多个消费者实例共同组成一个组来消费一个主题。该组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。消费者组提升了消费者端的吞吐量。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>一个 Kafka 集群由一个至多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。</p><h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>备份机制</p><h4 id="Leader-Replica"><a href="#Leader-Replica" class="headerlink" title="Leader Replica"></a>Leader Replica</h4><p>领导者副本，对外提供服务。</p><h4 id="Follower-Replica"><a href="#Follower-Replica" class="headerlink" title="Follower Replica"></a>Follower Replica</h4><p>追随者副本，不对外提供服务，不能与外界进行交互。对 Leader 副本同步有延迟。</p><h3 id="Cordinator"><a href="#Cordinator" class="headerlink" title="Cordinator"></a>Cordinator</h3><p>协调者</p><h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller 控制器"></a>Controller 控制器</h3><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>比如 MongoDB 和 Elasticsearch 中的 Sharding、HBase 中的 Region，其实它们都是相同的原理，只是 Partitioning 是最标准的名称。</p><p>生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。</p><p>一个有序不变的消息队列，每个主题下可以有多个分区。</p><h3 id="副本和分区的关系"><a href="#副本和分区的关系" class="headerlink" title="副本和分区的关系"></a>副本和分区的关系</h3><p>副本是在分区这个层级定义的，每个分区下可以配置若干个副本，其中只能有一个领导者副本和 N-1 个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息有Offset 的数据来表征。分区的位移总是从 0 开始。</p><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，它们还能彼此协助，假如组内的某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Faild 实例之前负责的分区转移给其他或者消费者。这就是 Rebalance，这个有很多 Bug。</p><h3 id="Consumer-Offset"><a href="#Consumer-Offset" class="headerlink" title="Consumer Offset"></a>Consumer Offset</h3><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上。</p><h2 id="Broker注册"><a href="#Broker注册" class="headerlink" title="Broker注册"></a><span id="broker-zk">Broker注册</span></h2><p><strong>Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的 Broker 管理起来</strong>，此时就使用到了Zookeeper。在 Zookeeper 上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点：</p><p>/brokers/ids</p><p>每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0…N]。</p><p>Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，<strong>每个Broker就会将自己的IP地址和端口信息记录</strong>到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。</p><h2 id="Kafka-ACK-机制"><a href="#Kafka-ACK-机制" class="headerlink" title="Kafka ACK 机制"></a>Kafka ACK 机制</h2><p>1 leader</p><p>0 不管</p><p>-1 所有</p><h2 id="Kafka-Zero-Copy"><a href="#Kafka-Zero-Copy" class="headerlink" title="Kafka Zero Copy"></a>Kafka Zero Copy</h2><p>和大家的零拷贝技术一样，少了用户态的参与。</p><h2 id="Kafka-副本机制"><a href="#Kafka-副本机制" class="headerlink" title="Kafka 副本机制"></a>Kafka 副本机制</h2><p>只有 Leader 副本才供外界读写，Follower 副本只是作为冗余，怕 Leader 副本 down 掉数据全部丢失。<br>Follower 副本定期向 Leader 拉取数据。</p><h2 id="Kafka-跨机房同步数据"><a href="#Kafka-跨机房同步数据" class="headerlink" title="Kafka 跨机房同步数据"></a>Kafka 跨机房同步数据</h2><h2 id="Kafka-消息压缩"><a href="#Kafka-消息压缩" class="headerlink" title="Kafka 消息压缩"></a>Kafka 消息压缩</h2><p>Kafka 默认不使用压缩，合理使用压缩，可以减少带宽使用。</p><p>GZIP、Snappy 、LZ4、Zstandard 算法（简写为 zstd）</p><p>在 Producer 端和 Broker 端设置相同（或者 Broker 端不改 compression.type 参数，默认为 producer 端的压缩方法）。 </p><p>在吞吐量方面：LZ4 &gt; Snappy &gt; zstd 和 GZIP；</p><p>而在压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy。</p><h2 id="Kafka-高水位"><a href="#Kafka-高水位" class="headerlink" title="Kafka 高水位"></a>Kafka 高水位</h2><p>高水位的作用在 Kafka 中，高水位的作用主要有 2 个。</p><ol><li>定义消息可见性，即用来标识分区下的哪些消息是可以被消费者消费的。</li><li>帮助 Kafka 完成副本同步。</li></ol><p><img src= "/img/loading.gif" data-src="https://static001.geekbang.org/resource/image/45/db/453ff803a31aa030feedba27aed17ddb.jpg" alt="高水位和 LEO"></p><p>它依靠一个名为 LSO（Log Stable Offset）的位移值来判断事务型消费者的可见性。</p><p>与 Leader 副本保持同步。判断的条件有两个。</p><ol><li>该远程 Follower 副本在 ISR 中。</li><li>该远程 Follower 副本 LEO 值落后于 Leader 副本 LEO 值的时间，不超过 Broker 端参数 replica.lag.time.max.ms 的值。如果使用默认值的话，就是不超过 10 秒。</li></ol><p>Leader Epoch</p><ol><li>Epoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。</li><li>起始位移（Start Offset）。Leader 副本在该 Epoch 值上写入的首条消息的位移。</li></ol><h2 id="为什么-Kafka-的-Consumer-采用-pull-方式，Provider-采用-push-方式"><a href="#为什么-Kafka-的-Consumer-采用-pull-方式，Provider-采用-push-方式" class="headerlink" title="为什么 Kafka 的 Consumer 采用 pull 方式，Provider 采用 push 方式"></a>为什么 Kafka 的 Consumer 采用 pull 方式，Provider 采用 push 方式</h2><p>消费者消费消息是需要一定时间的，为了防止推送过多消息给 Consumer 端，导致 Consumer 挂掉，让 Consumer 按需来自己 pull 消息。</p><h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><h2 id="Lucene全文搜索的原理"><a href="#Lucene全文搜索的原理" class="headerlink" title="Lucene全文搜索的原理"></a>Lucene全文搜索的原理</h2><p><a href="https://blog.csdn.net/yangqian201175/article/details/51462413" target="_blank" rel="noopener">https://blog.csdn.net/yangqian201175/article/details/51462413</a></p><p>《Lucene in action》</p><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><h2 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h2><p>primary shard， replica shard，cordinating</p><h2 id="Elasticsearch-聚合操作"><a href="#Elasticsearch-聚合操作" class="headerlink" title="Elasticsearch 聚合操作"></a>Elasticsearch 聚合操作</h2><p>Aggregation</p><h2 id="Elasticsearch-DLS-Query"><a href="#Elasticsearch-DLS-Query" class="headerlink" title="Elasticsearch DLS Query"></a>Elasticsearch DLS Query</h2><p>TermLevel</p><h2 id="Elasticsearch-查询"><a href="#Elasticsearch-查询" class="headerlink" title="Elasticsearch 查询"></a>Elasticsearch 查询</h2><p>支持多种类型查询，返回对应 score</p><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><p>docker pull docker.elastic.co/logstash/logstash:7.1.0</p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>中文环境设置 I18N_LOCALE=zh-CN</p><h1 id="BigData"><a href="#BigData" class="headerlink" title="BigData"></a>BigData</h1><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>Hadoop 分布式文件系统。NameNode + DataNode，NameNode 只存 metadata，实际文件存在各个 DataNode。</p><p>是的，它只是个文件系统，虽然一切皆文件。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce 是一种处理海量数据的并行编程模型和计算框架，用于对大规模数据集进行并行计算。</p><p>MapReduce 一个任务的运行需要由 JobTracker 和 TaskTracker 两类空志节点的配合来完成，JobTracker 将 Mappers 和 Reducers 分配给空闲的 TaskTracker 后，有TaskTracker 来执行这些任务。MapReduce 框架尽量在那些存储数据的节点（如 DataNode）上来执行计算任务，采用移动计算而非移动数据的思想，减少数据在网络中传输，以此来提高计算效率。同时 JobTracker 也负责任务的容错管理，如果某个 TaskTracker 发生故障，JobTracker 会重新进行任务调度。</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>将 SQL 解释成 MapReduce 任务。</p><p>Hive是早期将高级查询语言SQL引入<strong>Hadoop</strong>平台的引擎之一，早期的Hive服务器进程被称作Hiveserver1；Hiveserver1既不支持处理并行的多个连接，又不支持访问授权控制；后来这两个问题在Hiveserver2上被解决，Hiveserver2能够使用grant/revoke语句来限制用户对数据库、表、视图的访问权限，行列权限的控制是通过生成视图来实现的；但Hiveserver2的授权管理体系被认为存在问题，那就是任何通过认证登陆的用户都能够为自己增加对任何资源的访问权限。也就是说Hiveserver2提供的不是一种安全的授权体系，Hiveserver2的授权体系是为防止正常用户误操作而提供保障机制；不是为保护敏感数据的安全性而设计的。然而这些更多的是某些公司的说辞，事实上Hiveserver2自身的安全体系也在逐步完善，上述问题也在快速修复中。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>从 Hive 连接中可以看出用的是 Hiveserver2</p><p> beeline -u jdbc:hive2://olap1:10000/ –maxWidth=1000</p><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>从 WEB 开发到离线数仓，一个用多中间件 CRUD 开发，到另一个用 SQL 开发。换个地方 CRUD 而已</p><p>UDF，UDAF，UDTF。脱敏函数（UDF），聚合函数（UDAF 自定义count，sum），UDTF </p><p>UDF 一进一出，实现 UDF 接口，编写<strong>evaluate</strong>方法，例如可用作脱敏函数，对数据进行脱敏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleUDFExample</span> <span class="keyword">extends</span> <span class="title">UDF</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">evaluate</span><span class="params">(Text input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Text(<span class="string">"Hello "</span> + input.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDAF 多进一出，实现 AbstractGenericUDAFResolver，可用作实现自定义聚合函数。下面是求两个列的线性方程的相关系数。</p><p>看另一篇文章。</p><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><p>HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，是谷歌 BigTable 的开源实现，主要用来存储非结构化和半结构化的松散数据，运行在 HDFS 之上。设计 RowKey 尽量将数据均地分布在各个 Region 上，并且 RowKey 为<strong>等长</strong>，用于拼接 RowKey 的列必须是确定长度的值，高频词往前提，同样查询频率的，辨识度高，更短的列往前提。<strong>等长是因为桶排序。</strong></p><p>没有特殊要求，<strong>一个列族就可以满足大部分要求</strong>，多个列族会影响性能，实际生产中，都是一个列族，多个列族会有问题，具体的看《HBase 原理与实战》这本书。</p><p>拼接 Rowkey 是按照特定需求来做的，不能乱拼。</p><h2 id="HyperBase"><a href="#HyperBase" class="headerlink" title="HyperBase"></a>HyperBase</h2><p>星环增强了 HBase 变成了 HyperBase。查询更方便，千亿数据，查询秒返回。支持普通单表查询，多表查询慢，聚合操作更慢。聚合操作使用以下部件实现。支持更为丰富的值类型，例如  JSON 存储。</p><p>不过还是只是支持 PB 级别数据罢了，再大就不太行了。</p><h2 id="Kylin"><a href="#Kylin" class="headerlink" title="Kylin"></a>Kylin</h2><p>聚合操作。</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Spark SQL 也可以将 SQL 转换成 MR 任务，星环的 Inceptor 就整合了 Spark。Hive-on-spark，将 Hive 的 MR 任务转换成 Spark 的 job。</p><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>流式处理中间件。还是写 SQL。</p><p>符合事件驱动架构设计。</p><p>Kafka Streaming 也可以，但前者大公司都在用。做个 CRUD boy 他不香吗？</p><h2 id="CDH-TDH"><a href="#CDH-TDH" class="headerlink" title="CDH TDH"></a>CDH TDH</h2><p>Cloudera Data Hub，Transwarp Data Hub 一站式大数据平台</p><p>Transwarp Data Hub 对标的国外的 CDH，其实也用到了 CDH 开源的代码，我看到安装包里面有 CDH 的东西，并且他们封装的 Elasticsearch Transport 的 SDK，打包有问题。</p><h2 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h2><p>Online analytical processing <strong>联机分析处理</strong></p><p>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p><p>OLAP由三个基本的分析操作组成：上卷（roll-up）、钻取（drill-down）、切片（slicing）和切块（dicing）。上卷涉及可以在一个或多个维度中累积和计算的数据的聚合。例如，所有的销售办事处汇总到销售部门，以预测销售趋势。相比之下，钻取是一种允许用户浏览详细信息的技术。例如，用户可以查看组成一个地区销售额的单个产品的销售额。切片和切块是说，用户可以从OLAP多维数据集中取出（切片）一组特定的数据，并从不同的角度查看（切块）切片</p><p><a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86</a></p><h2 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h2><p><strong>联机事务处理</strong>（<strong>OLTP</strong>, Online transaction processing）是指透过<a href="https://zh.wikipedia.org/wiki/資訊系統" target="_blank" rel="noopener">信息系统</a>、电脑<a href="https://zh.wikipedia.org/wiki/網路" target="_blank" rel="noopener">网络</a>及<a href="https://zh.wikipedia.org/wiki/資料庫" target="_blank" rel="noopener">数据库</a>，以在线交易的方式处理一般即时性的作业资料，和更早期传统数据库系统大量批量的作业方式并不相同。OLTP通常被运用于自动化的资料处理工作，如订单输入、<a href="https://zh.wikipedia.org/wiki/金融" target="_blank" rel="noopener">金融</a>业务…等反复性的日常性交易活动。 和其相对的是属于决策分析层次的<a href="https://zh.wikipedia.org/wiki/線上分析處理" target="_blank" rel="noopener">联机分析处理</a>（OLAP）。</p><p><a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E4%BA%A4%E6%98%93%E8%99%95%E7%90%86" target="_blank" rel="noopener">来自</a></p><h1 id="J2EE-规范"><a href="#J2EE-规范" class="headerlink" title="J2EE 规范"></a>J2EE 规范</h1><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p><a href="https://docs.oracle.com/javaee/6/tutorial/doc/bncdr.html" target="_blank" rel="noopener">下面的来自oracle 官方文档</a></p><p>《大型分布式网站架构·设计与实践》中只是一笔带过一些概念，没有 JMS 实际代码，然后用 ActiveMQ &amp; JMS 的标题。</p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>Java Message Service 是一组 Java 应用程序接口，它提供消息的创建、发送、接收、读取等一系列的服务。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>原文</span></div>    <div class="hide-content"><p>The Java Message Service is a Java API that allows applications to create&sbquo; send&sbquo; receive&sbquo; and read messages</p></div></div><p>JMS 定义了一组公共应用程序接口和相应的语法，是一种通用的 API。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>原文</span></div>    <div class="hide-content"><p>the JMS API defines a common set of interfaces and associated semantics that allow programs written in the Java programming language to communicate with other messaging implementations</p></div></div><p>它定义了五种消息类型，如下。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>原文</span></div>    <div class="hide-content"><p>The JMS API defines five message body formats&sbquo; also called message types&sbquo; which allow you to send and receive data in many different forms and which provide compatibility with existing messaging formats.</p></div></div><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 80%;}</style><table><thead><tr><th>Message Type</th><th>Body Contains</th></tr></thead><tbody><tr><td><code>TextMessage</code></td><td>A <code>java.lang.String</code> object (for example, the contents of an XML file).</td></tr><tr><td><code>MapMessage</code></td><td>A set of name-value pairs, with names as <code>String</code> objects and values as primitive types in the Java programming language. The entries can be accessed sequentially by enumerator or randomly by name. The order of the entries is undefined.</td></tr><tr><td><code>BytesMessage</code></td><td>A stream of uninterpreted bytes. This message type is for literally encoding a body to match an existing message format.</td></tr><tr><td><code>StreamMessage</code></td><td>A stream of primitive values in the Java programming language, filled and read sequentially.</td></tr><tr><td><code>ObjectMessage</code></td><td>A <code>Serializable</code> object in the Java programming language.</td></tr><tr><td><code>Message</code></td><td>Nothing. Composed of header fields and properties only. This message type is useful when a message body is not required.</td></tr></tbody></table><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="1-0-规范"><a href="#1-0-规范" class="headerlink" title="1.0 规范"></a>1.0 规范</h3><ul><li><p>Connection</p></li><li><p>Statement</p></li><li><p>ResultSet</p></li><li><p>DriverManager.getDriver(url);</p></li></ul><h3 id="2-0-规范"><a href="#2-0-规范" class="headerlink" title="2.0 规范"></a>2.0 规范</h3><p>数据源</p><ul><li>DataSource        这个接口是在JDBC 2.0规范可选包中引入的API。它比DriverManager更受欢迎，因为它提供了更多底层数据源相关的细节，而且对应用来说，不需要关注JDBC驱动的实现。JDBC API中只提供了DataSource接口，没有提供DataSource的具体实现，DataSource具体的实现由JDBC驱动程序提供。主流的数据库连接池也提供了其实现，如 Druid，c3p0，Hikaricp</li><li>CommonDataSource </li></ul><p>连接池相关</p><ul><li>ConectionPoolDataSource 支持缓存和复用Connection对象，这样能够在很大程度上提升应用性能和伸缩性。</li><li>PooledConnection</li><li>ConnectionEvent</li><li>ConnectionEventListener</li></ul><p>ResultSet 扩展</p><ul><li>RowSet 继承自java.sql包下的ResultSet接口，相较于java.sql.ResultSet而言，RowSet的离线操作能够有效地利用计算机越来越充足的内存减轻数据库服务器的负担。由于数据操作都是在内存中进行的，然后批量提交到数据源，因此灵活性和性能都有了很大的提高。RowSet默认是一个可滚动、可更新、可序列化的结果集，而且它作为一个JavaBean组件，可以方便地在网络间传输，用于两端的数据同步。通俗来讲，RowSet就相当于数据库表数据在应用程序内存中的映射，我们所有的操作都可以直接与RowSet对象交互。RowSet与数据库之间的数据同步，作为开发人员不需要关注。</li><li>RowSetEvent</li><li>RowSetInternal</li><li>RowSetListener</li><li>RowSetMetaData</li><li>RowSetReader</li><li>RowSetWriter</li></ul><p>分布式扩展</p><ul><li>XAConnection</li><li>XADataSource 该实例返回的Connection对象能够支持分布式事务。</li></ul><p>上面三个都是接口。</p><h3 id="需要掌握的-API"><a href="#需要掌握的-API" class="headerlink" title="需要掌握的 API"></a>需要掌握的 API</h3><p>java.sql.Wrapper</p><p>java.sql.Connection</p><p>java.sql.Statement</p><p>java.sql.PrepareStatement</p><p>java.sql.CallableStatement</p><p>java.sql.DatabaseMetaData</p><p>java.sql.ParameterMetaData</p><p>java.sql.ResultSet</p><p>java.sql.ResultSetMetaData</p><p>这些接口都继承了java.sql.Wrapper接口，里面有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* unwrap()方法用于返回未经过包装的JDBC驱动原始类型实例，可以通过该实例调用JDBC驱动中提供的非标准的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(java.lang.Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> java.sql.SQLException</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于判断当前实例是否是JDBC驱动中某一类型的包装类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(java.lang.Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> java.sql.SQLException</span>;</span><br></pre></td></tr></table></figure><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>JNDI（Java Naming and Directory Interface，Java命名和目录接口）为应用程序提供了一种通过网络访问远程服务的方式。</p><h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>servlet-class<br>mapping<br>load-up</p><h2 id="JTA-Java-Transaction-Architecture"><a href="#JTA-Java-Transaction-Architecture" class="headerlink" title="JTA(Java Transaction Architecture)"></a>JTA(Java Transaction Architecture)</h2><p> JTA定义了一种标准的API，应用系统由此可以访问各种事务监控。</p><h2 id="JTS-Java-Transaction-Service"><a href="#JTS-Java-Transaction-Service" class="headerlink" title="JTS(Java Transaction Service)"></a>JTS(Java Transaction Service)</h2><p> 参考 <a href="https://www.ibm.com/developerworks/cn/java/j2ee/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j2ee/</a></p><h1 id="Cloud-Native-云原生"><a href="#Cloud-Native-云原生" class="headerlink" title="Cloud Native 云原生"></a>Cloud Native 云原生</h1><h2 id="云原生十二要素"><a href="#云原生十二要素" class="headerlink" title="云原生十二要素"></a>云原生十二要素</h2><p>十二要素程序的核心思想</p><ul><li>使用<strong>声明</strong>的方式来搭建自动化环境，最大限度地减少新加入项目的开发人员的时间和成本。</li><li>与底层操作系统之间建立清晰的约定，在执行环境之间提供<strong>最大的可移植性</strong>。</li><li>适合<strong>部署</strong>在现代的<strong>云平台上</strong>，无须提供服务器和系统管理工具。</li><li><strong>最大程度减少</strong>开发环境与生产环境之间的<strong>区别</strong>，通过<strong>持续部署</strong>获得最大的灵活性。</li><li>可以在不对工具、架构或开发实践带来重大变动的前提下，进行<strong>水平扩展</strong>。</li></ul><p>十二要素程序的实践</p><table><thead><tr><th>代码库</th><th align="left">一份版本控制下的基准代码库，多份部署</th></tr></thead><tbody><tr><td>依赖</td><td align="left">显示声明和隔离依赖关系</td></tr><tr><td>配置</td><td align="left">在环境中存储配置</td></tr><tr><td>后端服务</td><td align="left">把后端服务当作附加资源</td></tr><tr><td>构建、发布、运行</td><td align="left">严格分离构建和运行阶段</td></tr><tr><td>进程</td><td align="left">将应用程序作为一个或多个无状态进程执行</td></tr><tr><td>端口绑定</td><td align="left">通过端口绑定暴露服务</td></tr><tr><td>并发</td><td align="left">通过进程模型进行扩展</td></tr><tr><td>易处理</td><td align="left">通过快速启动和正常关机来最大限度地提高健壮性</td></tr><tr><td>开发/生产环境一致</td><td align="left">尽可能保持开发、预发布和生产环境的配置一致</td></tr><tr><td>日志</td><td align="left">将日志视为事件流</td></tr><tr><td>管理进程</td><td align="left">将管理任务作为一次性进程运行</td></tr></tbody></table><h2 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h2><p>Pivotal 团队 12 年发布的云原生平台，完美实现了云原生的十二要素。Cloud Foundry 创始人之一，Chris Richardson，也是 《微服务架构设计模式》的作者。你想要了解微服务，这本书大量图解，帮你了解。</p><h2 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h2><h1 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>构建 Dockerfile，参考我的 <a href="https://github.com/young1lin/evaluation/tree/docker" target="_blank" rel="noopener">evaluation</a> 库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build</span><br><span class="line">docker run</span><br><span class="line">docekr ps</span><br><span class="line">docker kill</span><br><span class="line">docker compose up</span><br><span class="line">docker images</span><br><span class="line">docker rm</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-（K8s，K3s）"><a href="#Kubernetes-（K8s，K3s）" class="headerlink" title="Kubernetes （K8s，K3s）"></a>Kubernetes （K8s，K3s）</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。</p><p>K3s 国产的轻量级的 K8s。<br><a href="https://shumeipai.nxez.com/2020/04/15/kubernetes-raspberry-pi-k3s.html" target="_blank" rel="noopener">用树莓派搭建 K3s</a></p><p>Kubernetes 是一个 Docker 编排框架。Docker 编排框架将运行 Docker 的一组计算机视为资源池。你只需要告诉 Docker 编排框架运行你的服务的 N 个实例，它就会自动把其余的事情搞定。</p><p>有三个主要功能：</p><ul><li>资源管理：将一组计算机视为由 CPU、内存和存储卷构成的资源池，将计算机集群视为一台计算机。</li><li>调度：选择要运行容器的机器。默认情况下，调度考虑容器的资源需要和每个节点的可用资源。它还可以实现在同一节点上部署具有亲和性（affinity）的容器，或确保特定的几个容器分散部署在不同的节点之上（反亲和性，anti-affinity）</li><li>服务管理：实现命名和版本化服务的概念，这个概念可以直接映射到微服务架构中的具体服务。编排框架确保始终运行所需数量的正常实例。它实现请求的负载均衡。编排框架也可以执行服务的滚动升级，并允许你会滚到旧版本。</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/05/23/7LYV9lMqswbdotf.png" alt="Docker 编排框架.png"></p><h2 id="Kubenetes-的架构"><a href="#Kubenetes-的架构" class="headerlink" title="Kubenetes 的架构"></a>Kubenetes 的架构</h2><p>Kubernetes 在一组机器上运行。下图显示了 Kubernetes 集群的架构。Kubernetes 集群中的计算机角色分为主节点和普通节点（也称为节点）集群通常只有很少的几个主节点（可能只有一个）和很多普通节点。主节点负责管理集群。Kubernetes 的普通节点称为 “工作节点”，它会运行一个或多个 Pod。Pod 是 Kubernetes 的部署单元，由一组容器组成。</p><ul><li>API 服务器：用于部署和管理服务的 REST API，例如，可被 kubectl 命令行使用。</li><li>Etcd：存储集群数据键值的 NoSQL 数据库。</li><li>调度器：选择要运行的 Pod 的节点。</li><li>控制器管理器：运行控制器，确保集群状态与预期状态匹配。例如，一种被称为复制（replication）控制器的控制通过启动和终止实例来确保运行所需数量的服务实例。</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/05/23/rjxoUPZYId6RSzF.png" alt="Kubernetes 的架构.png"></p><p>Kubenetes 集群由管理集群的主节点和运行服务的普通节点组成。开发人员和部署流水线通过 API 服务器与 Kubernetes 交互，API 服务器与主节点上运行的其他集群管理软件一起运行。应用程序容器在节点上运行，每个节点运行一个 Kubelet （它管理应用程序容器），以及一个 Kube-proxy （它将应用程序请求路由到 Pod），可以直接使用代理，也可以通过配置 Linux 内核中内置的 iptable 路由规则间接地完成路由工作。</p><p>普通节点运行多个组件，包括以下内容：</p><ul><li>Kubelet ： 创建和管理节点上运行的 Pod。</li><li>Kube-proxy：管理网络，包括跨 pod 的负载均衡。</li><li>Pods：应用程序服务。</li></ul><h3 id="Kubernetes-的关键概念"><a href="#Kubernetes-的关键概念" class="headerlink" title="Kubernetes 的关键概念"></a>Kubernetes 的关键概念</h3><ul><li>Pod：Pod 的 Kubernetes 的基本部署单元。它由一个或多个共享 IP 地址和存储卷的容器组成。服务实例的 pod 通常由单个容器组成，例如运行 JVM 的容器。但在某些情况下，Pod 包含一个或多个实现支持功能的边车（sidecar）容器。例如，Nginx 服务器可以有一个边车容器，定期执行 git pull 以下载最新版本的网站。Pod 的生命周期很短，因为 Pod 的容器或它运行的节点可能会崩溃。</li><li>Deployment：Pod 的声明规范。Deployment 是一个控制器，可确保始终运行所需数量的 Pod 实例（服务实例）。它通过滚动升级和会滚来支持版本控制。每个服务都是 Kubernetes 的一个 Deployment。</li><li>Servcie：向应用程序服务的客户端提供的一个静态/稳定的网络地址。它是基础设施提供的服务发现一种形式。每个 Service 具有一个 IP 地址和一个可解析位该 IP 地址的 DNS 名称，并跨一个或多个 Pod 对 TCP 和 UDP 流量进行负载均衡处理。IP 地址和 DNS 名称只能在 Kubernetes 内部访问。也可以配置可从集群外部访问的服务。</li><li>ConfigMap：名称与值对的命名集合，用于定义一个或多个应用程序服务的外部化配置。Pod 容器的定义可以饮用 ConfigMap 来定义容器的环境变量。它还可以使用 ConfigMap 在容器内创建配置文件。可以使用 Secret 来存储敏感信息（如密码），它也是 ConfigMap 的一种形式。</li></ul><h3 id="在-Kubernetes-上部署-Restaurant-Service"><a href="#在-Kubernetes-上部署-Restaurant-Service" class="headerlink" title="在 Kubernetes 上部署 Restaurant Service"></a>在 Kubernetes 上部署 Restaurant Service</h3><p>定义一个部署（Deployment）对象。最简单的方法是编写 YAML 文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ftgo-restaurant-service</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="comment"># Pod 副本的数量</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">ftgo-restaurant-service</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ftgo-restaurant-service</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">msapatterns/ftgo-restaurant-service:lastes</span></span><br><span class="line">              <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">              <span class="attr">ports:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">                  <span class="attr">nanme:</span> <span class="string">httpport</span></span><br><span class="line">                <span class="attr">env:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">JAVA_OPTS</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">"-Dsun.net.inetaddr.ttl=30"</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPRING_DATASOURCE_URL</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">jdbc:mysql://ftgo-mysql/eventuate</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPRING_DATASOURCE_USERNAME</span></span><br><span class="line">                    <span class="attr">valueFrom:</span></span><br><span class="line">                      <span class="attr">secretKeyRef:</span></span><br><span class="line">                        <span class="attr">name:</span> <span class="string">ftgo-db-secret</span></span><br><span class="line">                        <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPRING_DATASOURCE_PASSWORD</span></span><br><span class="line">                    <span class="attr">valueFrom:</span></span><br><span class="line">                      <span class="attr">secretKeyRef:</span></span><br><span class="line">                        <span class="attr">name:</span> <span class="string">ftgo-db-secret</span></span><br><span class="line">                        <span class="attr">key:</span> <span class="string">password</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPRING_DATASOURCE_DRIVER_CLASS_NAME</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EVENTUATELOCAL_KAFKA_BOOTSTRAP_SERVERS</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">ftgo-kafka:9092</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EVENTUATELOCAL_KAFKA_ZOOKEEPER_CONNECTION_STRING</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">ftgo-zookeeper:2181</span></span><br><span class="line">                <span class="attr">livenessProbe:</span></span><br><span class="line">                  <span class="attr">httpGet:</span></span><br><span class="line">                    <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">                    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">                  <span class="attr">initialDelySeconds:</span> <span class="number">60</span></span><br><span class="line">                  <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">                <span class="attr">readinessProbe:</span></span><br><span class="line">                  <span class="attr">httpGet:</span></span><br><span class="line">                    <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">                    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">                  <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">                  <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>接下来是部署 Service（这里的服务发现组件），K8s 自带的。</p><p>部署 API Gateway。大同小异，同上。</p><h3 id="Kubernetes-零停机部署"><a href="#Kubernetes-零停机部署" class="headerlink" title="Kubernetes 零停机部署"></a>Kubernetes 零停机部署</h3><ul><li>构建新的容器镜像，变更版本</li><li>编辑服务部署的 YAML 文件，以便它引用新镜像。</li><li>使用 kubectl apply -f 命令更新部署。</li></ul><p>K8s 将对 Pod 进行滚动升级。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment ftgo-restaurant-service</span><br></pre></td></tr></table></figure><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><h2 id="FaaS、SaaS、PasS、IaaS、Serverless"><a href="#FaaS、SaaS、PasS、IaaS、Serverless" class="headerlink" title="FaaS、SaaS、PasS、IaaS、Serverless"></a>FaaS、SaaS、PasS、IaaS、Serverless</h2><p>这些内容都是一些概念，并不是实际的实现，尤其是 Serverless 截止 2021 年初还没有标准的规范，我 Amazon 可以说我 Lambda 是标准的，我 Spring Boot + Azure 也可以说是 Serverless，我 Serverless X 也可以说是这个。某一次的技术沙龙直播，我问这个腾讯相关的人员，说各有优缺点。</p><p>下面的图层描绘了不同抽象层次上的云服务类型。<br><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/27/rkcE1SQj2KRfhwD.png" alt="云计算栈.png"></p><h3 id="Function-as-Service"><a href="#Function-as-Service" class="headerlink" title="Function as Service"></a>Function as Service</h3><p>功能即服务是一类云计算服务，它提供了一个平台，允许客户开发，运行和管理应用程序功能，而无需构建和维护通常与开发和启动应用程序相关的基础结构的复杂性。按照此模型构建应用程序是实现“无服务器”体系结构的一种方法，通常在构建微服务应用程序时使用。</p><p><strong>Function as a service</strong> (<strong>FaaS</strong>) is a category of <a href="https://en.wikipedia.org/wiki/Cloud_computing#Service_models" target="_blank" rel="noopener">cloud computing services</a> that provides a <a href="https://en.wikipedia.org/wiki/Computing_platform" target="_blank" rel="noopener">platform</a> allowing customers to develop, run, and manage application functionalities without the complexity of building and maintaining the infrastructure typically associated with developing and launching an app.<a href="https://en.wikipedia.org/wiki/Function_as_a_service#cite_note-1" target="_blank" rel="noopener">[1]</a> Building an application following this model is one way of achieving a “<a href="https://en.wikipedia.org/wiki/Serverless_computing" target="_blank" rel="noopener">serverless</a>“ architecture, and is typically used when building <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">microservices</a> applications.</p><h3 id="Software-as-a-Service"><a href="#Software-as-a-Service" class="headerlink" title="Software as a Service"></a>Software as a Service</h3><p><strong>软件即服务</strong>Software as a Service，亦可称为“按需即用软件”（即“一经要求，即可使用”）软件即服务，它是一种<a href="https://zh.wikipedia.org/wiki/软件" target="_blank" rel="noopener">软件</a>交付模式。在这种交付模式中，软件仅需通过网络，不须经过传统的安装步骤即可使用，软件及其相关的<a href="https://zh.wikipedia.org/wiki/数据" target="_blank" rel="noopener">数据</a>集中<a href="https://zh.wikipedia.org/wiki/互联网托管服务" target="_blank" rel="noopener">托管</a>于<a href="https://zh.wikipedia.org/wiki/云计算" target="_blank" rel="noopener">云端</a>服务。用户通常使用<a href="https://zh.wikipedia.org/wiki/精簡客戶端" target="_blank" rel="noopener">精简客户端</a>，一般即经由<a href="https://zh.wikipedia.org/wiki/网页浏览器" target="_blank" rel="noopener">网页浏览器</a>来访问、访问软件即服务。SaaS 最大的特色在于软件本身并没有被下载到用户的硬盘，而是存储在提供商的云端或者服务器。对比传统软件需要花钱购买，下载。软件即服务只需要用户租用软件，在线使用，不但大大减少了用户购买风险, 也无需下载软件本身，无设备要求的限制。</p><h3 id="Platform-as-a-Service"><a href="#Platform-as-a-Service" class="headerlink" title="Platform as a Service"></a>Platform as a Service</h3><p><strong>平台即服务</strong>，是一种<a href="https://zh.wikipedia.org/wiki/雲端運算" target="_blank" rel="noopener">云计算</a>服务，提供运算平台与解决方案服务。在云计算的典型层级中，PaaS层介于<a href="https://zh.wikipedia.org/wiki/軟體即服務" target="_blank" rel="noopener">软件即服务</a>与<a href="https://zh.wikipedia.org/wiki/基礎設施即服務" target="_blank" rel="noopener">基础设施即服务</a>之间。</p><p>PaaS提供用户将云端基础设施部署与创建至客户端，或者借此获得使用<a href="https://zh.wikipedia.org/wiki/程式語言" target="_blank" rel="noopener">编程语言</a>、<a href="https://zh.wikipedia.org/wiki/程式庫" target="_blank" rel="noopener">程序库</a>与服务。用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。<a href="https://zh.wikipedia.org/wiki/平台即服务#cite_note-nist-1" target="_blank" rel="noopener">[1]</a></p><p>PaaS 将软件研发的平台做为一种服务，以<a href="https://zh.wikipedia.org/wiki/軟體即服務" target="_blank" rel="noopener">软件即服务</a>（SaaS）模式交付给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。</p><p>PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。</p><p>K8s + Docker 也就相当于 PaaS 的实现。</p><h3 id="Infrastructure-as-a-Service"><a href="#Infrastructure-as-a-Service" class="headerlink" title="Infrastructure as a Service"></a>Infrastructure as a Service</h3><p>基础设施为服务。</p><p>云原生开发最终演化方向。</p><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><p>无服务化，冷启动应用，按需分配服务，适合边缘业务。</p><p>下下一代项目架构，目前只是 AWS 提供了 Lambda 来实现，在英文版的 InfoQ 上，有人把 Spring Boot + Azure = Serverless。</p><p>其实还没有非常明确的定义 Serverless 的规范，任何厂商都可以说他们的才是正统的 Serverless 服务器。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI（Service Provider Interface）是 JDK 内置的一种服务提供发现机制。SPI 是一种动态替换发现的机制。 SPI 典型的实现为 JDBC。</p><h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h1><h2 id="DDD-名词解释"><a href="#DDD-名词解释" class="headerlink" title="DDD 名词解释"></a>DDD 名词解释</h2><ul><li>子域</li><li>核心域</li><li>通用域</li><li>支撑域</li><li>限界上下文</li><li>聚合</li><li>聚合根</li><li>实体</li><li>值对象</li><li>领域事件 </li><li>依赖倒置</li><li>仓储（Repository）</li><li>ServiceManager</li></ul><h2 id="DDD-如何落地"><a href="#DDD-如何落地" class="headerlink" title="DDD 如何落地"></a>DDD 如何落地</h2><p>划分子域，子域内构建事件风暴。</p><h2 id="DDD-包名规范"><a href="#DDD-包名规范" class="headerlink" title="DDD 包名规范"></a>DDD 包名规范</h2><p>infrastructure</p><p>repository</p><p>service</p><p>entity</p><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h3><p>可用表格，可用链表存储。</p><h4 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h4><ul><li>首次适应</li><li>最佳适应</li><li>最差适应</li></ul><h4 id="分区释放算法"><a href="#分区释放算法" class="headerlink" title="分区释放算法"></a>分区释放算法</h4><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="Interview" scheme="https://young1lin.github.io/categories/Interview/"/>
    
    
    <category term="Interview" scheme="https://young1lin.github.io/tags/Interview/"/>
    
    <category term="Spring" scheme="https://young1lin.github.io/tags/Spring/"/>
    
    <category term="JUC" scheme="https://young1lin.github.io/tags/JUC/"/>
    
    <category term="JVM" scheme="https://young1lin.github.io/tags/JVM/"/>
    
    <category term="Structure" scheme="https://young1lin.github.io/tags/Structure/"/>
    
    <category term="Cache" scheme="https://young1lin.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下 Docker 更改国内镜像源</title>
    <link href="https://young1lin.github.io/2020/07/16/mac-docker%20-mirrors/"/>
    <id>https://young1lin.github.io/2020/07/16/mac-docker%20-mirrors/</id>
    <published>2020-07-15T16:00:00.000Z</published>
    <updated>2023-07-06T14:21:05.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="打开-DockerDesktop"><a href="#打开-DockerDesktop" class="headerlink" title="打开 DockerDesktop"></a>打开 <code>DockerDesktop</code></h1><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/16/BM374ek9xKfoOZT.png" alt="docker更改国内镜像源.png"></p><h1 id="如果你有其他配置改了的，直接复制这个，记住前面的逗号不要删"><a href="#如果你有其他配置改了的，直接复制这个，记住前面的逗号不要删" class="headerlink" title="如果你有其他配置改了的，直接复制这个，记住前面的逗号不要删"></a>如果你有其他配置改了的，直接复制这个，记住前面的逗号不要删</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,&quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br></pre></td></tr></table></figure><h1 id="如果你之前什么都没改，复制粘贴下面内容"><a href="#如果你之前什么都没改，复制粘贴下面内容" class="headerlink" title="如果你之前什么都没改，复制粘贴下面内容"></a>如果你之前什么都没改，复制粘贴下面内容</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"experimental"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>,<span class="string">"https://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如果在上图的界面报错，不能改"><a href="#如果在上图的界面报错，不能改" class="headerlink" title="如果在上图的界面报错，不能改"></a>如果在上图的界面报错，不能改</h1><p>打开 Terminal 进入 Users/YourName目录下，复制粘贴进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .docker</span><br><span class="line">vi deamon.json</span><br></pre></td></tr></table></figure><p>重启<code>docker</code>，镜像生效</p><div class="note danger">            <p>如果 <code>docker</code> 点 <code>prefrence</code>一直在更新状态，检查一下<code>daemon.json</code> 文件是否格式正确</p>          </div><h1 id="如果不想换镜像源，可以开代理"><a href="#如果不想换镜像源，可以开代理" class="headerlink" title="如果不想换镜像源，可以开代理"></a>如果不想换镜像源，可以开代理</h1><blockquote><p>别问我什么是代理，问就是不知道</p><p>我的本地代理端口是10080，你要是服务器的话，<code>http://[ ip address]:[port]</code></p><p>像这样</p><p>二选一，别两个都写，或者打开 <code>terminal</code>，</p><p><code>export ALL_PROXY=socks5://127.0.0.1:10080;</code><br><code>export http_proxy=socks5://127.0.0.1:10080;</code><br><code>export https_proxy=socks5://127.0.0.1:10080;</code>，</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/20/2vHdlr7B34L5fGX.png" alt="proxy.png"></p><h1 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h1><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>FROM 你的服务器后，加上，Docker Compose 建议下一种方法。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> http_proxy &lt;HTTP_PROXY&gt;</span><br><span class="line"><span class="keyword">ENV</span> https_proxy &lt;HTTPS_PROXY&gt;</span><br></pre></td></tr></table></figure><h2 id="打开终端后设置"><a href="#打开终端后设置" class="headerlink" title="打开终端后设置"></a>打开终端后设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"&lt;HTTPS_PROXY&gt;"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"&lt;HTTPS_PROXY&gt;"</span></span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p><a href="https://www.jianshu.com/p/419eaf4425a6" target="_blank" rel="noopener">https://www.jianshu.com/p/419eaf4425a6</a></p><p><a href="http://pangguoming.com/blog/architecture/docker-configuration-file-daemon.json" target="_blank" rel="noopener">http://pangguoming.com/blog/architecture/docker-configuration-file-daemon.json</a></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="tools" scheme="https://young1lin.github.io/categories/tools/"/>
    
    
    <category term="Docker" scheme="https://young1lin.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>搭建免费博客网站</title>
    <link href="https://young1lin.github.io/2020/07/10/blog-builder/"/>
    <id>https://young1lin.github.io/2020/07/10/blog-builder/</id>
    <published>2020-07-10T13:51:58.000Z</published>
    <updated>2021-01-03T13:57:35.870Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p align="right">折叠播放列表 ≡ ⬇️</p>    <div id="aplayer-lUjtqVwy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7652784085" data-server="tencent" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="200px" data-preload="none" data-theme="#ad7a86" data-loop="all" data-order="random"    ></div><blockquote><p>我用虚拟机里面的<code>Win10</code>演示</p></blockquote><h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol><li><code>GitHub</code>账号<a href="https://github.com/" target="_blank" rel="noopener">注册地址</a></li><li><code>Git</code><a href="https://github.com/git-for-windows/git/releases/download/v2.27.0.windows.1/Git-2.27.0-64-bit.exe" target="_blank" rel="noopener">下载地址</a></li><li>下载<code>NodeJs</code><a href="https://npm.taobao.org/mirrors/node/v14.5.0/node-v14.5.0-x64.msi" target="_blank" rel="noopener">下载地址</a></li><li>下个<code>Visual Studio Code</code>来编辑文件<a href="https://go.microsoft.com/fwlink/?Linkid=852157" target="_blank" rel="noopener">下载地址</a>（这个是为了让你更好得编辑<code>yml</code>文件，防止格式不正确，如果你有其他的，可以用其他的编辑器）</li></ol><blockquote><p>上面的 3 个应用可以直接下载，等会再安装</p></blockquote><h2 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h2><p>如果你有<code>github</code>账号，直接从第六步开始</p><div class="tabs" id="content-1"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-1-1">第一步</button></li><li class="tab"><button data-href="#content-1-2">第二步</button></li><li class="tab"><button data-href="#content-1-3">第三步</button></li><li class="tab"><button data-href="#content-1-4">第四步</button></li><li class="tab"><button data-href="#content-1-5">第五步</button></li><li class="tab"><button data-href="#content-1-6">第六步</button></li><li class="tab"><button data-href="#content-1-7">第七步</button></li><li class="tab"><button data-href="#content-1-8">第八步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-1-1"><blockquote><p>输入账号/邮箱/密码。账号必须唯一</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/rBsedoCKzcDTiZ1.png" alt="进Github网站.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-2"><blockquote><p>这一步是验证你是不是人机，图像没出来的话，请等一等，或者刷新一下。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/2mSGPx5e6zupgvI.png" alt="验证.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-3"><blockquote><p>不用管往下拉<code>Complete SignUp</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/HgpeDkVqOcREJza.png" alt="往下拉.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-4"><blockquote><p>到这里验证一下邮箱。你可以登陆你刚才注册用的邮箱，看下邮件，点击邮件里面的验证<code>Verify Email</code>。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/lFimT16bKGWqoyL.png" alt="邮箱验证.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-5"><blockquote><p><code>Create a repository</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/wObKJgHhd89vmiq.png" alt="创建库.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-6"><blockquote><p>你的用户名叫什么，就<code>[用户名].github.io</code>     一定要叫这个名字。像下面这样，还有记得点初始化一个<code>README</code>文件。<code>很重要！！！！</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/EzSGVjIuCkp3L4U.png" alt="给你的库取名字.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-7"><blockquote><p>创建好后就是下面这种情况</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/98R4pPeDmfnwQTy.png" alt="sign-up-github-8.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-8"><blockquote><p>访问一下看行不行，正常情况都能访问。（如果你是之前创建的<code>Github</code>账号是要去<code>settings</code>里面设置配置<code>pages</code>，现在创建了这个名字的<code>Repository</code>资料库就行了）。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/10/tvfePlZQxGFwsKE.png" alt="完成github方面内容.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><blockquote><p>双击安装包，一直点<code>next</code>，要注意勾选<code>Additional icons</code>就行。安装好后，桌面有个左上角的图标的快捷方式，就算安装成功了。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/1kCMnq6A5mu7Rhw.png" alt="git-install.png"></p><h2 id="下载NodeJs"><a href="#下载NodeJs" class="headerlink" title="下载NodeJs"></a>下载NodeJs</h2><div class="tabs" id="content-2"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-2-1">第一步</button></li><li class="tab"><button data-href="#content-2-2">第二步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-2-1"><blockquote><p>下载好后双击安装的<code>NodeJs.msi</code>文件，一直点击<code>next，accept</code>，<code>next</code>直到完成。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/q9BPbgxu4KvdzEy.png" alt="nodejs-1.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-2-2"><blockquote><p>安装完成后，按<code>win+R</code>键，输入<code>cmd</code>。再输入<code>node -v</code>或者<code>npm -v</code>，如果有版本号输出，那就是安装好了。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/8VXolPkHaDpQnyG.png" alt="nodejs-2.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="VsCode安装"><a href="#VsCode安装" class="headerlink" title="VsCode安装"></a>VsCode安装</h2><blockquote><p>一直点下一步就行了，记得点一个创建桌面快捷方式。安装好后有个快捷方式</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/V1vrnFZlN6Lb5BO.png" alt="icons.png"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="必须执行的操作"><a href="#必须执行的操作" class="headerlink" title="必须执行的操作"></a>必须执行的操作</h2><div class="tabs" id="content-3"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-3-1">第一步</button></li><li class="tab"><button data-href="#content-3-2">第二步</button></li><li class="tab"><button data-href="#content-3-3">第三步</button></li><li class="tab"><button data-href="#content-3-4">第四步</button></li><li class="tab"><button data-href="#content-3-5">第五步</button></li><li class="tab"><button data-href="#content-3-6">第六步</button></li><li class="tab"><button data-href="#content-3-7">第七步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-3-1"><blockquote><p>输入并执行以下命令，一条一条复制粘贴按回车。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">cd Desktop</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/U3dpLYVxeS8iHQ1.png" alt="operation-1.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-3-2"><blockquote><p>在浏览器中输入<code>localhost:4000</code>会看到以下页面</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/ucrFiQ4l35XKYbv.png" alt="operation-2.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-3-3"><blockquote><p>返回之前的命令行窗口，按<code>ctrl+c</code>输入<code>Y</code>。确定你在 <code>Desktop/blog/</code>文件夹下时，输入以下命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">git clone https://github.com/young1lin/hexo-butterfly-auxiliary-folder.git</span><br><span class="line"></span><br><span class="line">cd ../blog</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/LGCEztQYFDI2r6w.png" alt="operation-3.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-3-4"><blockquote><p>将下面的<code>/hexo-butterfly-auxiliary-folder/_data</code>文件夹剪切到<code>/blog/source</code>文件夹下。如图所示。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/27/JFQ7CsyZxtqkKuN.png" alt="blog_data.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-3-5"><blockquote><p>双击<code>VS Code</code>快捷键，然后在里面打开文件夹，操作如下</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/Ebm2jH3wITAilgB.png" alt="operation-5.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-3-6"><blockquote><p>更改<code>/blog/_config.yml</code>文件中的<code>theme</code>，将<code>landscape</code>改成<code>butterfly</code>。操作如下。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/11/kfVAn7EwQXMhbCJ.png" alt="operation-6.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-3-7"><blockquote><p>到这一步就完事了，在<code>blog</code>文件夹下输入下面的命令可以在本地跑了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></blockquote><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="自定义一些简单的内容"><a href="#自定义一些简单的内容" class="headerlink" title="自定义一些简单的内容"></a>自定义一些简单的内容</h1><div class="tabs" id="content-7"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-7-1">首页标题</button></li><li class="tab"><button data-href="#content-7-2">文章标签 tags （必选）</button></li><li class="tab"><button data-href="#content-7-3">文章分类 categories （必选）</button></li><li class="tab"><button data-href="#content-7-4">侧边栏显示</button></li><li class="tab"><button data-href="#content-7-5">头像（可选）</button></li><li class="tab"><button data-href="#content-7-6">首页字显示（可选）</button></li><li class="tab"><button data-href="#content-7-7">首页图片显示（可选）</button></li><li class="tab"><button data-href="#content-7-8">文章图片（可选）</button></li><li class="tab"><button data-href="#content-7-9">鼠标点击显示（可选）</button></li><li class="tab"><button data-href="#content-7-10">网页底部显示（可选）</button></li><li class="tab"><button data-href="#content-7-11">更多丰富的内容</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-7-1"><blockquote><p>在<code>/blog</code>下的<code>_config.yml</code> 里面可以改</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/iyX2VuzJb3YoA6a.png" alt="_config-yml.png"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/XnEFykpmvc1rxCN.png" alt="_config-yml-display.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-2"><blockquote><p>在/blog 下面执行 <code>hexo new page tags</code> ，找到对应文件夹下面的<code>index.md</code>文件，在下面的文件上加上 <code>type: &quot;tags&quot;</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/ph7IvoMS2zaZbKL.png" alt="create-tags-categories-1.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-3"><blockquote><p>在<code>/blog</code> 下面执行 <code>hexo new page categories</code>  和上面的操作一样，找到<code>/blog/categories/</code>文件夹下面的<code>index.md</code>文件，在下面的文件上加上 <code>type: &quot;categories&quot;</code>。这里个<code>tags</code>改成<code>categories</code>就行了。<br><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/ph7IvoMS2zaZbKL.png" alt="create-tags-categories-1.png"></p></blockquote><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-4"><blockquote><p><code>aside</code>这里可以改公告内容，侧边栏在哪边显示等等</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/4xbjFcG6U5KpXiw.png" alt="aside.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-5"><blockquote><p>avatar:</p><p>  img: /img/yinyang.png</p><p>  effect: false # 这个是是否旋转你的头像，默认是false</p><p><code>img</code> 是图片路径，在<code>/blog /themes/butterfly/source/img</code>下。粘贴自己想上传的头像，把这里的路径改一下，就可以了。我建议改成去图床获取头像，减少页面加载时。例如 img: <a href="https://i.loli.net/2020/08/15/cAenSihrD4CI3p9.png" target="_blank" rel="noopener">https://i.loli.net/2020/08/15/cAenSihrD4CI3p9.png</a></p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/fgmXM2hJxWtPGL3.png" alt="image.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-6"><blockquote><p><code>subtitle</code>的<code>sub</code> </p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/jzIcfuUv5omHKyV.png" alt="subtitle-font.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-7"><blockquote><p><code>defual_top_img</code> 图片中介绍</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/wTtp4Ccsl7xbeM1.png" alt="top_img.png"><br><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/C3eEWDBO2QtGmvd.png" alt="top_img_display.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-8"><blockquote><p>搜索<code>cover</code>这个是默认的文章封面，第二张图是文章中如何更改封面，第三张图是封面展示</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/gTQvcMCmfGSPxJp.png" alt="default_cover_setting.png"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/y1EPilIkM2nLKNv.png" alt="change_cover_tags_categories.png"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/ReZPKyzm5uviG7D.png" alt="image.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-9"><blockquote><p><code>ClickShowText</code> 三选一，我建议是第三个</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/GWeNd83w5mfFV4S.png" alt="click-show-text.png"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/XonEGwuMAUWVNRs.png" alt="click-show-text-display.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-10"><p><code>footer_custom_text</code> 改成你想要展示的内容</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/EqRdjYe4AF1VLxb.png" alt="footer_custom_text.png"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/Yr762KzWou3HSOa.png" alt="foot-display.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-7-11"><p>添加 <code>QQ</code> 音乐列表，以及如何获得<code>音乐 ID</code>和<code>音乐列表 ID</code>。</p><ol><li>网页登录<code>QQ</code>音乐</li><li>到你的歌单中</li><li>按<code>F12</code>，点到控制台顶部<code>network</code></li><li>刷新页面</li><li><a href="https://c.y.qq.com/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg" target="_blank" rel="noopener">https://c.y.qq.com/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg</a> 这个请求响应里面，<code>disstid: &quot;7652784085&quot;</code> 这就是歌单 id，<code>songlist</code> 下是该歌单下所有歌曲信息（里面有很多重复的请求，外表光鲜亮丽，，网页版 QQ 音乐已经烂了，很多无用的请求虽然只有几 ms）。</li><li>具体使用歌单 ID，<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md" target="_blank" rel="noopener">请参考</a></li></ol><p>更多设置，<a href="https://demo.jerryc.me/" target="_blank" rel="noopener">请参考</a></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>可以通过两种方式，</p><ol><li><p><code>hexo new</code> ‘’这是一片文章’’</p></li><li><p>直接在<code>blog/source/_posts</code>/中创建 <code>md</code> 文件，其实就是文本文件，你只要改后缀名就行了</p></li></ol><p>文章头部有以下信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 搭建免费博客网站懒人包</span><br><span class="line">date: 2020-07-10 21:51:58</span><br><span class="line">tags: “搭建博客”</span><br><span class="line">categories: "搭建博客"</span><br><span class="line"><span class="section"># 如果hexo g生成文章时报错，请把 Front-matter 也就是这里的内容删了，重新写一遍</span></span><br><span class="line"><span class="section"># ...等等，还要设置其他具体内容例如该文章头部图片，尾部图片等等，[请参考](https://demo.jerryc.me/posts/dc584b87/)</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="部署到-Github-上"><a href="#部署到-Github-上" class="headerlink" title="部署到 Github 上"></a>部署到 Github 上</h1><div class="tabs" id="content-11"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-11-1">第一步</button></li><li class="tab"><button data-href="#content-11-2">第二步</button></li><li class="tab"><button data-href="#content-11-3">第三步</button></li><li class="tab"><button data-href="#content-11-4">第四步</button></li><li class="tab"><button data-href="#content-11-5">第五步</button></li><li class="tab"><button data-href="#content-11-6">第六步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-11-1"><blockquote><p>同样的，在 <code>/blog</code>文件夹下，进行输入命令。通过 <code>Git bash</code>来操作，双击桌面的<code>Git bash</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd Desktop/blog</span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">git config --global user.name "你的 github 名字"</span><br><span class="line"></span><br><span class="line">git config --global user.email "你的邮箱"</span><br><span class="line"></span><br><span class="line">ssh-keygen -o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一直按回车就行了</span></span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制下面内容</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/NKgE1UqAi4X2fMR.png" alt="deploy-1.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-11-2"><blockquote><p>到你的<code>github</code>下面的<code>xxxx.github.io repository</code> 下面，按步骤点击</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/raDgmH87OqEFLsy.png" alt="deploy-2.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-11-3"><blockquote><p>添加 <code>deploy key</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/dgEbFLUWJCHKDSY.png" alt="deploy-3.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-11-4"><blockquote><p>更改<code>/blog</code>下面的 <code>_config.yml</code> 文件。按照图中内容输出</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/6QfV4eXZPTl8B2L.png" alt="deploy-4.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-11-5"><blockquote><p>在<code>Git bash</code> 里面输入。执行完下面三个命令，会让你输入用户名和密码，输你自己的 <code>Github</code>的用户名和密码</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/gNoEnxmvDhsIPFd.png" alt="hexo-deploy-5-1.png"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/UewBXzusHpyE5LY.png" alt="hexo-deploy-5-2.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-11-6"><blockquote><p>一分钟左右，甚至马上你就可以访问<code>xxxxx.github.io</code>  这个<code>xxxx</code>是你的用户名</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/19/QCYZRLMvxtHkX1r.png" alt="hexo-deploy-6.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="之后部署"><a href="#之后部署" class="headerlink" title="之后部署"></a>之后部署</h1><h2 id="写一篇文章并部署至-GithubPages-（xxxx-github-io）"><a href="#写一篇文章并部署至-GithubPages-（xxxx-github-io）" class="headerlink" title="写一篇文章并部署至 GithubPages （xxxx.github.io）"></a>写一篇文章并部署至 GithubPages （xxxx.github.io）</h2><blockquote><p>在 <code>Teminal</code>  中 <code>/blog</code> 文件夹下输入下面命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo new "这是一篇文章"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你改动了除了文章下的文件，我建议你执行一下这个命令</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 至此搞定</span></span><br></pre></td></tr></table></figure><blockquote><p>可以在<code>hexo g</code> 之后，执行<code>hexo s</code>，来在本地运行，访问 <code>localhost:4000</code> 先审视一遍文章。</p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="推荐的图床"><a href="#推荐的图床" class="headerlink" title="推荐的图床"></a>推荐的图床</h2><blockquote><p>超过 <code>1M</code> 的图片，我建议<a href="https://tinyjpg.com/" target="_blank" rel="noopener">压缩</a>一下</p></blockquote><blockquote><ol><li><p><a href="sm.sm"><code>sm.ms</code></a>这个不需要登陆就可以传图片，但是为了之后的图片找回，最好还是登陆一下，国内也能访问。最好不要把大图片放在<code>img</code>文件夹下，加载非常慢。低效。其他图床要么要登陆才能传，要么有很多限制，要么大陆访问不了。</p></li><li><p><a href="https://sbimg.cn/" target="_blank" rel="noopener">公益图床。</a></p></li><li><p><a href="https://imgchr.com/" target="_blank" rel="noopener">路过图床。</a></p></li><li><p>其他什么七牛云之类要实名认证的，我不推荐，操作极其繁琐。</p></li></ol></blockquote><h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><blockquote><p>我推荐 <code>Typora</code> 。下了腾讯管家的，可以在它的软件管家下载这个软件，或者 <code>Google</code>搜官网（我试过了，官网下载超级慢）。</p><p>如果你有更好用的 <code>MarkDown</code> 编辑器推荐的话，欢迎留言。</p></blockquote><h2 id="文章格式建议"><a href="#文章格式建议" class="headerlink" title="文章格式建议"></a>文章格式建议</h2><blockquote><ol><li>英文字母与中文空格出一行，或者用 1左边的按键输出的符号，包裹住英文字符。</li><li>每个段落阐明不同意思，<code>Markdown</code>编辑器已经默认帮你每个段落隔开一行了。</li><li>一个<code>#</code>号表示一级标题，<code>##</code>表示二级标题，以此类推。</li><li>更多<a href="https://github.com/ruanyf/document-style-guide" target="_blank" rel="noopener">文章格式参考</a></li><li>更多 <code>Markdown</code> 语法的介绍，可以看<a href="https://chrisniael.gitbooks.io/gitbook-documentation/content/format/markdown.html" target="_blank" rel="noopener">这里</a></li></ol></blockquote><h2 id="利用-CDN-和域名加速你的-Github-Pages"><a href="#利用-CDN-和域名加速你的-Github-Pages" class="headerlink" title="利用 CDN 和域名加速你的 Github Pages"></a>利用 CDN 和域名加速你的 Github Pages</h2><p>在<code>source</code>文件夹下，新增 <code>CNAME</code>文件，填上你的域名。具体操作，参考<a href="https://cyfeng.science/2020/02/02/cloudflare-github-pages/" target="_blank" rel="noopener">这里</a>。我翻了几十篇博客，找到这个适合的。域名购买以及 <code>CDN</code>选择，参考那篇文章。可以用免费的域名（不推荐，除非你只是拿来玩一玩的），也可以买 <code>me</code> 结尾的域名，具体购买，知乎上有域名购买推荐，例如<a href="https://www.zhihu.com/question/19551906" target="_blank" rel="noopener">这篇</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">hexo</a></p></blockquote><blockquote><p><a href="https://demo.jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">hexo的butterfly主题</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_39207948/article/details/79449633" target="_blank" rel="noopener">npm配置国内镜像资源+淘宝镜像</a></p></blockquote><blockquote><p><a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">Markdown中文文档</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/35270383" target="_blank" rel="noopener">盘点国内免费好用的图床</a></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="tools" scheme="https://young1lin.github.io/categories/tools/"/>
    
    
    <category term="搭建博客" scheme="https://young1lin.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>平时遇到的问题</title>
    <link href="https://young1lin.github.io/2020/07/09/problem/"/>
    <id>https://young1lin.github.io/2020/07/09/problem/</id>
    <published>2020-07-08T16:00:00.000Z</published>
    <updated>2021-01-03T15:01:47.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-qRIXdKsj" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7652784085" data-server="tencent" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="200px" data-preload="none" data-theme="#ad7a86" data-loop="all"    ></div><h1 id="范型语法糖"><a href="#范型语法糖" class="headerlink" title="范型语法糖"></a>范型语法糖</h1><p><code>Jackson</code>里面有个转字符串为<code>Java</code>对象的方法，传进去的是</p><p>大概像下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsertRecords</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">  Map&lt;String,String&gt; record = parseObject(str,Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String ageStr = record.get(<span class="string">"age"</span>);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *这里如果你这样写，如果你传进去的是&#123;name:"Yasir Lin",age:"23"&#125;,这样没问题，但是你要是传进去的是&#123;name:"Yasir Lin",age:23&#125;</span></span><br><span class="line"><span class="comment">  *就会报错误，因为范型是个语法糖，你定义了Key为String，结果是String，那没问题，定义了Value为String，实际是Integer，</span></span><br><span class="line"><span class="comment">  * 它在取值的时候，就会隐式给你强转为String类型，然后类型是Integer，出来就会报错。Integer cannot be cast to String。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 这边以我这边的业务为准的话，这样写是正确的，因为这边确定Key的类型一定为String，Value不确定而已</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Map&lt;String,Object&gt; correctRecord = parseObject(str,Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Integer ageInt = correctRecord.get(<span class="string">"age"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于隐式转换，不只是 Java 的拆装箱，范型，在其他地方也有，如<code>SQL</code>，<code>select * from t where id = 1</code>;<code>select * from t where id =&#39;1&#39;</code>完全是两个东西，一个会不走索引，一个走一级（主键）索引</p><p>在<code>JDK1.5</code>前，范型(Java这里只是个语法糖/伪范型，每个编程语言都会去实现它)没有出来的时候，像<code>ArrayList</code>里面提供的就是<code>Object</code>返回。没有<code>return (E) elementData[index]</code>这里面是没有E的，是<code>Object</code>类型。能够在编译时检查类型错误，利用<code>get()</code>方法取出的对象也不再是<code>Objec</code>t引用，编译器可以认识此类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> listSize = <span class="number">4</span>;</span><br><span class="line">      <span class="comment">// 这里的foo/bar没有什么深层次意思，就像你打游戏开局打怪是哥布林/史莱姆一样，学其他知识也是这么写（eg.Vue）</span></span><br><span class="line">        <span class="comment">// 还有创建容器的时候，最好根据实际量多少，指定容器大小，避免重复1.5倍扩容，也避免过多浪费内存。也算个Java小优化</span></span><br><span class="line">      <span class="keyword">byte</span>[] bar = &#123;<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'r'</span>&#125;;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList(listSize);</span><br><span class="line">        list.add(<span class="string">"foo"</span>);</span><br><span class="line">      <span class="comment">// 这里不能直接在add()方法里面写&#123;'b','a','r'&#125;,这样编译不通过，数组类型在Java里面比较特殊，它的初始化不像其他类型，</span></span><br><span class="line">      <span class="comment">// 它是有专门的array类型去初始化的，不像C++就直接是分配一整块内存，Java为了实现更安全的对数组进行操作，进行了包装数组</span></span><br><span class="line">      <span class="comment">// 对象（《深入理解Java虚拟机》里面有讲）</span></span><br><span class="line">        list.add(bar);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">1L</span>);</span><br><span class="line">        <span class="comment">// 上面的代码是完全没问题的（我是指编译没问题）</span></span><br><span class="line">        <span class="comment">// 当你想下面做的时候</span></span><br><span class="line">      <span class="comment">// 进行下面操作的时候，最好将ArrayList的大小提出来，避免重复进行getSize();尽量减少方法调用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,size=listSize;i&lt;size;++i)&#123;</span><br><span class="line">            String str = (String)list.get(i);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            <span class="comment">// 执行到这里就会报错，编译不会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.8还是在里面维护了一个Object数组，elementData;</span></span><br><span class="line"><span class="comment">// 然后调用</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></span><br></pre></td></tr></table></figure><p>很多人可能说，我怎么可会犯这种错误。当你指定类型不明确时，进行强转，就会出现这个问题。</p><h1 id="HBase-Scan-PageFilter"><a href="#HBase-Scan-PageFilter" class="headerlink" title="HBase Scan PageFilter"></a>HBase Scan PageFilter</h1><p> HBase Scan PageFilter 设置的返回数据量和实际返回的数据量不同。低版本的 Scan 没有 setLimit 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">scan.setFilter(<span class="keyword">new</span> PageFilter(<span class="number">200</span>));</span><br></pre></td></tr></table></figure><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>上面很大可能返回大于 200 条记录。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>HBase 里 Filter 状态全部都是 Region 内有效的，也就是说，Scan 一旦从一个 Region 切换到另一个 Region，之前那个 Filter 的内部状态就无效了，新 Region 内用的其实是一个全新的 Filter。具体到这个问题，就是 PageFilter 内部计数器从一个 Region 切换到另一个 Region，计数器已经被清 0。<em>——来自《HBase 原理与实践》</em></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>手动利用 List#subList 方法，在返回结果前截取对应 pageSize 条数记录。</li><li>升级 HBase 客户端代码，使用 scan#setLimit 方法。</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="tools" scheme="https://young1lin.github.io/categories/tools/"/>
    
    
    <category term="Q" scheme="https://young1lin.github.io/tags/Q/"/>
    
  </entry>
  
  <entry>
    <title>大数据简介</title>
    <link href="https://young1lin.github.io/2020/06/18/BigData/"/>
    <id>https://young1lin.github.io/2020/06/18/BigData/</id>
    <published>2020-06-17T16:00:00.000Z</published>
    <updated>2022-09-05T14:25:22.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="大数据（BigData）三要素"><a href="#大数据（BigData）三要素" class="headerlink" title="大数据（BigData）三要素"></a>大数据（BigData）三要素</h1><p>“大数据”是指传统数据处理应用软件时，不足以处理的大的或者复杂的数据集的术语。</p><p><strong>大数据是个抽象的概念</strong>，和虚拟机一样，具体实现各有不同。每个语言的实现都是不一样的，这里讲的是 Java 相关的，应用相对来说很广的大数据组件。要了解结构化/非结构化/半结构化数据、数据挖掘相关的内容，可自行搜索其他的，这里只讲部分。</p><p>大数据又称海量数据。所有的大数据相关的中间件都离不开下面三个问题。</p><ol><li>如何保存海量数据</li><li>如何从海量数据中取有用的数据</li><li>以什么格式保存海量数据，高效插入和查询数据</li></ol><p>什么上卷，下钻，slice，dice，那是 OLAP 里面的内容，Wikipedia 里面把这个搞在一起了，虽然事实上两者经常混在一起。</p><h2 id="如何保存海量数据"><a href="#如何保存海量数据" class="headerlink" title="如何保存海量数据"></a>如何保存海量数据</h2><p><strong>GFS 登场</strong>，不要跟我说什么 RAID，不停加磁盘也是有限制的。</p><blockquote><p>文件就是字节序列，仅此而已——《深入理解计算机系统》</p></blockquote><p>Google File System 是 Google 发表的论文，提出了这个概念，Google 内部有实现了这个理论文件系统。Hadoop 内部实现叫 HDFS（Hadoop Distrubuted File System），其实就是加强版的文件系统。</p><p>下面是 HDFS 的总体架构图，主要是分两块</p><p><img src= "/img/loading.gif" data-src="https://hadoop.apache.org/docs/r1.2.1/images/hdfsarchitecture.gif" alt="hdfs"></p><h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><p><strong>什么是元信息？</strong></p><p>元信息是关于信息的信息，用于描述信息的结构、语义、用途和用法等。[^1]:</p><p>我认为是最小单元信息，精简的不能再精简的那种信息，相当于句柄。</p><p>这里的 NameNode 就是部署在一台服务器上，上面保存了元（必要的）信息。例如在 HDFS 中的文件路径，文件权限信息，文件具体在哪几个 DataNode 上的信息。比如我一个存在 HDFS 上一个文件，路径是 /tmp/shaluan/aorui.log，它是一个日志文件，我通过客户端传上去的。然后元信息就有[^2]:</p><ol><li>文件、目录自身的属性信息，例如文件名，目录名，能对这个文件进行 write/read/recute 等操作信息等。</li><li>文件记录的信息的存储相关的信息，例如存储块信息，分块情况，副本个数等。</li><li>记录 HDFS 的 DataNode 的信息，用于 DataNode 的管理。</li></ol><p>NameNode 也是有主备（这里是主备，不是主从）的，保证 HDFS 高可用。</p><h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><p><strong>实际保存的文件的组件。</strong>可以看作一个 NameNode 部署在一个服务器上。</p><p>数据你看上去是 TB 级别的，其实里面被分成了很多个文件块。可能是 1 GB 一个文件块，每次读取文件的时候，就读那一小块。</p><p>而且一份数据不是单独保存在一个 DataNode 的，会进行冗余，保存在多个 DataNode 上，防止一个 DataNode 挂了，然后丢失数据的情况。多个 DataNode 同时挂掉的概率不大，不考虑这种情况。</p><p>DataNode 配合上 RAID，这样数据丢失的概率大大降低了。</p><h2 id="如何高效地从海量数据中取有用的数据"><a href="#如何高效地从海量数据中取有用的数据" class="headerlink" title="如何高效地从海量数据中取有用的数据"></a>如何高效地从海量数据中取有用的数据</h2><p><strong>MapReduce 登场</strong>，MapReduce 既是一种编程模型，在 Hadoop 里面的实现也叫 MapReduce。</p><p>这个理解起来比较费劲，就是 映射 &gt; 归纳。你可以看作是一条 SQL 执行过程中，执行  SQL 语法解析树的过程。Reduce 就是规约，减少的意思，其实就是类似 Group By 操作，如果你看懂了我之前写的 UDAF 文章，那个类，理解起来就比较轻松了。</p><p>可以在多个机器上，采用并行的方式，进行高效的计算。</p><p>下面就是 Mapreduce 的过程，分词 -&gt; 映射 -&gt; 分组 -&gt; 归纳（减少）</p><p><img src= "/img/loading.gif" data-src="https://s3-us-west-2.amazonaws.com/content.edupristine.com/images/blogs/mapreduce-example.jpg" alt="mapreduce"></p><p>实际在需要编写 Mapper 类和 Redue 类来操作数据。</p><p>详细的内容可以参考<a href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/Hadoop-MapReduce.md" target="_blank" rel="noopener">这个</a>。</p><h2 id="以什么格式保存海量数据，高效插入和查询数据"><a href="#以什么格式保存海量数据，高效插入和查询数据" class="headerlink" title="以什么格式保存海量数据，高效插入和查询数据"></a>以什么格式保存海量数据，高效插入和查询数据</h2><p><strong>BigTable 登场。</strong> <strong>BigTable</strong>是一种<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>的、高性能的、高可扩展性的，基于<a href="https://zh.wikipedia.org/wiki/Google檔案系統" target="_blank" rel="noopener">Google文件系统</a>（Google File System，GFS）的数据存储系统，用于存储大规模结构化数据，适用于<a href="https://zh.wikipedia.org/wiki/雲端計算" target="_blank" rel="noopener">云端计算</a>。[^3]:</p><p>高效插入数据，不支持删除数据，只能根据时间戳来更新数据的 NoSQL 数据库。</p><p><img src= "/img/loading.gif" data-src="https://media.geeksforgeeks.org/wp-content/uploads/1111-7.png" alt="Hbase"></p><p>下面是 HBase 🐳的表结构，<strong>一个字段只有时间戳</strong>、<strong>RowKey</strong>（关系数据库中的 id）和 <strong>col</strong>（关系数据库中的字段，什么 deleted，create_date这种）。然后映射表（实际取数据的表，映射成行式数据库）就是根据实际的 rowkey 和 col（字段）映射出来易于理解的关系型数据库类型的表。注意这个 ps 下的 ps 的1234 和 5678，他这个 t16 比 t02 晚，所以取最新的数据。HBase 不会删数据，只会取最新的数据。</p><p><img src= "/img/loading.gif" data-src="https://www.warpcloud.cn/docs/images/TDH-PLATFORM/7.0/030HyperbaseManual/mapping_hbase_table_2.jpg" alt="hbase表结构"></p><p>在实际生产中，一般也就一个列族，RowKey 等长，不是特别长的 RowKey 等等设计，原因可以看《HBase 原理与实战》这本书。</p><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><h2 id="Zookeeper-集群信息管理"><a href="#Zookeeper-集群信息管理" class="headerlink" title="Zookeeper 集群信息管理"></a>Zookeeper 集群信息管理</h2><p>这么多东西，全是一主多从的架构方式，让谁管理？Zookeeper 就登场了。</p><p>Zookeeper（动物管理员）为什么叫动物管理员，和上面的 HBase（🐳）Hadoop（🐘）以及下面的 Hive（🐝）Pig（🐷）有关。全是动物 logo，管理这些动物信息，能不叫 Zookeeper 吗。</p><p>用于管理主从信息，以及主从选举，如果从节点掉了，剔除从节点，保证高可用的中间件。ZooKeeper曾经是<a href="https://zh.wikipedia.org/wiki/Hadoop" target="_blank" rel="noopener">Hadoop</a>的一个子项目，但现在是一个独立的顶级项目。[^4]:</p><p>当然 Zookeeper 也是一主多从架构。一个 Leader 多个 follower。</p><p><img src= "/img/loading.gif" data-src="https://zookeeper.apache.org/doc/current/images/zkservice.jpg" alt="zk"></p><p>也是以文件形式保存信息的，一切皆文件。例如 /ids/broker/olap01，然后这个节点保存了很多信息，什么时间，ip 地址都可以塞进去。</p><p>主要分两种节点，细分是 4 种。</p><ol><li>持久化节点</li><li>临时节点</li></ol><p>第一个永久保存的，第二个客户端连接的时候有，session 断了就没了。</p><h2 id="Yarn-资源管理"><a href="#Yarn-资源管理" class="headerlink" title="Yarn 资源管理"></a>Yarn 资源管理</h2><p>其实很多组件的一部分都是在一台机器上的，比如 Zookeeper 的一个 follower 在服务器 A 上，HDFS 的 DataNode 也在，HBase 的 HMaster 也在。计算机资源（cpu 算力，内存容量等等）是有限的，所以要通过一个组件来调度这些组件合理的利用服务器资源。</p><p><img src= "/img/loading.gif" data-src="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/yarn_architecture.gif" alt="yarn"></p><h1 id="降低开发难度"><a href="#降低开发难度" class="headerlink" title="降低开发难度"></a>降低开发难度</h1><p>哦，每次我要统计的时候，我都要写 Mapper 和 Reducer 函数，累不累？那些数学好，编程一般的，怎么做数据分析？有没有更简单的方式来搞？</p><p><strong>Hive 和 Spark SQL 登场了。</strong></p><h2 id="Hive🐝"><a href="#Hive🐝" class="headerlink" title="Hive🐝"></a>Hive🐝</h2><p><strong>Apache Hive</strong>是一个建立在<a href="https://zh.wikipedia.org/wiki/Hadoop" target="_blank" rel="noopener">Hadoop</a>架构之上的数据仓库。它能够提供数据的精炼，查询和分析。[^5]:</p><p>上面的解释太官方了，其实就是你写 SQL，Hive 帮你把 SQL 转换成对应 MapReduce 任务，让你更方便查数据而已。</p><p>和一般规范的 SQL 没差，就是 insert into table（这里要加个 table 关键字）tableName，还有 UDAF 中不能嵌套其他方法，例如 <code>select myudaf(avg(x),avg(y)) from xxtable group by x;</code></p><p>Hive 上不存数据，数据存在 HDFS 上，有比较多的数据格式存储。例如存成 Text、CSV、ORC、Holodesk等。数据是像下面这样存的。</p><p>employee.txt 这里面就以换行作为分隔符，也有用 \t 作为分隔符，分离成数据的。结合上面的 MapReduce 图就能看懂了。也可以用 ｜ 作为分隔符，怎么舒服怎么来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,Alice</span><br><span class="line">2,Bob</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> employee (<span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">STRING</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></span><br><span class="line">LOCATION <span class="string">'/manual_crud_tmp/employee'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Id</th><th>Name</th></tr></thead><tbody><tr><td>2</td><td>Bob</td></tr><tr><td>1</td><td>Alice</td></tr></tbody></table><p>下面是 Hive 的 JDBC URL。Hive2 协议解决了 Hive 协议的一些bug，所以现在用 Hive2 协议。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:hive2://127.0.0.1:10000/xxx --maxWidth=1000</span><br></pre></td></tr></table></figure><h2 id="Pig-🐷"><a href="#Pig-🐷" class="headerlink" title="Pig 🐷"></a>Pig 🐷</h2><p><strong>Pig</strong>是一个基于<a href="https://zh.wikipedia.org/wiki/Apache_Hadoop" target="_blank" rel="noopener">Apache Hadoop</a>的大规模数据分析平台，它提供的 SQL-LIKE 语言叫Pig Latin，该语言的编译器会把类<a href="https://zh.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">SQL</a>的数据分析请求转换为一系列经过优化处理的<a href="https://zh.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">MapReduce</a>运算。Pig 为复杂的海量数据并行计算提供了一个简单的操作和编程接口，使用者可以透过<a href="https://zh.wikipedia.org/wiki/Python" target="_blank" rel="noopener">Python</a>或者<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>编写<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>，之后再重新转写。</p><p>和 Hive 功能差不多，就是把特定的语言转换成 MapReduce 运算，只是不是用 SQL 这种语言。</p><h2 id="SlipStream-Flink"><a href="#SlipStream-Flink" class="headerlink" title="SlipStream/Flink"></a>SlipStream/Flink</h2><p>也是 SQL，简化开发，上面的 Hive 只能是说作为离线数据，进行批处理。这两个组件，前者是 TDH 内置的流处理组件，后者 Flink 是阿里等大型企业推荐并提交源码的流处理组件。</p><h3 id="什么是批数据？"><a href="#什么是批数据？" class="headerlink" title="什么是批数据？"></a>什么是批数据？</h3><p>有界流数据。</p><p>利用 Sqoop 可以做定时任务，每天在业务低谷期，从线上关系型数据库中抽取数据到 HDFS，可以用做离线数据分析等。</p><p>你可以把 Sqoop 想象成抽水机，数据（水）在不同数据库（水源）中，抽到 HDFS 中，然后 Hive 可以从 HDFS “导入”数据。</p><p>下面是 Sqoop 的一个用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop import --append --connect jdbc:mysql://localhost:3306/mall --username root --password 123456 --target-dir /long/sqoop --m 1 --table goods --fields-terminated-by '\t';</span><br></pre></td></tr></table></figure><h3 id="什么是流数据？"><a href="#什么是流数据？" class="headerlink" title="什么是流数据？"></a>什么是流数据？</h3><p>无界流数据。</p><p>比如 SlipStream （TDH 内的组件）就是创建表的时候绑定 Kafka 的某个 Topic，源源不断的从该 Topic 读取数据。避免上游数据量过大，消费不过来，从而需要反压机制（这个在另一篇介绍数据仓库的文章会提到）。</p><p>TDH 很多银行在用，对标的是国外知名的 CDH，就是贡献那个有 Cloudera Kafka 的。</p><h3 id="为什么要这么处理？"><a href="#为什么要这么处理？" class="headerlink" title="为什么要这么处理？"></a>为什么要这么处理？</h3><p>可以求线性回归方程相关系数，来确定两个字段的相关值，进而做一系列的数据分析。</p><p>像下面这样，搜索量和票房的关系。</p><p><img src= "/img/loading.gif" data-src="http://www.tjxzj.net/wp-content/uploads/2020/01/2020010202173618.jpg" alt=""></p><p>S 赛的 KI 上校（就是肯德基那个），是通过大量的离线数据（过去的大量玩家的比赛记录）分析 + 实时数据分析（当场比赛数据） =&gt; 推导出胜负曲线。狭义的数据分析分三块，现状分析、原因分析、预测分析，S 赛的 KI 上校就是先现状分析 –&gt; 原因分析 –&gt; 预测分析。</p><h1 id="CDH-TDH"><a href="#CDH-TDH" class="headerlink" title="CDH/TDH"></a>CDH/TDH</h1><h2 id="CDH"><a href="#CDH" class="headerlink" title="CDH"></a>CDH</h2><p>Cloudera Data Hub</p><h2 id="TDH"><a href="#TDH" class="headerlink" title="TDH"></a>TDH</h2><p>Transwarp Data Hub</p><p>TDC </p><p>Transwarp Data Cloud</p><h1 id="大数据就业方向"><a href="#大数据就业方向" class="headerlink" title="大数据就业方向"></a>大数据就业方向</h1><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><h3 id="数据科学研究"><a href="#数据科学研究" class="headerlink" title="数据科学研究"></a>数据科学研究</h3><p>数据科学家是一个全新的工种，能够将企业的数据和技术转化为企业的商业价值。随着数据学的进展，越来越多的实际工作将会直接针对数据进行，这将使人类认识数据，从而认识自然和行为。Deep Learning、Machine Learning。</p><h3 id="数据预测分析"><a href="#数据预测分析" class="headerlink" title="数据预测分析"></a>数据预测分析</h3><p>营销部门经常使用预测分析预测用户行为或锁定目标用户。预测分析开发者有些场景看上有有些类似数据科学家，即在企业历史数据的基础上通过假设来测试阈值并预测未来的表现。</p><p><em>这是你们以为的大数据开发。</em></p><h2 id="数据应用开发"><a href="#数据应用开发" class="headerlink" title="数据应用开发"></a>数据应用开发</h2><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>为方便企业决策，出于分析性报告和决策支持的目的而创建的数据仓库研究岗位是一种所有类型数据的战略集合。为企业提供业务智能服务，指导业务流程改进和监视时间、成本、质量和控制。</p><p><strong>报表 + 多维度数据库联机查询。</strong>做报表的。</p><h3 id="数据安全研究"><a href="#数据安全研究" class="headerlink" title="数据安全研究"></a>数据安全研究</h3><p>数据安全这一职位，主要负责企业内部大型服务器、存储、数据安全管理工作，并对网络、信息安全项目进行规划、设计和实施。成都加米谷大数据培训机构，专注于大数据人才培养。</p><p>说白了，大数据运维 + 安全管理员。一站式大数据平台就是降低大数据运维和应用难度的，例如 CDH、TDH、阿里的飞天大数据平台。</p><h3 id="企业数据管理"><a href="#企业数据管理" class="headerlink" title="企业数据管理"></a>企业数据管理</h3><p>企业要提高数据质量必须考虑进行数据管理，并需要为此设立数据管家职位，这一职位的人员需要能够利用各种技术工具汇集企业周围的大量数据，并将数据清洗和规范化，将数据导入数据仓库中，成为一个可用的版本。</p><p>下面是用 Kafka Streams 这种类型的做数据清洗和规范化大概的图。有三个系统，每个系统往不同的 topic 发消息，格式不同，然后数据清洗应用根据不同 Topic 设置不同规则，对数据进行清洗和规范化。当然这个数据清洗还可以做聚合运算等操作，将信息重新梳理，然后发给其他 Topic。</p><p>注：Kafka Streams 是一个非常非常非常基础的内容，很多东西你做不到配置即用，编写 SQL 就能跑起来这种境地，所以不建议在生产上直接使用 Kafka Streams 。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/10/22/KsHt7O3BgrMX1Gb.png" alt="数据清洗和规范化 _1_.png"></p><h3 id="信息架构开发"><a href="#信息架构开发" class="headerlink" title="信息架构开发"></a>信息架构开发</h3><p>大数据重新激发了主数据管理的热潮。充分开发利用企业数据并支持决策需要非常专业的技能。信息架构师必须了解如何定义和存档关键元素，确保以最有效的方式进行数据管理和利用。信息架构师的关键技能包括主数据管理、业务知识和数据建模等。</p><p>数据中台构建。</p><h3 id="OLAP开发"><a href="#OLAP开发" class="headerlink" title="OLAP开发"></a>OLAP开发</h3><p>OLAP在线联机分析开发者，负责将数据从关系型或非关系型数据源中抽取出来建立模型，然后创建数据访问的用户界面，提供高性能的预定义查询功能。</p><p><em>我这边就是和这个相关的，也和下面的研发沾点边，因为 HBase 和 Hive 没有提供健全的 HTTP 接口查询。目前只支持单表查询，以及 HBase 单表查询，并且采用 Fail-fast 原则，采用 FutureTask，必须在 6s 内返回结果，不至于一个查询拖垮整个链路调用，不至于其他系统调用我们的 Dubbo 服务出现问题。当然也解决了部分的 Spring boot data HBase 相关调用缓慢的问题。有点中间件的味道</em></p><h2 id="数据系统研发"><a href="#数据系统研发" class="headerlink" title="数据系统研发"></a>数据系统研发</h2><h3 id="二次开发-Hadoop-组件"><a href="#二次开发-Hadoop-组件" class="headerlink" title="二次开发 Hadoop 组件"></a>二次开发 Hadoop 组件</h3><p>或者直接开发一套解决大数据内容的中间件，用 Solr 或者 Elasticsearch 增强 HBase 这种。</p><h3 id="可视化工具开发"><a href="#可视化工具开发" class="headerlink" title="可视化工具开发"></a>可视化工具开发</h3><p>可视化开发就是在可视化工具提供的图形用户界面上，通过操作界面元素，有可视化开发工具自动生成相关应用软件，轻松跨越多个资源和层次连接所有数据。过去，数据可视化属于商业智能开发者类别，但是随着Hadoop的崛起，数据可视化已经成了一项独立的专业技能和岗位。</p><p>光有 Hadoop 可不行，还需要可视化的内容，去更加方便操作里面的组件。[^6]:</p><h1 id="Colossus"><a href="#Colossus" class="headerlink" title="Colossus"></a>Colossus</h1><p>GFS升级版</p><blockquote></blockquote><blockquote><p>[2]:<a href="https://blog.csdn.net/lb812913059/article/details/79717525" target="_blank" rel="noopener">Hadoop DataNode详解</a></p></blockquote><blockquote><p>[3]:<a href="https://zh.wikipedia.org/wiki/Bigtable" target="_blank" rel="noopener">BigTable 维基百科</a></p></blockquote><blockquote><p>[4]:<a href="https://zh.wikipedia.org/wiki/Apache_ZooKeeper" target="_blank" rel="noopener">Zookeeper 维基百科</a></p></blockquote><blockquote><p>[5]: <a href="https://zh.wikipedia.org/wiki/Apache_Hive" target="_blank" rel="noopener">Hive 维基百科</a></p></blockquote><blockquote></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="BigData" scheme="https://young1lin.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java(with Spring core)</title>
    <link href="https://young1lin.github.io/2020/06/18/Effective-Java-With-Spring/"/>
    <id>https://young1lin.github.io/2020/06/18/Effective-Java-With-Spring/</id>
    <published>2020-06-17T16:00:00.000Z</published>
    <updated>2021-10-04T14:28:30.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://www.oreilly.com/library/view/effective-java/9780134686097/" target="_blank" rel="noopener">电子原版目录以及概要</a></p><p>请购买实体书籍，支持作者、翻译以及出版社</p><h1 id="Creating-and-Destroying-Objects"><a href="#Creating-and-Destroying-Objects" class="headerlink" title="Creating and Destroying Objects"></a>Creating and Destroying Objects</h1><h2 id="用静态工厂方法代替构造器"><a href="#用静态工厂方法代替构造器" class="headerlink" title="用静态工厂方法代替构造器"></a>用静态工厂方法代替构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态工厂方法与设计模式中的工厂方法模式不同。并不能直接对应设计模式的工厂方法。</p><p><strong>优势</strong></p><ul><li>有名字（像这种<code>BigInteger.probablePrime(int bitLength,Random rnd)</code>）</li><li>不必每次调用他们的时候，都创建一个新对象。像<code>Integer.MAX_VALUE = 0x7fffffff</code>（享元<code>Flyweight</code>模式）真正的享元模式如下，<code>Integer</code>中有个私有静态类，叫<code>IntergeCache</code></li><li>可以返回原返回类型的任何子类型的对象。<code>Java8</code>允许接口中含有静态方法，<code>Java9</code>允许接口中有私有的静态方法，但是静态域和静态成员变量仍然需要是公有的。</li><li>所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。</li><li>方法返回的对象所属的类，在便携包含该静态工厂方法的类时可以不存在。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 这里定义了最大值，也就是说这个可以配置</span></span><br><span class="line"><span class="comment">         * -XX:AutoBoxCacheMax=NNN，这里的 NNN 表示最大值是多少，只能改最大值，不能改最小值。</span></span><br><span class="line"><span class="comment">         * 在设置了-XX:+AggressiveOpts启动参数后，AutoBoxCacheMax的默认值会被修改为20000并且生效。</span></span><br><span class="line"><span class="comment">         * 这里的 -XX:+AggressiveOpts 是表示加快编译</span></span><br><span class="line"><span class="comment">         * aggressive adj.好争斗的, 挑衅的, 侵略性的</span></span><br><span class="line"><span class="comment">         * export JAVA_OPTS="-Xms2048m -Xmx2048m"。</span></span><br><span class="line"><span class="comment">         * 合起来翻译 积极的选择</span></span><br><span class="line"><span class="comment">         * - Tired compilers (hoping that it will make it into JDK7)</span></span><br><span class="line"><span class="comment">         * - Scalar replacement (and I am still hoping that this will remove some of the memory throughput preassure 64-bit brought)</span></span><br><span class="line"><span class="comment">         * EA and stack allocation</span></span><br><span class="line"><span class="comment">         * Code cache</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>缺点</p><ul><li>类如果不含公有或者受保护的构造器，就不能被子类化</li><li>难发现它们</li></ul><p><code>BeanDefinitionBuiler</code> 就是将<code>静态工厂方法</code> 和 <code>构建器</code> 模式结合的案例。</p><h2 id="遇到多个构造器参数时要考虑使用构建器"><a href="#遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="遇到多个构造器参数时要考虑使用构建器"></a>遇到多个构造器参数时要考虑使用构建器</h2><ul><li><p><code>JavaBean</code>模式（不推荐，当然我觉得不包括 <code>POJO</code> 类）</p></li><li><p><code>Builder</code>模式（<code>lombok</code>提供了<code>@Builder</code>注解，可以偷懒，但是就不要注解了，可以在顶部菜单栏<code>Refactor</code>使用 <code>delomok</code>生成相应代码）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样例</span></span><br><span class="line"><span class="comment">// spring-beans 下。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionBuilder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AbstractBeanDefinition beanDefinition;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> constructorArgIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一般 BeanDefinitionBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinitionBuilder <span class="title">genericBeanDefinition</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = <span class="keyword">new</span> BeanDefinitionBuilder(<span class="keyword">new</span> GenericBeanDefinition());</span><br><span class="line">        builder.beanDefinition.setBeanClassName(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他相同类型方法.....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init-method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setInitMethodName</span><span class="params">(@Nullable String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setInitMethodName(methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detroy-method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setDestroyMethodName</span><span class="params">(@Nullable String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setDestroyMethodName(methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scope  defualt singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">setScope</span><span class="params">(@Nullable String scope)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.setScope(scope);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他类型方法....</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinition.validate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionAPI</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericBeanDefinition <span class="title">getGeneriBeanDefinition</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (GenericBeanDefinition)BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(<span class="string">"org.springframework.web.client.RestTemplate"</span>)</span><br><span class="line">            .setScope(<span class="string">"singleton"</span>)</span><br><span class="line">            .getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em style = "color:blue">如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是一种不错的选择</em></p><h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化<code>Singleton</code>属性</h2><p><em style="color:blue">如果要阻止反射实例化单例类，可以在被要求创建第二个实例的时候，抛出异常。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。</span></span><br><span class="line"><span class="comment">* 双检锁/双重校验锁（DCL，即 double-checked locking）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里检查是不是初始化过了</span></span><br><span class="line">        <span class="keyword">if</span>(singleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元素的枚举类型经常成为实现<code>Singleton</code>的最佳方法。当然如果<code>Singleton</code>必须扩展一个超类，而不是扩展<code>Enum</code>的时候，则不宜使用这个方法。</p><p>下面是 Spring Boot 2.0 引入的单例类。具体执行顺序如下 </p><p><code>SpringApplication#run --&gt; SpringApplication#prepareEnvironment --&gt; SpringApplication#configureEnvironment --&gt; ApplicationConversionService#getSharedInstance</code><br>也是使用 DCL 思想（我觉得应该从 Stackoverflow 上面复制的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConversionService</span> <span class="keyword">extends</span> <span class="title">FormattingConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ApplicationConversionService sharedInstance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ApplicationConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ApplicationConversionService</span><span class="params">(StringValueResolver embeddedValueResolver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (embeddedValueResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">         setEmbeddedValueResolver(embeddedValueResolver);</span><br><span class="line">      &#125;</span><br><span class="line">      configure(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return a shared default application &#123;<span class="doctag">@code</span> ConversionService&#125; instance, lazily</span></span><br><span class="line"><span class="comment">    * building it once needed.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Note: This method actually returns an &#123;<span class="doctag">@link</span> ApplicationConversionService&#125;</span></span><br><span class="line"><span class="comment">    * instance. However, the &#123;<span class="doctag">@code</span> ConversionService&#125; signature has been preserved for</span></span><br><span class="line"><span class="comment">    * binary compatibility.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the shared &#123;<span class="doctag">@code</span> ApplicationConversionService&#125; instance (never</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConversionService <span class="title">getSharedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">      <span class="keyword">if</span> (sharedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (ApplicationConversionService<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">            <span class="keyword">if</span> (sharedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               sharedInstance = <span class="keyword">new</span> ApplicationConversionService();</span><br><span class="line">               ApplicationConversionService.sharedInstance = sharedInstance;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sharedInstance;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 省略一大段代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><p>像这种工具类就私有构造器。使用 final 防止继承，使用私有构造器防止实例化（开安全后防止反射实例化）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DateUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如 spring.core 中的 String 工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WINDOWS_FOLDER_SEPARATOR = <span class="string">"\\"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOP_PATH = <span class="string">".."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CURRENT_PATH = <span class="string">"."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> EXTENSION_SEPARATOR = <span class="string">'.'</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先考虑依赖注入来引用资源"><a href="#优先考虑依赖注入来引用资源" class="headerlink" title="优先考虑依赖注入来引用资源"></a>优先考虑依赖注入来引用资源</h2><p><em>通过依赖注入而非手动 new 对象，降低类于类之间的耦合度。而且应该尽量是基于接口而非实现来注入，这样更适合*</em>经常变更的类*<em>，或者模块</em>。当然，不是 Service 都需要写接口，除非你真的很需要，例如 SOA 程序、微服务程序，需要提供给外部 SDK。像 Spring Cloud 所有模块，以及 Spring 所定义的所有抽象一样，定义了统一的接口，引用的都是接口，而非实现类，Spring 统一的 Caching 等接口也是如此。</p><p>静态工具类和<code>Singleton</code>类不适合于需要引用底层资源的类。</p><p>关于解耦，右侧有更多解释。<a href="https://www.infoq.cn/article/8hlh2qEWP1Y00qumdMQj" target="_blank" rel="noopener">细数软件架构中的解耦</a></p><p>集中化配置，根据服务动态解析 IP 也算是解耦的方式。</p><p><em style='color:blue'>当创建一个新的实例时，就将该资源传到构造器中</em></p><p>依赖注入（<code>Dependency Injection</code>）</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/11/uEgJFLlyzrk951m.png" alt="Spring IoC"></p><p>类似的内容，在进程间的 Broker 消息模式也有体现。</p><p>关于构造器注入好，还是 <code>Setter</code> 注入好，个人认为是前者好。<code>Spring</code>作者也推荐前者，因为这样能判断你是不是传了非空、非法的参数。</p><p>如果想更深入了解如何实现循环依赖，在构造器注入如何实现，可以看看 ObjectProvider，以及 Spring Boot MyBatis 的内容，那个比较简单。</p><p><code>Spring</code> 中单例的对象，并不一定是全局唯一的，它是 每个<code>ClassLoader</code> 中唯一的，<code>static</code> 对象也是。所以插件 Spring Dev Tool 让项目重启，只需要新的 ClassLoader 加载这些内容。这里有个小知识点，就是分级处理。和 JVM 的分代处理其实是差不多的，就是将部分不变的类用固定的 ClassLoader 加载，项目中可变的类用新的 ClassLoader 加载，这样就实现每次代码变更，不用全部重新加载的功能了。当然，这里是简化了实现细节，内部实现没有这么简单。</p><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><ol><li>字符串循环累加</li><li>包装类型循环累加</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DON'T DO THIS面试经常问到这个，傻瓜才会这么写</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"bikini"</span>);</span><br><span class="line"><span class="comment">//正确的写法</span></span><br><span class="line">String s = <span class="string">"bikini"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于是否是罗马数字的正则校验   这样做不合理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matche(<span class="string">"^(?=.)M&#123;1,3&#125;?(CM|C?D|D?C&#123;1,3&#125;)?(XC|XL|L|L?X&#123;1,3&#125;)?(IX|I?V|V?I&#123;1,3&#125;)?$"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然String.matches方法最易于查看一个字符串是否与正则表达式相匹配，但并不适合在注重性能的情形中重复使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(<span class="string">"^(?=.)M&#123;1,3&#125;?(CM|C?D|D?C&#123;1,3&#125;)?(XC|XL|L|L?X&#123;1,3&#125;)?(IX|I?V|V?I&#123;1,3&#125;)?$"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器是指这样一个对象：它把功能委托给一个后备的对象（<code>backing object</code>），从而为后备对象提供一个可以代替的接口。</p><p><code>WebMvcConfigurerAdapter</code>这是个适配器，一般用于配置<code>web</code>的一些配置，如拦截器<code>Interceptor</code>，<code>JSONformatter</code>等，不过在<code>Java8</code>出来接口中声明 <code>default</code> 方法后，这个类就被声明 <code>@Deprecated</code>。</p><p><strong>优先使用基础类型而不是装箱基本类型，要当心无意识的自动装箱</strong>。(当然，实际生产中，除非你用于科学计算，一般都用包装类，例如 long 和 Long，小写的 l 容易看成大写 i 避免歧义)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐下面的写法，会让系统无意义得创建很多Long类型对象。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>;i &lt;= Integer.MAX_VALUE; i++)&#123;</span><br><span class="line">        <span class="comment">//就算是一行代码，我也推荐加上大括号，语义清晰</span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        <span class="comment">// 把数组中对象置空，防止内存泄漏</span></span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存泄漏的另一个常见来源是缓存。用<code>WeakHashMap</code>代表缓存。只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，<code>WeakHashMap</code>才有用处。</p><p>第三个常见来源是监听器和其他回调。可以借助 <code>Heap</code> 剖析工具（<code>Heap Profiler</code>）发现内存泄漏问题。</p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/56214714" target="_blank" rel="noopener">ThreadLocal 是否存在内存泄漏问题，为什么？</a></p></li><li><p><a href="https://www.zhihu.com/org/a-li-yun-yun-qi-she-qu-48" target="_blank" rel="noopener">阿里云云栖号</a></p></li></ol><h2 id="避免使用finalizer方法，和Java9的cleaner方法"><a href="#避免使用finalizer方法，和Java9的cleaner方法" class="headerlink" title="避免使用finalizer方法，和Java9的cleaner方法"></a>避免使用<code>finalizer</code>方法，和<code>Java9</code>的<code>cleaner</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Clearner cleaner = Cleaner.create();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numJunkPiles;</span><br><span class="line">        State(<span class="keyword">int</span> numJunkPiles)&#123;</span><br><span class="line">            <span class="keyword">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Cleaning room"</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">int</span> numJunkPiles)</span></span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> State(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="keyword">this</span>,state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-with-resources-优先于-try-finally"><a href="#try-with-resources-优先于-try-finally" class="headerlink" title="try with resources 优先于 try finally"></a>try with resources 优先于 try finally</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path,String defualtVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path)))&#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// dual 表只在 Mysql 是默认有的，Oracle 查不到的</span></span><br><span class="line">        pst = conn.prepareStatement(<span class="string">"SELECT 1 FROM dual"</span>);</span><br><span class="line">        pst.execute();</span><br><span class="line">        rs = pst.getResultSet();</span><br><span class="line">        rs.getInt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 老程序猿是这样教的，当然实际生产中不要这么写，尽量细化异常，让不同异常，做不同的事</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pst != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pst.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 这里的 logger 是 Slf4j 获取的 Logger</span></span><br><span class="line">            logger.error(getStackTraceAsString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getStackTraceAsString</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">    e.printStackTrace(<span class="keyword">new</span> PrintWriter(stringWriter));</span><br><span class="line">    <span class="keyword">return</span> stringWriter.toString()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.7引入的语法糖，让代码更简洁</span></span><br><span class="line"><span class="comment">// try with resource 相当于默认加了finally块，并且默认添加 finally 块，其中调用实现了 AutoCloseable 接口的 close 方法</span></span><br><span class="line"><span class="comment">// AtuoCloseable 接口自 1.7 引入，让 Closeable 继承，而 Closeable @since 1.5</span></span><br><span class="line"><span class="comment">// InputStream &amp; OutputStream 都实现了 Closeable接口</span></span><br></pre></td></tr></table></figure><h1 id="Methods-Common-to-All-Objects"><a href="#Methods-Common-to-All-Objects" class="headerlink" title="Methods Common to All Objects"></a>Methods Common to All Objects</h1><h2 id="什么时候应该覆盖equals方法？"><a href="#什么时候应该覆盖equals方法？" class="headerlink" title="什么时候应该覆盖equals方法？"></a>什么时候应该覆盖<code>equals</code>方法？</h2><p>如果类具有自己特有的“逻辑相等”（<code>logical equality</code>）概念，而且超类还没有<code>equals</code>。这通常属于”值类“（<code>Value class</code>），值类仅仅是表示一个表示值的类，例如<code>Integer</code>或<code>String</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String foo = <span class="keyword">new</span> String(<span class="string">"str"</span>);</span><br><span class="line">String bar = <span class="keyword">new</span> String(<span class="string">"str"</span>);</span><br><span class="line">foo.equals(bar);<span class="comment">// true 比较的是对象内容，String重写了Object的equals方法</span></span><br><span class="line">foo == bar ;<span class="comment">// false 比较内存地址，只要内存地址为true，就一定是一样的对象</span></span><br><span class="line"><span class="comment">// 还有ons-client（RocketMQ的Java client） Subscription 订阅类，覆盖了equals方法，比较的是topic，只要topic相等，这个类就相等(dump)，但是他要根据不同 tag 获取不同消息内容，比如删除 人员信息的tag和新增人员信息的 tag 不一样。搞得我以不同 tag 为基础设置类，配置半天找不到问题。</span></span><br></pre></td></tr></table></figure><p><em style='color:blue'>equals方法实现了等价关系（<code>equivalence relation</code>）</em></p><p>放心，在《算法》Java 版本的这本书上也有介绍，这只是个基本的概念而已。</p><p>– 所有前提是 对于任何非<code>null</code>的引用值<code>x</code></p><ul><li>自反性（<code>reflexive</code>）：<code>x.equals(x)</code>必须为<code>true</code></li><li>对称性（<code>symmetric</code>）：如果x.equals(y)==true，必定y.equals(x);前提是两个非null</li><li>传递性（<code>transitive</code>）：<code>x.equals(y)==true</code>,<code>y.equals(z)==true</code>,<code>z.equals(x)==true</code>;</li><li>一致性（<code>consistent</code>）：当<code>x.equals(y)==true</code>时，只要在比较操作在对象中所用的信息没有被修改，多次调用，都是<code>true</code>。</li><li>任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(null)==true;</code></li></ul><p>里氏替换原则（<code>Liskov substitution principle</code>）认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoValueMoney</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getCurrency</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getAmount</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutoValueMoney <span class="title">create</span><span class="params">(String currency, <span class="keyword">long</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoValue_AutoValueMoney(currency, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoValue_AutoValueMoney</span> <span class="keyword">extends</span> <span class="title">AutoValueMoney</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String currency;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> amount;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    AutoValue_AutoValueMoney(String currency, <span class="keyword">long</span> amount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currency == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(currency);</span><br><span class="line">        <span class="keyword">this</span>.currency = currency;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        h *= <span class="number">1000003</span>;</span><br><span class="line">        h ^= currency.hashCode();</span><br><span class="line">        h *= <span class="number">1000003</span>;</span><br><span class="line">        h ^= amount;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> AutoValueMoney) &#123;</span><br><span class="line">            AutoValueMoney that = (AutoValueMoney) o;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.currency.equals(that.getCurrency()))</span><br><span class="line">              &amp;&amp; (<span class="keyword">this</span>.amount == that.getAmount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenValueTypeWithAutoValue_whenFieldsCorrectlySet_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoValueMoney m = AutoValueMoney.create(<span class="string">"USD"</span>, <span class="number">10000</span>);</span><br><span class="line">    assertEquals(m.getAmount(), <span class="number">10000</span>);</span><br><span class="line">    assertEquals(m.getCurrency(), <span class="string">"USD"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="覆盖-equals-时总要覆盖-hashCode"><a href="#覆盖-equals-时总要覆盖-hashCode" class="headerlink" title="覆盖 equals 时总要覆盖 hashCode"></a>覆盖 equals 时总要覆盖 hashCode</h2><ul><li>在应用程序的执行期间，只要对象的<code>equals</code>方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，<code>hashCode</code>方法必须始终放回同一个值。在一个应用程序与另一个程序的执行过程中，执行hashCode方法所返回的值可以不一致。</li><li>两个对象<code>equals</code>调用相等，<code>hashCode</code>一定相等</li><li>两个对象<code>equals</code>调用不相等，<code>hashCode</code>可以一样。例如<code>String</code>的<code>hashCode</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选31*每个h值+每个char的值</span></span><br></pre></td></tr></table></figure><p>这是 <code>HashMap</code> 的实际的<code>put</code> 方法，里面通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果你是 new HashMap()创建的对象，默认这里的 resize() 大小是 16，DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 //aka 16 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">// 第一次创建 HashMap，如果没有特殊处理，这里的 table 为 null</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//也就是这里的 n = 16</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">// 与 &amp; 操作两个操作数中位都为1，结果才为1，否则结果为0</span></span><br><span class="line">        <span class="comment">// 这里是判断 tab[i] 数组上有没有对象，没有直接存，跳过下面 else 复杂的步骤</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">// 这里就用到 equals 来判断了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h2><p>下面是<code>Spring</code>中的抽象<code>Bean</code>定义类重写的<code>hashCode()</code>和<code>toString()</code>方法，重写<code>toString()</code>让我们能更好的<code>debug</code>以及了解这个类属性。<code>String</code>的<code>hashCode</code>是以31为优选乘子，选择相邻的质数也是<code>ok</code>的，但是<code>31 = (2&lt;&lt;5) -1</code> ,可以被<code>JVM</code>优化。</p><div class="note danger">            <p>不建议用 <code>Lombok</code>以及<code>AutoValue</code> 。代码是简洁了，维护起来很麻烦。</p>          </div><ul><li>你使用了这些插件，你的组员也要用，如果你在内网开发，其他人没有这个插件，完全是个灾难。</li><li>代码是整洁了，但是维护起来很麻烦，不要图一时之快。</li></ul><p>当然你要用，要注意用<code>@Slf4j</code>，而不是<code>@Log4j</code>，<code>SpringBoot</code>默认使用<code>Logback</code>，你指定了<code>Log4j</code>，就会有冲突，你换成其他日志输出框架，那就有问题。<code>Slf4j</code>有桥接包，屏蔽了这些内容，让你可以<code>LoggerFactory.getLogger(xxx.class)</code>，而不用明确指定是哪个日志输出框架。</p><p>那<code>Spring</code> 和其他框架是怎么输出日志的呢，就是用 <code>apache.logging</code>包下的<code>protected final org.apache.commons.logging.Log logger = org.apache.commons.logging.LogFactory.LogFactory.getLog(this.getClass());</code>里面的<code>getLog</code>方法，再来了<code>LogAdpter.createLog()</code>这个 <code>LogAdpter</code>里面就是去找<code>slf4j</code>或者<code>log4j</code>内容，当然你用<code>Spring Boot</code>默认的 <code>logback</code>就用<code>Slf4j</code>再来个桥接包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_SPI = <span class="string">"org.apache.logging.log4j.spi.ExtendedLogger"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_SLF4J_PROVIDER = <span class="string">"org.apache.logging.slf4j.SLF4JProvider"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SLF4J_SPI = <span class="string">"org.slf4j.spi.LocationAwareLogger"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SLF4J_API = <span class="string">"org.slf4j.Logger"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LogAdapter.LogApi logApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LogAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是解析 <code>Spring</code> 中<code>AbstractBeanDefinition</code> 的 <code>toString()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.getBeanClassName());</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.scope);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.constructorArgumentValues);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.propertyValues);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.factoryBeanName);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.factoryMethodName);</span><br><span class="line">        hashCode = <span class="number">29</span> * hashCode + <span class="keyword">super</span>.hashCode();</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"class ["</span>);</span><br><span class="line">        sb.append(<span class="keyword">this</span>.getBeanClassName()).append(<span class="string">"]"</span>);</span><br><span class="line">        sb.append(<span class="string">"; scope="</span>).append(<span class="keyword">this</span>.scope);</span><br><span class="line">        sb.append(<span class="string">"; abstract="</span>).append(<span class="keyword">this</span>.abstractFlag);</span><br><span class="line">        sb.append(<span class="string">"; lazyInit="</span>).append(<span class="keyword">this</span>.lazyInit);</span><br><span class="line">        sb.append(<span class="string">"; autowireMode="</span>).append(<span class="keyword">this</span>.autowireMode);</span><br><span class="line">        sb.append(<span class="string">"; dependencyCheck="</span>).append(<span class="keyword">this</span>.dependencyCheck);</span><br><span class="line">        sb.append(<span class="string">"; autowireCandidate="</span>).append(<span class="keyword">this</span>.autowireCandidate);</span><br><span class="line">        sb.append(<span class="string">"; primary="</span>).append(<span class="keyword">this</span>.primary);</span><br><span class="line">        sb.append(<span class="string">"; factoryBeanName="</span>).append(<span class="keyword">this</span>.factoryBeanName);</span><br><span class="line">        sb.append(<span class="string">"; factoryMethodName="</span>).append(<span class="keyword">this</span>.factoryMethodName);</span><br><span class="line">        sb.append(<span class="string">"; initMethodName="</span>).append(<span class="keyword">this</span>.initMethodName);</span><br><span class="line">        sb.append(<span class="string">"; destroyMethodName="</span>).append(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"; defined in "</span>).append(<span class="keyword">this</span>.resource.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨慎地覆盖-clone"><a href="#谨慎地覆盖-clone" class="headerlink" title="谨慎地覆盖 clone"></a>谨慎地覆盖 clone</h2><p><strong>不可变的类永远都不应该提供<code>clone</code>方法</strong></p><p>实际上<code>clone</code>方法就是另一个构造器，必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件（<code>invariant</code>）。</p><p><code>Cloneable</code>架构与引用可变对象的final域的正常用法是不相兼容的。</p><p><code>HashMap.Entry</code>被加强了，它支持一个“深拷贝”<code>deepCopy()</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/K0_FBX6pRJ-seUGKVqrY-w" target="_blank" rel="noopener">什么是深拷贝，什么是浅拷贝</a></p><p><code>Java Shallow clone</code></p><p><strong>Shallow clone</strong> is  default implementation  in Java. In overridden <code>clone</code> method, if you are not cloning all the object types (not primitives（原生类型）, then you are making a shallow copy.</p><p><code>Java Deep Copy</code></p><p>In the deep copy, we create a clone which is independent of original object and making changes in the cloned object should not affect original object.</p><h2 id="考虑实现-Comparable-接口"><a href="#考虑实现-Comparable-接口" class="headerlink" title="考虑实现 Comparable 接口"></a>考虑实现 Comparable 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值规范</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this &lt; t &#x3D;&gt; -1，</span><br><span class="line"></span><br><span class="line">this &#x3D;&#x3D; t &#x3D;&gt; 0;</span><br><span class="line"></span><br><span class="line">this &gt; t &#x3D;&gt; 1;</span><br></pre></td></tr></table></figure><p>遵循下面几个规范</p><ul><li>sgn(x.compareTo(y)) == -sgn(y.compareTo(x));  类似1 == -(-1)</li><li>传递性，a&gt;b,b&gt;c     =&gt;   a&gt;c</li><li>如果x.compareTo(y) ==0，sgn(x.compareTo(z)) == sgn(y.compareTo(z))。a==b,a.f(c) == b.f(c)</li></ul><p>强烈建议<code>x 比 y == 0</code>，<code>x.equals(y) =&gt; true</code>,若违反了这个条件，都应该明确说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal foo = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal bar = <span class="keyword">new</span> BigDecimal(<span class="string">"1.00"</span>);</span><br><span class="line">foo.equals(bar);<span class="comment">//false</span></span><br><span class="line">foo.compareTo(bar);<span class="comment">// 0值相等</span></span><br></pre></td></tr></table></figure><p><em style="color:blue">在ocmpareTo方法中使用关系操作符 &lt; 和 &gt; 是非常繁琐的，而且容易出错，因此不建议使用</em></p><p>HashSet 会两个都存，TreeSet 只会存一个，因为利用了compareTo() 方法。<br>实现 Comparable 接口，有助于在有序集合中更好的排序。</p><h1 id="Classes-and-Interfaces"><a href="#Classes-and-Interfaces" class="headerlink" title="Classes and Interfaces"></a>Classes and Interfaces</h1><h2 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h2><p>区分一个组件设计得好不好，唯一重要的因素在于，它对外部的其他组件而言，是否隐藏了其内部数据和其他实现细节。设计良好的组件会隐藏所有的实现细节，把<code>API</code>与实现清晰地隔离开来。然后组件之间通过<code>API</code>通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏（<code>information hiding</code>）/封装（<code>encapsulation</code>），是软件设计的基本原则之一。</p><p>例如<code>Spring Boot 2.0</code>后的版本的<code>Spring Boot</code>，直接在<code>https://start.spring.io</code>直接生成就完事了，不像以前写一个<code>Web</code>应用先要<code>Servlet</code> 容器（<code>Tomcat/Jetty/Weblogic</code>等），再实现<code>javax.servlet.http.HttpServlet</code>重写它的<code>doGet/doPost</code>方法，甚至是<code>service</code>方法（不建议这么做，有关内容自己谷歌 <code>Http Code 304</code>），然后在 <code>web.xml</code>文件中添加这么一坨东西。</p><div class="tabs" id="content-1"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-1-1">Java代码部分</button></li><li class="tab"><button data-href="#content-1-2">web.xml部分</button></li><li class="tab"><button data-href="#content-1-3">有关 304 在HttpServlet及Servlet容器的实现</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import required java libraries</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend HttpServlet class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String message = <span class="string">"Hello World"</span>;</span><br><span class="line">        <span class="comment">// Set response content type</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        <span class="comment">// Actual logic goes here.</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>me.young1lin.HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloWorld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-1-3"><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/09/1cwSl6KMXNrVtY7.png" alt="Http Code 304.png"></p><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><p><a href="https://www.tutorialspoint.com/servlets/servlets-first-example.htm" target="_blank" rel="noopener">引用</a></p><p>当然这些东西不算完，还要放进<code>Servlet</code>容器中启动，最终返回信息。</p><p>而<code>Spring Boot</code>只需要简单几行代码的配置，就能启动一个<code>web</code>应用。</p><p>信息隐藏之所以重要，是因为</p><ol><li>有效地解除组成系统的各组件之间的耦合关系，即解耦（<code>decouple</code>），使得这些组件可以独立地开发、测试、优化、使用、理解和修改。</li><li>同时减轻了维护的负担。</li><li>隐藏实现，就可以使代码组件化，如果因为哪个组件性能差，就可以单独对这个组件进行优化。</li></ol><div class="note info">            <p>尽可能地使每个类或者成员不被外界访问</p>          </div><p>并且一个包级私有的顶层类（或者接口）只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个累的私有嵌套类（内部类）。像下面这样</p><div class="tabs" id="content-2"><ul class="nav-tabs"><li class="tab active"><button data-href="#content-2-1">HashMap Node部分</button></li><li class="tab"><button data-href="#content-2-2">ArrayList 迭代器部分</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="content-2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....省略一大段代码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="content-2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;    </span><br><span class="line">          <span class="comment">// ......省略一大段代码</span></span><br><span class="line">      <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div><p>公有类的实例域决不能是公有的，包含公有可变域的类通常并不是线程安全的。</p><p>虽然 ClassPathXmlApplicationContext 封装做的很好，但是学习起来比较费劲。</p><h2 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h2><p>善用<code>final</code>、加上<code>final</code>的静态工厂，享元模式。<code>BigDecimal.ZERO</code>，<code>Integer</code>的自动拆装箱里面的<code>CacheInteger</code>类。</p><h2 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h2><p>我觉得更优的翻译应该叫组合优于继承。当然，不是所有情况下都要用组合。《UNIX 编程艺术》中也提到，善用组合。</p><p>下面是 <code>Spring</code> 基石 <code>GenericApplicationContext</code> 中的源码，其中 <code>DefaultListableBeanFactory</code> 才是真正的容器。这个叫组合模式，两者都实现了同一个接口（<code>BeanFactory</code>），这里的 <code>DefaultListableBeanFactory</code> 可以是一个至多个，然后依次调用，直到返回结果为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略一大段代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .....省略一段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用内含的方式实现，例如<code>JFinal</code>中的<code>Record</code>对象，内含了一个<code>HashMap</code>对象，来实现一些操作。万物(单条数据)皆为<code>Record</code>。</p><p>Spring 中 ApplicationContext 类型的对象就是内涵了个 BeanFactory，其实就是 DefaultListableBeanFactory，也就是所谓的 IoC （Inversion of Control）容器。</p><h2 id="要么设计继承并提供文档说明，要么禁止继承"><a href="#要么设计继承并提供文档说明，要么禁止继承" class="headerlink" title="要么设计继承并提供文档说明，要么禁止继承"></a>要么设计继承并提供文档说明，要么禁止继承</h2><p>类必须精心挑选的受保护的（<code>protected</code>）方法，提供适当的钩子（<code>hook</code>），一边进入其内部工作中。</p><p>因为要符合里氏替换原则，之后开发的人，并不清楚你现在的类是什么意思。</p><h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><p>类是单继承，接口可以多实现，多接口可以实现不同业务需求，由于<code>1.8</code>后可以用<code>default</code>修饰接口方法，实现和抽象类一样的效果，又可以有实体方法，又有待子类实现的抽象方法。</p><p>Netty 中的 ChannelInboundHandler 就是个很好的例子。</p><p>多个接口方法同名，实现类报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">// 这样会报错，不知道你到底要返回什么类型，但是把B的void改成int，就不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口是高度抽象的结果，而抽象类</p><h2 id="为后代设计接口"><a href="#为后代设计接口" class="headerlink" title="为后代设计接口"></a>为后代设计接口</h2><p>慎用 default 去修饰接口方法</p><p>BeanFactory 接口定义了最基本的容器功能。</p><h2 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h2><p>常量接口模式是对接口的不良使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XXXConstants</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MY_CONSTANTS = <span class="string">"my constants    "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.io.ObjectStreamConstants</code> 是个反例</p><p>如果要去定义常量</p><ol><li><p>要么在类内部定义，想 <code>Integer.MAX_VALUE</code>，<code>BigDecimal.ZERO</code>等等</p></li><li><p>要么用枚举实现，像我自定义的状态信息</p></li></ol><p>接口应该用来定义类型。</p><h2 id="类层次优先于标签类"><a href="#类层次优先于标签类" class="headerlink" title="类层次优先于标签类"></a>类层次优先于标签类</h2><p>字面意思。</p><p>像这种 <code>AbstractApplicationContext</code> 继承自 <code>DefaultResourceLoader</code>，拥有了资源加载的能力，像 EventObject 这种就是标记类，你可以加上，也可以不加，但是这是约定俗称的事件对象的类。</p><p>著名的标签接口（tagging interface）<code>java.util.EventListener</code>、<code>java.lang.Serializable</code>。注意这里是接口，平常项目开发也是会自己定义标记接口的，里面没有任何方法（行为），仅起到标记作用。这个是约定俗称的内容，你不遵守，等待的就是报错（例如 Java 序列化没有实现 Serializable 接口，就会报错）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A tagging interface that all event listener interfaces must extend.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态成员类优先于非静态成员类"><a href="#静态成员类优先于非静态成员类" class="headerlink" title="静态成员类优先于非静态成员类"></a>静态成员类优先于非静态成员类</h2><p><code>Builder</code></p><p><code>Map.Entry</code></p><h2 id="限制源文件为单个顶级类-public-修饰与文件名相同的类"><a href="#限制源文件为单个顶级类-public-修饰与文件名相同的类" class="headerlink" title="限制源文件为单个顶级类(public 修饰与文件名相同的类)"></a>限制源文件为单个顶级类(<code>public</code> 修饰与文件名相同的类)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pan"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"cake"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个不同文件，public 修饰的 class 为该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"bar"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(A.NAME+B.NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样有歧义，编译不给过，分开存。如果一定要放一起，就放在顶级类内部做静态成员类。</p><h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p>翻译版本有误，<code>SINCE Java 5, generics have been a part of the language</code>. 翻译版本少了个 s 变成了 generic。因为 Think in Java 英文版中， generics 才是代表泛型。</p><h2 id="不要使用原生态类型"><a href="#不要使用原生态类型" class="headerlink" title="不要使用原生态类型"></a>不要使用原生态类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 别这样使用，报黄线是结果，原因是没有确定类型，那么就是任何类型都可以存入，如果存错了东西，取出来强制转换的时候，会报错。编译时给不了提示。</span></span><br><span class="line">List apples = <span class="keyword">new</span> ArrayList(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该这样用，编译器就会告诉你哪里出问题</span></span><br><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">apples.add(<span class="keyword">new</span> Banana());</span><br><span class="line"><span class="comment">//如果 Banana不是继承 Apple，就会报错</span></span><br></pre></td></tr></table></figure><p><code>List</code> 和 <code>List&lt;Object&gt;</code> 是有区别的，后者明确告诉该容器接受所有任意类型对象。</p><p>必须在类文字（<code>class literal</code>）中使用原生态类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="消除非受检的警告"><a href="#消除非受检的警告" class="headerlink" title="消除非受检的警告"></a>消除非受检的警告</h2><p><code>/uncheck/</code></p><p>⬆️尽量不要编译后出现这个（其实就是<code>@SuppreWarnings(&quot;unchecked&quot;)</code>），除非可以证明引起警告的代码是类型安全的，用 /uncheck/ 或者 <code>@SuppreWarnings(&quot;unchecked&quot;)</code>来禁止警告。尽可能在小的范围使用这个注解，像 <code>synchronized</code> 以及<code>catch Exception</code> 一样，尽可能精准，细粒度去做。这样好调试啊。</p><p>书上讲的 <code>ArrayList.toArray(T[] a)</code>方法，在 <code>JDK1.8</code> 中，源码是把去警告的注解放在方法上的，和他推荐的不一样。当然还是按照作者推荐的，这样让后人更容易懂你写的代码，尽量别写出祖传代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h2><p>除非写游戏类的，用二维数组表示坐标什么的，科学计算用基础类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译不报错，运行报错</span></span><br><span class="line">Object[] o = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"str"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">List&lt;Object&gt; o2 = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br><span class="line">ol.add(<span class="string">"str"</span>);</span><br></pre></td></tr></table></figure><p>范型数组不存在，编译不通过。</p><p>列表帮你做好了动态扩容，类型转换等操作。</p><h2 id="优先考虑范型"><a href="#优先考虑范型" class="headerlink" title="优先考虑范型"></a>优先考虑范型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前写 BaseDao 这种类时写的反射方法，也是 ORM 框架中会用到的方法。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="优先考虑范型方法-⬆️"><a href="#优先考虑范型方法-⬆️" class="headerlink" title="优先考虑范型方法 ⬆️"></a>优先考虑范型方法 ⬆️</h2><p>像上面这种</p><p>善用通配符，<code>E Element</code>，<code>T type</code>表示具体的类型，<code>K V key Value</code>，？ 不确定什么类型</p><p><code>JDK1.7</code>引入<code>@SafeVarargs</code> 放在方法上，消除使用范型方法警告</p><h2 id="利用有限制通配符来提升-API-的灵活性"><a href="#利用有限制通配符来提升-API-的灵活性" class="headerlink" title="利用有限制通配符来提升 API 的灵活性"></a>利用有限制通配符来提升 <code>API</code> 的灵活性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T extends Record&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContainAnnotation</span><span class="params">(Object target,Class&lt;? extends Annotation&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == target.getClass().getAnnotation(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨慎使用并用范型和可变参数"><a href="#谨慎使用并用范型和可变参数" class="headerlink" title="谨慎使用并用范型和可变参数"></a>谨慎使用并用范型和可变参数</h2><p>《阿里巴巴 Java 开发规范》中也明确指出了，少用甚至不用可变参数，这是个语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;String&gt;...  stringLists)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">// 这样一起用，就要谨慎了。不安全，当遇到不同类型转换时，编译器不能把你的错误给指出来。</span></span></span><br></pre></td></tr></table></figure><p>如果真的方法是安全的，对于每一个带有范型可变参数或者参数化类型的方法，都要用<code>@SafeVarargs</code>进行注解.</p><h2 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h2><p>以前写的手动分页的类。,<code>List&lt;E&gt; Set&lt;E&gt; Map&lt;K,V&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size；</span><br><span class="line">  <span class="keyword">private</span> E[] list;</span><br><span class="line"> <span class="comment">//.... getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Enums-and-Annotations"><a href="#Enums-and-Annotations" class="headerlink" title="Enums and Annotations"></a>Enums and Annotations</h1><h2 id="用-enum-代替-int-常量"><a href="#用-enum-代替-int-常量" class="headerlink" title="用 enum 代替 int 常量"></a>用 enum 代替 int 常量</h2><p> <code>Java</code> 的枚举本质上是<code>int</code> 值。<code>《深入理解 Java 虚拟机》</code>介绍了枚举类其实是隐式继承了 <code>java.lang.Enum</code>这个类，所以枚举不能继承其他类，只能实现接口。</p><p>Java enums can extend <strong>java.lang.Enum</strong> class <strong>implicitly</strong>（隐含的）, so enum types cannot extend another class.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeThingStatus</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用枚举替代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Status&#123;</span><br><span class="line">    Y,N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据枚举所作用的范围，尽可能贴合实际使用范围来定义枚举类该在类私有/包级私有/顶层类（<code>top-level class</code>）/顶层类的成员类。</p><p>策略模式枚举</p><p><code>trategy enum</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PayrollDay&#123;</span><br><span class="line">    MONDAY,TUESEDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY(PayType.WEEKEND),SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType paytype)&#123;<span class="keyword">this</span>.payType = payType;&#125;</span><br><span class="line"></span><br><span class="line">    PayrollDay()&#123;<span class="keyword">return</span> <span class="keyword">this</span>(PayType.WEEKDAY);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span> <span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> PayType&#123;</span><br><span class="line">        WEEKDAY&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minisWorked &lt;= MINIS_PER_SHIT ? <span class="number">0</span> : (minsWorked - NINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minsWorked * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> mins,<span class="keyword">int</span> payRate)</span></span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> basePay = minsWorked * payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当需要一组固定的常量，并且在编译时就知道其成员的时候，就应该使用枚举。如菜单的选项、操作代码以及命令行标记等。</p><p>策略模式 如 <code>org.springframework.core.io.Resource</code></p><ul><li><strong>UrlResource：</strong>访问网络资源的实现类。</li><li><strong>ClassPathResource：</strong>访问类加载路径里资源的实现类。</li><li><strong>FileSystemResource：</strong>访问文件系统里资源的实现类。</li><li><strong>ServletContextResource：</strong>访问相对于 ServletContext 路径里的资源的实现类.</li><li><strong>InputStreamResource：</strong>访问输入流资源的实现类。</li><li><strong>ByteArrayResource：</strong>访问字节数组资源的实现类。</li></ul><p>责任链模式，例如 Handler Interceptor，Filter 。如下所示：</p><p>DispatcherServlet 中的 service 方法，经过一些校验和一些参数设置，最终会调用这个方法，如果你懂了这个方法，Spring MVC 一般的情况都能 Hold 住了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">            Object dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = processedRequest != request;</span><br><span class="line">                <span class="comment">// HandlerMapping 会在系统启动的时候，把所有的 RequestMapping 相关的方法封装成 MethodHadler，注入进来</span></span><br><span class="line">                <span class="comment">// 先从 HandlerMapping 中获取对应的 Handler</span></span><br><span class="line">                mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                String method = request.getMethod();</span><br><span class="line">                <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">                <span class="comment">// 做一些优化，304 方面的。看文件没有没改动过，没有就直接返回请求。</span></span><br><span class="line">                <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// mapperHandler，执行 preHandle 方法。对应 Interceptor preHandle 的方法</span></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                <span class="comment">// 对应 Intercaptor 的 postHandler 方法。</span></span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                dispatchException = var20;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, var21);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, var23));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用实例域代替序数（表示次序的数目）"><a href="#用实例域代替序数（表示次序的数目）" class="headerlink" title="用实例域代替序数（表示次序的数目）"></a>用实例域代替序数（表示次序的数目）</h2><p>实例域 <code>ONE(1),TWO(2)</code></p><h2 id="用-EnumSet-代替位域"><a href="#用-EnumSet-代替位域" class="headerlink" title="用 EnumSet 代替位域"></a>用 EnumSet 代替位域</h2><p>让你用 <code>OR</code> 位运算将几个常量合并到一个集合中，称作位域（<code>bit field</code>）</p><p><code>Set set = EnumSet.of(ONE,TWO);</code></p><h2 id="用-EnumMap-代替序数索引"><a href="#用-EnumMap-代替序数索引" class="headerlink" title="用 EnumMap 代替序数索引"></a>用 EnumMap 代替序数索引</h2><p>麻烦，平时用不到</p><h2 id="用接口模拟可扩展的枚举"><a href="#用接口模拟可扩展的枚举" class="headerlink" title="用接口模拟可扩展的枚举"></a>用接口模拟可扩展的枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(String operation)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SubFoo implements Foo&#123;</span><br><span class="line">    A(<span class="string">"a"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String operation)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"a"</span>+operation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    B(<span class="string">"b"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String operation)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"b"</span>+operation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    SubFoo(String s)&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">boolean</span> <span class="title">updateUser</span>(<span class="title">User</span> <span class="title">user</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.updateUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ApiReturnObject</span> <span class="title">defaultExceptionHandler</span>(<span class="title">BindException</span> <span class="title">bindException</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理返回的错误信息</span></span><br><span class="line">    List&lt;ObjectError&gt; errors = bindException.getBindingResult().getAllErrors();</span><br><span class="line">    <span class="keyword">if</span>(errors.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ObjectError objectError = errors.get(<span class="number">0</span>);</span><br><span class="line">        ResultCode resultCode = ResultCode.FAILURE.setMessage(objectError.getDefaultMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiReturnUtil.failure(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ApiReturnUtil.failure(ResultCode.SYSTEM_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坚持使用-Override-注解"><a href="#坚持使用-Override-注解" class="headerlink" title="坚持使用 @Override 注解"></a>坚持使用 @Override 注解</h2><p>保证写的代码，在编译时能检查得出来到底有没有重写 父类/接口 的方法。</p><h2 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h2><p>Spring 中的所有事件，默认继承 EventObject 这个也算是“接口”，一个不成文的规定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在使用 ObjectOutputstream 时，如果没有实现 Serializable 接口会报错，仅仅是个标记接口</span></span><br><span class="line"><span class="comment">* 在 writeObject0(Object obj, boolean unshared)中，显示的标注了，非 instance of Serializable 实现，将会抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="comment">// 防止被序列化，当然实现了某个接口，还是设置一下，还是会被序列化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> BigDecimal salary;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记注解</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Compment</span></span><br></pre></td></tr></table></figure><h1 id="Lambdas-and-Streams"><a href="#Lambdas-and-Streams" class="headerlink" title="Lambdas and Streams"></a>Lambdas and Streams</h1><h2 id="Lambda-优先于匿名类"><a href="#Lambda-优先于匿名类" class="headerlink" title="Lambda 优先于匿名类"></a>Lambda 优先于匿名类</h2><p>接口只有一个待实现方法时，可以转换成<code>Lambda</code> 写法。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SayHelloInterface</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span></span>&#123;</span><br><span class="line">    SayHelloInterface hello = () -&gt; <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有 <code>Comparable&lt;T&gt;</code>就是很好用 Lambda 写法的例子，而不是用匿名类去写。</p><p>如果 Lambda 没有名称和文档，并且有很多行，那就不要用。</p><h2 id="方法引用优先于-Lambda"><a href="#方法引用优先于-Lambda" class="headerlink" title="方法引用优先于 Lambda"></a>方法引用优先于 Lambda</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out::println</span><br><span class="line">Integer::parseInt</span><br></pre></td></tr></table></figure><p>方法引用详情见 《Java 8 实战》</p><h2 id="坚持使用标准的函数接口"><a href="#坚持使用标准的函数接口" class="headerlink" title="坚持使用标准的函数接口"></a>坚持使用标准的函数接口</h2><table><thead><tr><th align="center">接口</th><th align="center">函数签名</th><th align="center">范例</th></tr></thead><tbody><tr><td align="center">UnaryOperator<T></td><td align="center">T apply(T t)</td><td align="center">String::toLowerCase</td></tr><tr><td align="center">BinaryOperator<T></td><td align="center">T apply(T t1,T t2)</td><td align="center">BigInteger::add</td></tr><tr><td align="center">Predicate<T></td><td align="center">boolean test(T t)</td><td align="center">Collection::isEmpty</td></tr><tr><td align="center">Function&lt;T,R&gt;</td><td align="center">R apply(T t)</td><td align="center">Arrays::asList</td></tr><tr><td align="center">Supplier<T></td><td align="center">T get()</td><td align="center">Instant::now</td></tr><tr><td align="center">Consumer<T></td><td align="center">void accept(T t)</td><td align="center">System.out::println,Iterable<T>::forEach</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 Supplier 其实是下面的更简化版。</span></span><br><span class="line">Supplier&lt;Instant&gt; supplier = () -&gt; (Instant.now());</span><br></pre></td></tr></table></figure><p><code>@FunctionalInterface</code></p><p>这个注解有三个目的，</p><ol><li>告诉这个类及其文档的读者，这个接口是针对 Lambda 设计的。</li><li>这个接口不会进行编译，除非它只有一个抽象方法</li><li>避免后续维护人员不小心给该接口添加抽象方法</li></ol><p>必须使用这个注解对自己编写的函数接口进行标注。</p><h2 id="谨慎使用-Stream"><a href="#谨慎使用-Stream" class="headerlink" title="谨慎使用 Stream"></a>谨慎使用 Stream</h2><p>不建议使用 Stream 来进行 SQL 查询之类的操作。</p><p>过度地使用函数式编程，会导致代码可读性变差，强调不要滥用</p><h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><h2 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法尽量是个动词，方法是行为/动作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(String str,Collection collection,Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(str))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是 apache common 包下的工具类，hutool 也有类似的类</span></span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(collection))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    Objects.requireNonNull(obj,<span class="string">"obj is null"</span>);</span><br><span class="line">    <span class="comment">// 其他操作....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在违背导出的方法，使用断言，确保什么时候能够调用这个方法</span></span><br><span class="line">    <span class="keyword">assert</span> str.length = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><p>对于参数类型可以被不可信任方子类化的参数，请不要使用 clone 方法进行保护性拷贝。</p><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><p>代码整洁之道</p><p>对于参数类型，优先使用接口而不是具体实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Modify the application context's internal bean definition registry after its</span></span><br><span class="line"><span class="comment">    * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">    * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">    * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="comment">//BeanDefinitionRegistry 常用实现为 DefaultListableBeanFactory，也有其他 ApplicationContext 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boolean 参数，优先使用两个元素的枚举类型。</p><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><p>不要在重载方法中使用范型，或者继承关系类型。如 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAll(List&lt;?&gt; list);</span><br><span class="line"></span><br><span class="line">getAll(Collection&lt;?&gt; collection);</span><br></pre></td></tr></table></figure><p>需要调用哪个重载方法是在编译时作出决定的。</p><p>对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。</p><h2 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h2><p>可变参数其实是个语法糖</p><p>每次调用可变参数方法都会导致一次数组分配和初始化。有性能问题。可以适当的利用重载方法，替代可变参数方法。当然方法参数超过3个，就一起用可变参数，具体方法参数内容可以参考《代码整洁之道》。</p><p>最理想的参数数量是零，其次是一，再次是二，尽量避免三。有足够特殊的理由才能用三个以上参数（阿里巴巴Java开发手册：相同参数类型，相同业务含义，才可以使用 Java 的可变参数，可变参数放在最后，尽量不用可变参数，避免使用 Object）。</p><p><a href="https://yq.aliyun.com/articles/684075?spm=a2c4e.11155435.0.0.1e463312jtOsPe" target="_blank" rel="noopener">很久以前记的《代码整洁之道》的笔记</a></p><h2 id="返回零长度的数组或者集合，而不是-null"><a href="#返回零长度的数组或者集合，而不是-null" class="headerlink" title="返回零长度的数组或者集合，而不是 null"></a>返回零长度的数组或者集合，而不是 null</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getDigestKeyGen(String content)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">        bytes = xxxx;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨慎返回-optional"><a href="#谨慎返回-optional" class="headerlink" title="谨慎返回 optional"></a>谨慎返回 optional</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an &#123;<span class="doctag">@link</span> Optional&#125; wrapper for the specified dependency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;?&gt; createOptionalDependency(</span><br><span class="line">    DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName, <span class="keyword">final</span> Object... args) &#123;</span><br><span class="line"></span><br><span class="line">    DependencyDescriptor descriptorToUse = <span class="keyword">new</span> NestedDependencyDescriptor(descriptor) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :</span><br><span class="line">                    <span class="keyword">super</span>.resolveCandidate(beanName, requiredType, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Object result = doResolveDependency(descriptorToUse, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> (result <span class="keyword">instanceof</span> Optional ? (Optional&lt;?&gt;) result : Optional.ofNullable(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line"><span class="comment">// 这个 value 就是该对象的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"><span class="comment">// 这里是空的兜底的策略时，返回的 Optional null 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用的方法 <code>Optional.ofNullable(result)</code>，返回一个<code>Optional(null)</code>或者 <code>Optional</code> 的包装对象的。</p><p><strong>Optional&lt;T&gt; 类代表的是一个不可变的容器，它可以存放单个非 null 的 T 引用，或者什么内容都没有</strong>。</p><ol><li><p>永远不要通过返回 Optional 的方法返回 null，因为它彻底违背了 optional（可选的） 的本意。</p></li><li><p>容器类型含<code>集合</code>、<code>映射</code>、<code>Stream</code>、<code>数组</code>和<code>optional</code>，都不应该被包装在 optional 中。</p></li><li><p>永远不要返回基本包装类型的 optional 。已经提供了 <code>OptionalInt</code>，<code>OptionalDouble</code>，<code>OptionalLong</code>等。</p></li><li><p>永远都不适合用 optional 作为键、值，或者集合或做数组中的元素。</p></li><li><p>尽量不要将 Optional 用作返回值以外的任何其他用途。</p></li></ol><p>用了 Optional，你就必须在调用方，做相应的判断，因为如果使用 <code>Optional.ofNullable(obj)</code>它有最差返回 <code>private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</code></p><h2 id="为所有到处的-API-元素编写文档注释"><a href="#为所有到处的-API-元素编写文档注释" class="headerlink" title="为所有到处的 API 元素编写文档注释"></a>为所有到处的 API 元素编写文档注释</h2><p>《代码整洁之道》—— 最好的注释是方法本身（见名知意、简短 <code>不超过 50 行</code>、方法参数最好不要超过 3 个、少用可变参数）。</p><p>当然这是一种比较极端的说法，好的 API 应该至少写出 what why how，这个方法是什么，为什么这么实现，以及如何使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface BeanFactory</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Behaves the same as &#123;<span class="doctag">@link</span> #getBean(String)&#125;, but provides a measure of type</span></span><br><span class="line"><span class="comment"> * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the</span></span><br><span class="line"><span class="comment"> * required type. This means that ClassCastException can't be thrown on casting</span></span><br><span class="line"><span class="comment"> * the result correctly, as can happen with &#123;<span class="doctag">@link</span> #getBean(String)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.</span></span><br><span class="line"><span class="comment"> * Will ask the parent factory if the bean cannot be found in this factory instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType type the bean must match; can be an interface or superclass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanNotOfRequiredTypeException if the bean is not of the required type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure><p>使用<code>{@literal}</code>忽略尖括号等需要转义的内容。如 <code>{@literal r &lt; 1}</code></p><h1 id="General-Programing"><a href="#General-Programing" class="headerlink" title="General Programing"></a>General Programing</h1><h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p><strong>只在需要用到变量的前一步，去声明变量。</strong></p><p>下面是<code>AutowiredAnnotationBeanPostProcessor</code>覆盖<code>SmartInstantiationAwareBeanPostProcessor</code>的方法。</p><p>具体执行步骤 <code>AbstractAutowireCapaleBeanFactory#doCreateBean</code> -&gt; <code>AbstractAutowireCapaleBeanFactory#createBeanInstance</code> -&gt; <code>AbstractAutowireCapaleBeanFactory#determineConstructorsFromBeanPostProcessors</code> -&gt; <code>SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors</code>  -&gt;<code>AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors</code></p><p>在属性填充之前，创建 beanWrapper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName)</span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let's check for lookup methods here..</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.doWithMethods(beanClass, method -&gt; &#123;</span><br><span class="line">                Lookup lookup = method.getAnnotation(Lookup<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">"No BeanFactory available"</span>);</span><br><span class="line">                    <span class="comment">// 检查 Lookup 方法，去覆盖原来的方法</span></span><br><span class="line">                    LookupOverride override = <span class="keyword">new</span> LookupOverride(method, lookup.value());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        RootBeanDefinition mbd = (RootBeanDefinition) <span class="keyword">this</span>.beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">                        mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                        <span class="string">"Cannot apply @Lookup to beans without corresponding bean definition"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Lookup method resolution failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lookupMethodsChecked.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略后面代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 循环优先于 <code>while</code> 循环</p><h2 id="优先使用-foreach-而不是-for"><a href="#优先使用-foreach-而不是-for" class="headerlink" title="优先使用 foreach 而不是 for"></a>优先使用 foreach 而不是 for</h2><p>简洁、灵活、预防出错（当然在里面删除元素又进行遍历，是不行的）</p><p>不要在 foreach（增强 for 循环） 里面进行删除集合内部元素的操作。如果必要，请使用迭代器。</p><p><strong>什么时候不该用 foreach</strong></p><ol><li><p>解构过滤：就是上面的情况，使用 Collection#removeIf。</p></li><li><p>转换：就是要明确知道要替换的元素在哪几位的时候，予以替换的时候。</p></li><li><p>平行迭代：多层迭代，例如排序算法</p></li></ol><p><strong>正确的在遍历时删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">    Iterator&lt;User&gt; it = users.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        User user = it.next();</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span> &amp;&amp; <span class="string">"zhangSan"</span>.equals(user.name))&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="了解和使用类库"><a href="#了解和使用类库" class="headerlink" title="了解和使用类库"></a>了解和使用类库</h2><p>从 Java7 开始该使用 ThreadLocalRandom 而不是 Random</p><p>熟悉 java.lang、java.util、java.io及其子包中的内容。子包包括但不限于 java.util.concurrent，java.util.regex。</p><h2 id="如果需要精确的答案，避免使用-float-和-double"><a href="#如果需要精确的答案，避免使用-float-和-double" class="headerlink" title="如果需要精确的答案，避免使用 float 和 double"></a>如果需要精确的答案，避免使用 float 和 double</h2><p>float、double 适合科学计算。</p><p>使用 BigDecimal、Joda Money 进行金额计算。</p><p>JavaScript</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> != <span class="number">0.3</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">//0.1 +0.2===0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">0.3</span>;</span><br><span class="line">System.out.println(b-a == <span class="number">0.2</span>);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">double</span> d = b-a;</span><br><span class="line">System.out.println(d);<span class="comment">// 0.19999999999999998</span></span><br></pre></td></tr></table></figure><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>基本类型比包装类型更省内存，性能更高。当然，业务对性能要求不是非常高的，可以用装箱的类型。</p><p>自动拆装箱会带来一些隐藏的问题，在《阿里巴巴 Java 开发手册》中介绍，统一使用装箱类型。</p><p>如果基本类型和装箱基本类型混合使用，装箱基本类型则会自动拆箱。</p><p>自动拆装箱本质上是为了简化开发，添加此类语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时优化，自动装箱</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 实际上是 list.add(Integer.valueOf(1));</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 编译时优化，自动拆箱</span></span><br><span class="line">Integer a = <span class="number">129</span>;</span><br><span class="line">a = <span class="number">1</span> * a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动装箱时，会在 IntegerCache 中查找是否有缓存中的元素，有即返回，这个最大值可以设置，最小值为 -128，low=-128，</span></span><br><span class="line"><span class="comment">//  String integerCacheHighPropValue =</span></span><br><span class="line"><span class="comment">//                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果其他类型更合适，尽量避免使用字符串"><a href="#如果其他类型更合适，尽量避免使用字符串" class="headerlink" title="如果其他类型更合适，尽量避免使用字符串"></a>如果其他类型更合适，尽量避免使用字符串</h2><p>不适合代替枚举类型的值、聚合类型、能力表（capabilities）。</p><p>ThreadLocal 如果用 String 作为 Key，那将是全局共享的，不妥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚合类型</span></span><br><span class="line">String compoundKey = className + <span class="string">"#"</span> + i.next();</span><br><span class="line"><span class="comment">// Spring 中也是这么做的。 </span></span><br><span class="line">String methodName = className + <span class="string">"#"</span>+ methodName;</span><br></pre></td></tr></table></figure><p><code>1kb = 1024 byte = 1024 * 8 bit</code></p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>名称</td><td>长度</td><td>备注</td></tr><tr><td>byte</td><td>字节型</td><td>8bit</td><td>表示数据范围：-128~127</td></tr><tr><td>short</td><td>短整型</td><td>16bit</td><td></td></tr><tr><td>char</td><td>字符型</td><td>16bit</td><td></td></tr><tr><td>int</td><td>整型</td><td>32bit</td><td></td></tr><tr><td>long</td><td>长整型</td><td>8 byte</td><td></td></tr><tr><td>float</td><td>单精度浮点型</td><td>4 byte</td><td>精度：7-8位</td></tr><tr><td>double</td><td>双精度浮点型</td><td>8 byte</td><td></td></tr><tr><td>boolean</td><td>布尔型</td><td>true/false</td><td>实际用 byte 存储，0 为 false，1 为 true</td></tr></tbody></table><p>选择合适的类型，能使得占用内存更小。</p><p>当然，为防止伪共享，提高 CPU 执行效率，如果使用 volatile 关键字禁止 CPU 缓存，如果需要提升代码性能，需要额外填充其他对象。</p><p>如果一个对象包含线程局部变量且尺寸小于 64byte，就有可能发生伪共享。在Java7之前，一般通过对象填充的方式来避免伪共享问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java7 以前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedVolatileLong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java 8 加上注解，加上启动参数，自动填充。</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要给JVM加上启动项参数：</p><p><strong>-XX:-RestrictContended</strong></p><p>Hotspot虚拟机文档 “oops/oop.hp”有对Markword字段的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">64 bits:</span><br><span class="line">--------</span><br><span class="line">unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">Fruit fruit = <span class="keyword">new</span> Fruit();</span><br></pre></td></tr></table></figure><ul><li><p>Object 对象，Markword  8 个字节，kclass 4 个字节， 加起来 12 个字节，加上 4 个字节的对齐填充，占用的空间是 16 个字节。</p></li><li><p>Fruit 对象， Markword 8 个字节，kclass 4 个字节，还有个 size 成员变量，int类型占 4 个字节，加起来是 16 个字节，不需要对齐填充</p><p>缓存行非64字节宽的处理器。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。</p><p>共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p></li></ul><h2 id="了解字符串连接的性能"><a href="#了解字符串连接的性能" class="headerlink" title="了解字符串连接的性能"></a>了解字符串连接的性能</h2><p>避免在循环使用 <code>+</code> 拼接字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">    String str = <span class="string">"1"</span> + strs[i];</span><br><span class="line">    <span class="comment">// 实际代码为</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">  *sb.append(str);</span></span><br><span class="line"><span class="comment">  * sb.append(strs[i]);</span></span><br><span class="line"><span class="comment">  * sb.toString();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>更加灵活。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>实际碰到的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = aService.getList();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我需要按照构造器传入的 size 来截取 List，因为我客户端需要根据 pageSize 来获取指定 size 或小于该大小的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = aService.getList();</span><br><span class="line">    SubList subList = list.subList(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(subList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只是需要个 JSON 数组，我并不需要 ArrayList 的特殊的方法，这样就是<strong>严重耦合</strong>的代码。</p><p>这个改成下面的，是不是更好点？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; list = aService.getList();</span><br><span class="line">    <span class="keyword">return</span> list.subList(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 中大量使用接口来引用，而非具体实现类。代码尽量使用依赖注入接口类型，实现实际类与调用类解耦。</p><p>如果没有合适的接口，就用<strong>类层次结构中提供了必要功能的最小的具体类</strong>来引用对象。</p><p>即如果要使用<code>ArrayList.trimToSize()</code>就声明为 <code>ArrayList</code> 引用，这是一种编程习惯，只用你用到的，只提供你想给外部调用的，不是全部，是部分（部分可以是全部）。</p><p>Spring 中是采用的流水线的思维方式，将各个阶段，抽象了出来，每个阶段都有其对应的接口抽象。</p><p>每个阶段的抽象。</p><ol><li>BeanFactory</li><li>Resource</li><li>BeanDefinition</li><li>BeanWrapper</li></ol><p>每个阶段中的前置后置处理抽象</p><ol><li>BeanFactoryPostProcessor（BeanFactory 启动的时候，可以在 <code>AbstractApplicationContext#invokeBeanFactoryPostProcessors</code> 中找到答案，打断点，自己慢慢看，就知道 @Component 是在这里的哪一步解析的了，启动一个随便什么的 Spring Boot 项目，即可查看具体内容）</li><li>BeanDefinitionRegistryPostProcessor（BeanDefnition 注册的时候）</li><li>MergedBeanDefinitionPostProcessor（GenericBeanDefinition 和其他 BeanDefinition 有个合并的过程，合并成 RooBeanDefinition，如果你看过小马哥的讲解的，这个其实是 XML 配置里面会出现的情况，一个 &lt;bean/&gt; 就是一个 RootBeanDefinition，当然，它会先包装成 GenericBeanDefinition 再进行合并）</li><li>SmartInstantiationAwareBeanPostProcessor（一般带 Smart 的，都要先一步执行，例如 SmartInitializingSingleton，会在单例对象<strong>预实例化</strong>阶执行，SmartInstantiationAwareBeanPostProcessor 的实现的抽象类 <code>AbstractAdvisorAutoProxyCreator</code> 和 AOP 相关，就在这一步，对要拦截的 Bean 进行拦截，然后代理，这里会有 Pattern 正则来匹配的过程，@Transaction 也是在这一步做的）</li><li>InstantiationAwareBeanPostProcessor</li><li>DestructionAwareBeanPostProcessor</li><li>BeanPostProcessor（上面所有 BeanPostProcessor 的父类，就是最卑微的，最后执行）</li></ol><h2 id="接口优先于反射机制"><a href="#接口优先于反射机制" class="headerlink" title="接口优先于反射机制"></a>接口优先于反射机制</h2><p><strong>详情见</strong></p><p>Spring <code>BeanProcessor</code></p><p>InitializingBean 和 DisposableBean，它们也可以用 @PostConstruct 和 @PreDestroy 代替，当然，两者一起也是可以的，具体执行顺序。</p><ul><li><p>@PostConstruct</p></li><li><p>InitializingBean</p></li><li><p>自定义初始化方法 </p></li><li><p>@PreDestroy 标注方法</p></li><li><p>实现 DisposableBean 接口的 destroy() 方法</p></li><li><p>自定义销毁方法 (destroy-mehod)</p></li></ul><p>Spring MVC <code>Interceptor</code></p><p>给定了模版类，调用模版类的模版方法。</p><p>如果使用反射机制</p><ul><li>损失了编译时类型检查的优势</li><li>执行反射访问所需要的代码非常笨拙和冗长</li><li>性能损失</li></ul><h2 id="谨慎使用本地方法"><a href="#谨慎使用本地方法" class="headerlink" title="谨慎使用本地方法"></a>谨慎使用本地方法</h2><p>native method 是与平台相关的，破坏了 Java 的移植性，如非必须情况，要避免使用本地方法。</p><p>可能的必要情况</p><ul><li>需要调用 dll 文件</li><li>需要真正高性能的高精度算术运算。</li></ul><h2 id="谨慎地进行优化"><a href="#谨慎地进行优化" class="headerlink" title="谨慎地进行优化"></a>谨慎地进行优化</h2><p>不等同于不要持续重构代码</p><h2 id="遵守普遍接受的命名惯例"><a href="#遵守普遍接受的命名惯例" class="headerlink" title="遵守普遍接受的命名惯例"></a>遵守普遍接受的命名惯例</h2><ol><li>包名com.xxxx，域名反写</li><li>类名 抽象类，BaseXXXXX，AbstractXXXXXX</li><li>变量名 局部变量名，String xxxStr，</li><li>方法名 方法名应该是个动词，如 createBean，getBean，表示的是类的行为。</li><li>get 是获取单个对象，list 是获取多个对象。</li></ol><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p><strong>怪罪于</strong> StringBuilder sb = new StringBuilder(100); 命名为 sb 的人，是真的 SB。本来就是局部变量用于拼接字符串的，没有很大的实际意义。</p><p>有些现代工具（MyBatis）依赖 Beans 命名惯例，setter getter，从数据库中取出值后，赋值需要调用 setter 类型方法。</p><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h2><p>不要将异常作为普通的控制流。</p><h2 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可恢复情况</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.xxx.Driver"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编程错误使用 RuntimeException</span></span><br><span class="line"><span class="keyword">int</span> foo = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error 最好由 JVM 抛出，不适合自定义 Error</span></span><br></pre></td></tr></table></figure><h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>可以适当将 try catch 块重构为 if else 块。</p><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p>类越精简，加载类的速度越快，优先使用专家级的定义的异常。加粗表示更为高频使用的，如</p><ul><li><p>IndexOfBoundsException</p></li><li><p>NullPointException</p></li><li><p><strong>IllegalArgumentException</strong></p></li><li><p><em>IllegalStateException*</em></p></li><li><p>IllegalAccessException</p></li><li><p>ConcurrentModificationException</p></li><li><p>UnsupportedOperationException</p></li></ul><h2 id="抛出与抽象对应的异常"><a href="#抛出与抽象对应的异常" class="headerlink" title="抛出与抽象对应的异常"></a>抛出与抽象对应的异常</h2><p>更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。</p><p>如果在 MyBatis 中，写 resultType 写成不存在的类，会先抛出 ClassNotFoundException，然后层层抛出，到 Spring 创建 Bean 的步骤中。最终由 Servlet 容器捕获，然后停止启动项目。<strong>可以自己手动试试</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Constructor&lt;?&gt;[] ctors, @Nullable Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>)).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.ConstructorResolver</span></span><br><span class="line"><span class="comment">// ConstructorResolver.ArgumentsHolder createArgumentArray 方法里面</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object autowiredArgument = resolveAutowiredArgument(</span><br><span class="line">        methodParam, beanName, autowiredBeanNames, converter, fallback);</span><br><span class="line">    args.rawArguments[paramIndex] = autowiredArgument;</span><br><span class="line">    args.arguments[paramIndex] = autowiredArgument;</span><br><span class="line">    args.preparedArguments[paramIndex] = <span class="keyword">new</span> AutowiredArgumentMarker();</span><br><span class="line">    args.resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, <span class="keyword">new</span> InjectionPoint(methodParam), ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常链（exception chaining），如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。Spring 就是这样。</p><p>实际 WEB 开发也是不要将异常捕获，尽量将异常向上抛出，最终由 <strong>容器/框架 *<em>进行 *</em>捕获/抛出</strong>。编写自定义含 @ExceptionHandler的类，进行捕获异常。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表单验证时异常返回信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bindException 绑定异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 带异常的 ResponseEntiy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 杨逸林</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-29 22:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span>&lt;?&gt; <span class="title">defaultExceptionHandler</span>(<span class="title">BindException</span> <span class="title">bindException</span>) </span>&#123;</span><br><span class="line"><span class="comment">//处理返回的错误信息</span></span><br><span class="line">List&lt;ObjectError&gt; errors = bindException.getBindingResult().getAllErrors();</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(errors)) &#123;</span><br><span class="line">ObjectError objectError = errors.get(<span class="number">0</span>);</span><br><span class="line">ResultCode resultCode = ResultCode.FAILURE.setMessage(objectError.getDefaultMessage());</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(resultCode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意⚠️</p><p>这里必须使用 ResponseEntity，不要自定义的什么乱七八糟的返回，没有必要再套一层，HTTP 早就想到了，<strong>不要</strong>像下面这样返回！！多此一举，如果这么做，多半不了解 HTTP 的一些细节内容，前人早就帮你想好了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span> : <span class="string">"404"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"can't find any matches response"</span>,</span><br><span class="line">    <span class="attr">"data"</span> : <span class="string">"404"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做，只会徒增前端的负担。</p><h2 id="每个方法抛出的所有异常都要建立文档"><a href="#每个方法抛出的所有异常都要建立文档" class="headerlink" title="每个方法抛出的所有异常都要建立文档"></a>每个方法抛出的所有异常都要建立文档</h2><p>永远不要声明一个公有方法直接 “throws Exception”。无法让调用者判断该如何解决并捕获该异常。</p><p>有个例外，就是 main 方法，它可以被安全地声明抛出 Exception，因为它只通过虚拟机调用。</p><p>还有就是 Spring Boot 的 CommandRunner，ApplicationRunner 以及 Spring 的 InitializingBean。注意这里的 @throws 需要你写清楚，像下面那样。如何写，在我的另一个我在公司分享的【代码规范】文章里面有讲解、翻译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Invoked by the containing &#123;<span class="doctag">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class="line"><span class="comment">    * and satisfied &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, &#123;<span class="doctag">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class="line"><span class="comment">    * configuration and final initialization when all bean properties have been set.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class="line"><span class="comment">    * essential property) or if initialization fails for any other reason</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在细节消息中包含失败-捕获信息"><a href="#在细节消息中包含失败-捕获信息" class="headerlink" title="在细节消息中包含失败-捕获信息"></a>在细节消息中包含失败-捕获信息</h2><p>为了捕获失败，异常的细节信息应该包含“对该异常由贡献”的所有参数和域的值。</p><p>以下是 Spring 启动创建 Bean 时失败，抛出异常的堆栈异常信息。PS：就是上面说的 MyBatis 改了 resultType 的异常。<strong>这里就是按层级抛出异常的案例</strong>。注意：Spring 是以流水线（Pipeline）的形式来处理的 Bean，看过卓别林的《摩登时代》里面就有他在拧螺丝，是流水线上的一环，也是一个阶段的处理者。流水线是福特提出的，并且作用于福特汽车的生产，极大得提高了生产力。在软件行业同样适用，如果你懂了 Spring 是流水线的处理思想（没什么书上提到流水线和 Spring 的关系），你就懂了大半的 Spring，其他的注解解析，派生等等内容都不难。思想很重要，每个人都需要拥有多个学科的知识，例如达芬奇是<strong>画家</strong>、科学家、发明家。这个观念在查理·芒格的《穷查理宝典》中反复被提及，值得一看的书籍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'callEvaluationController' defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/api/CallEvaluationController.class]: Unsatisfied dependency expressed through constructor parameter 0;</span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'userServiceImpl'</span>: Unsatisfied dependency expressed through method <span class="string">'setUserMapper'</span> parameter <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userMapper' defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/dao/main/UserMapper.class]: Cannot resolve reference to bean 'mainSqlSessionTemplate' while setting bean property 'sqlSessionTemplate'; </span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'mainSqlSessionTemplate' defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Unsatisfied dependency expressed through method 'sqlSessionTemplate' parameter 0;</span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mainSqlSessionFactory' defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Bean instantiation via factory method failed; </span><br><span class="line"></span><br><span class="line">nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method <span class="string">'sqlSessionFactory'</span> threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: <span class="string">'file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]'</span>;</span><br><span class="line"></span><br><span class="line">nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is 'file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]'. Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Cause: org.apache.ibatis.type.TypeException: Could not resolve type alias 'java1.lang.Integer'.  Cause: java.lang.ClassNotFoundException: Cannot find class: java1.lang.Integer</span><br><span class="line"> <span class="comment">// 这其实是一行异常信息，我用换行分离出来 </span></span><br><span class="line"><span class="comment">// 层层嵌套，将必要的信息给暴露出来。</span></span><br></pre></td></tr></table></figure><p>不要在细节消息中包含密码、密钥以及类似的信息。输出异常消息日志时，或者正常日志时，一定要对敏感信息（用户名密码，用户名等等信息）进行脱敏操作。</p><h2 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h2><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p><p>使用 JDBC 操作数据库进行增/删/改时，出现失败的情况，应该进行事务回滚。</p><p>分布式系统中的 GET 操作即使失败，也要保持幂等性。</p><p>// TODO Spring Cloud 的中就是这么 GET 默认为幂等的，会一直调用，直到你没出错为止。这个就需要提到 HATEOS 以及 RESTful 的一些约定的一些内容。</p><h2 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h2><p>空的 catch 块会使异常达不到应有的目的。</p><p>如果选择忽略异常，catch 块中应该包含一条注释，说明情况，并将异常变量命名成 ignored</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(TimeoutException | ExecutionException ignored)&#123;</span><br><span class="line">    <span class="comment">// 这是一条注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>不要使用 Thread#stop 方法。</p><p>除非读和写操作都被同步，否则无法保证同步能起作用。</p><p>避免线程不安全的条件，可以有，避免共享，没有共享就没有伤害，使用 Synchronized/volatile/Atomic 类保证线程安全。</p><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><p>使用 JUC 容器，如CopyOnWriteArrayList。</p><p>// TODO 死锁代码</p><h2 id="executor、task、stream-优先于线程"><a href="#executor、task、stream-优先于线程" class="headerlink" title="executor、task、stream 优先于线程"></a>executor、task、stream 优先于线程</h2><p>不要用 Executors 创建线程池，里面具体实现有无界队列，Integer.MAX_VALUE 等坑人的定义。无界队列会一直堆积请求，直到OOM，应该使用 ArrayBlockingQueue 这种有界队列。使用 Guava 中 ThreadFactoryBuilder 创建 ThreadFactory，而不是继承原生的（不仅麻烦，而且很多东西其实是重复的，就是为了给线程加个名字和其他一些自定义的内容），也可以用 Spring 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"><span class="comment">// 核心线程数，最大线程数，等待时间，时间单位，线程队列（应该用有界队列 ArrayBlockingQueue），线程工厂（继承 ThreadFactory），系统自带的拒绝策略 4 种 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ol><li>AbortPolicy：中止策略是默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException 调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</li><li>DiscardPolicy：当新提交的任务无法保存到队列中等待执行时，抛弃策略会悄悄抛弃该任务。</li><li>CallerRunsPolicy：调用者运行（Caller-Runs）策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛弃异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行该任务。</li><li>DiscardOldestPolicy：抛弃最旧的（Discard-Oldest）策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，那么”抛弃最旧的“策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。</li></ol><p>ForkJoinTask。// TODO 《Java 并发编程的艺术》解释，以及代码。Redis 子线程 Fork 父线程，进行集群同步。</p><p>并发的 Stream 是在 Fork Join 池上编写的。</p><h2 id="并发工具优先于-wait-和-notify"><a href="#并发工具优先于-wait-和-notify" class="headerlink" title="并发工具优先于 wait 和 notify"></a>并发工具优先于 wait 和 notify</h2><ul><li>Executor FrameWork </li><li>JUC 容器 ConcurrentHashMap（而不是 Collections.synchronizedMap/HashTable）</li><li>同步器 CountDownLatch，Semaphore,CyclicBarrier 和 Exchanger 等</li></ul><p>对于间歇式的定时，始终应该优先使用 System.nanoTime 而不是 System.currentTimeMillis</p><p>// TODO Spring 同步机制代码补充</p><p>始终应该使用 wait 循环模式来调用 wait 方法，永远不要在循环之外调用 wait 方法。</p><p>一般情况下，优先使用 notifyAll 方法。// 极客时间《并发编程》代码补充</p><h2 id="线程安全性的文档化"><a href="#线程安全性的文档化" class="headerlink" title="线程安全性的文档化"></a>线程安全性的文档化</h2><p>一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。</p><ul><li>不可变的（immutable）—— String、Long、BigInteger</li><li>无条件的线程安全（unconditionally  thread-safe）—— 这个类的实例是可变的，但是这个类有着足够的内部同步。AtomicInteger、ConcurrentHashMap</li><li>有条件的线程安全（conditionally thread-safe）—— 除了有些方法为进行安全的并发使用而需要外部同步之外，和无条件的线程安全相同。Collections.synchronized 包装返回的集合。</li><li>非线程安全（not thread-safe）—— 类实例是可变的。ArrayList、HashMap</li><li>线程对立的（thread-hostile）—— 类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。// TODO ThreadLocal？</li></ul><p>使用类内部私有锁对象。lock 域应该始终声明为 final。// TODO Spring 中也是这么做的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><p>Lazy Initialization 是指延迟到需要域的值时才将它初始化的行为。Spring Boot 中有 @Lazy 标注是否延迟初始化，如果标记了，则将会该 Bean 进行延迟初始化，只有在其他类真正使用时，进行初始化。</p><p><strong>大多数情况下，非延迟初始化优先于延迟初始化。</strong></p><p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）</p><p>除非绝对必要，否则就不要这么做。</p><p><strong>如果处于性能的考虑而需要对静态域使用延迟初始化，就使用 Lazy Initiazlization Holder Class 模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式（Double-Check Idiom）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 构造器检查，防止反射多次创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(instance != <span class="keyword">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 中使用单例注册表（Bean 容器）控制 Bean 的单例。</p><p><strong>有时可能需要延迟初始化一个可以接受重复初始化的实例域。可以使用单重检查模式（Single-Check Idiom）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FieldType result = filed;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">        field = result = computeFieldValue()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><p><strong>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的</strong></p><p>如果一个程序不能工作，是因为某些线程无法像其他线程那样获得足够的 CPU 时间片，那么，不要企图调用 Thread.yield 来 “修正” 该程序。</p><p>线程优先级时 Java 平台上最不可移植的特征了。设置了优先级，不代表一定会按优先级执行，而是“看情况”。</p><h1 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize"></a>Serialize</h1><h2 id="其他方法优先于-Java-序列化"><a href="#其他方法优先于-Java-序列化" class="headerlink" title="其他方法优先于 Java 序列化"></a>其他方法优先于 Java 序列化</h2><p>如果使用 Java 自带的反序列化，以下层次非常高的结构，会导致系统反序列化时占用大量资源。使用 JSON 代替 Java 中的序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] bomb()&#123;</span><br><span class="line">Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; s1 = root;</span><br><span class="line">    Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(ini i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123; </span><br><span class="line">        Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        t1.add(<span class="string">"foo"</span>);</span><br><span class="line">        s1.add(t1);</span><br><span class="line">        s1.add(t2);</span><br><span class="line">        s2.add(t1);</span><br><span class="line">        s2.add(t2);</span><br><span class="line">        s1 = t1;</span><br><span class="line">        s2 = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialize(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨慎地实现-Serializable-接口"><a href="#谨慎地实现-Serializable-接口" class="headerlink" title="谨慎地实现 Serializable 接口"></a>谨慎地实现 Serializable 接口</h2><p>BigInteger、Instant 等值类应该实现 Serializable 接口，大多数的集合类也应该如此。代表活动实体的类，如线程池，一般不应该实现 Seriallizable 接口。</p><p>内部类不该实现 Serializable。</p><h2 id="考虑使用自定义的序列化形式"><a href="#考虑使用自定义的序列化形式" class="headerlink" title="考虑使用自定义的序列化形式"></a>考虑使用自定义的序列化形式</h2><p>跨语言的 Socket 通信，是自己实现序列化机制，包括 Redis，是以纯文本格式，换行的方式分隔操作符。</p><p>transient 表示该字段不能被序列化，当然实现了 // TODO 实现某个接口后，在方法中写明了字段，也是可以序列化的。</p><h2 id="保护性地编写-readObject-方法"><a href="#保护性地编写-readObject-方法" class="headerlink" title="保护性地编写 readObject 方法"></a>保护性地编写 readObject 方法</h2><p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，必须做保护性拷贝。</p><h2 id="对于实例控制，枚举类型优先于-readObject"><a href="#对于实例控制，枚举类型优先于-readObject" class="headerlink" title="对于实例控制，枚举类型优先于 readObject"></a>对于实例控制，枚举类型优先于 readObject</h2><p>// TODO 不太理解</p><h2 id="考虑用序列化代理代替序列化实例"><a href="#考虑用序列化代理代替序列化实例" class="headerlink" title="考虑用序列化代理代替序列化实例"></a>考虑用序列化代理代替序列化实例</h2><p>使用静态内部类，代理外部类序列化内容，以及反序列化。</p><p>// TODO 代码</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><blockquote><p><a href="https://juejin.im/post/5c6698b6f265da2da23d17a8" target="_blank" rel="noopener">关于Integer面试的一个问题</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">VM系列三:JVM参数设置、分析</a></p></blockquote><blockquote><p><a href="http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2008-April/000110.html" target="_blank" rel="noopener">What does AggressiveOpts do with my timings?</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">科普：为什么 String hashCode 方法选择数字31作为乘子</a></p></blockquote><blockquote><p><a href="https://cloud.tencent.com/developer/article/1593982" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1593982</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/xx326664162/article/details/51743969" target="_blank" rel="noopener">https://blog.csdn.net/xx326664162/article/details/51743969</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/43161690" target="_blank" rel="noopener">无声的性能杀手-伪共享(FalseSharing)</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/6844903873346453518" target="_blank" rel="noopener">重学Java-一个Java对象到底占多少内存</a></p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script</summary>
        
      
    
    
    
    <category term="notes" scheme="https://young1lin.github.io/categories/notes/"/>
    
    
    <category term="Effective Java" scheme="https://young1lin.github.io/tags/Effective-Java/"/>
    
  </entry>
  
</feed>
